{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-03-28 18:42:49","docid":0,"fillcolor":"fffeeb73","id":1,"markups":[{"date":"2022-03-28 18:42:52","docid":0,"fillcolor":"fffeeb73","id":2,"markups":[{"date":"2022-03-28 18:42:56","docid":0,"fillcolor":"fffeeb73","id":3,"originaltext":"1) 为基本数据类型定义新的类型名","page":0,"textblocks":[{"first":[36.349998474121094,588.1248779296875,6.348930358886719,13.5],"last":[183.54844665527344,588.1248779296875,10.289993286132812,13.5],"length":17,"rects":[[36.349998474121094,588.1248779296875,157.48844146728516,13.5]],"start":535,"text":"1) 为基本数据类型定义新的类型名"}],"type":5},{"date":"2022-03-28 18:43:03","docid":0,"fillcolor":"fffeeb73","id":4,"markups":[{"date":"2022-03-28 18:46:13","docid":0,"fillcolor":"fffeeb73","id":9,"markups":[{"date":"2022-03-28 18:46:21","docid":0,"fillcolor":"fffeeb73","id":10,"originaltext":"1、定义了一个新的结构类型，代码如下所示：","page":2,"textblocks":[{"first":[36.349998474121094,49.574951171875,6.891361236572266,14.5],"last":[266.68133544921875,49.574951171875,11.760009765625,14.5],"length":21,"rects":[[36.349998474121094,49.574951171875,242.09134674072266,14.5]],"start":92,"text":"1、定义了一个新的结构类型，代码如下所示："}],"type":5},{"date":"2022-03-28 18:46:24","docid":0,"fillcolor":"fffeeb73","id":11,"markups":[{"date":"2022-03-28 18:46:32","docid":0,"fillcolor":"fffeeb73","id":13,"originaltext":"typedef struct tagPoint Point","page":2,"textblocks":[{"first":[76.03999328613281,286.9620666503906,5.144996643066406,10.28997802734375],"last":[229.65499877929688,286.9620666503906,5.1450042724609375,10.28997802734375],"length":29,"rects":[[76.03999328613281,286.9620666503906,158.760009765625,10.28997802734375]],"start":785,"text":"typedef struct tagPoint Point"}],"type":5}],"originaltext":"2、使用 typedef 为这个新的结构起了一个别名，叫 Point，即：","page":2,"textblocks":[{"first":[36.349998474121094,255.4099884033203,6.891361236572266,16.499984741210938],"last":[360.9085693359375,255.4099884033203,11.760009765625,16.499984741210938],"length":37,"rects":[[36.349998474121094,255.4099884033203,336.3185806274414,16.499984741210938]],"start":179,"text":"2、使用 typedef 为这个新的结构起了一个别名，叫 Point，即："}],"type":5}],"originaltext":"结构体 struct Point 为新的数据类型，在定义变量的时候均要向上面的调用方法一样有保留字 struct，而不能像 int 和 double 那样直接使用 Point 来定义变量。现在，我们利用 typedef 定义这个结构体","page":1,"textblocks":[{"first":[83.3899917602539,625.81494140625,11.760002136230469,14.5],"last":[83.3899917602539,664.2999267578125,11.760002136230469,14.5],"length":119,"rects":[[83.3899917602539,625.81494140625,471.0831527709961,14.5],[36.349998474121094,644.2249145507812,518.7846450805664,16.5],[36.349998474121094,664.2999267578125,58.79999542236328,14.5]],"start":320,"text":"结构体 struct Point 为新的数据类型，在定义变量的时候均要向上面的调用方法一样有保留\n字 struct，而不能像 int 和 double 那样直接使用 Point 来定义变量。现在，我们利用 typedef 定义\n这个结构体"}],"type":5}],"originaltext":"2) 为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称","page":1,"textblocks":[{"first":[36.349998474121094,367.625,6.348930358886719,13.5],"last":[358.47845458984375,367.625,10.290008544921875,13.5],"length":34,"rects":[[36.349998474121094,367.625,332.41846466064453,13.5]],"start":219,"text":"2) 为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称"}],"type":5},{"date":"2022-03-28 18:43:35","docid":0,"fillcolor":"fffeeb73","id":5,"originaltext":"3) 为数组定义简洁的类型名称","page":3,"textblocks":[{"first":[36.349998474121094,408.0498046875,6.348930358886719,13.5],"last":[162.96844482421875,408.0498046875,10.289993286132812,13.5],"length":15,"rects":[[36.349998474121094,408.0498046875,136.90843963623047,13.5]],"start":209,"text":"3) 为数组定义简洁的类型名称"}],"type":5},{"date":"2022-03-28 18:43:36","docid":0,"fillcolor":"fffeeb73","id":6,"originaltext":"4) 为指针定义简洁的名称","page":3,"textblocks":[{"first":[36.349998474121094,516.564697265625,6.348930358886719,13.5],"last":[142.38844299316406,516.564697265625,10.289993286132812,13.5],"length":13,"rects":[[36.349998474121094,516.564697265625,116.32843780517578,13.5]],"start":264,"text":"4) 为指针定义简洁的名称"}],"type":5},{"date":"2022-03-28 18:43:41","docid":0,"fillcolor":"fffeeb73","id":7,"markups":[{"date":"2022-03-28 18:43:54","docid":0,"fillcolor":"fffeeb73","id":8,"originaltext":"在上面的代码中，“const PCHAR” 是否相当于 “const char*” 呢？ 答案是否定的，原因很简单，typedef 是用来定义一种类型的新别名的，它不同于宏，不是简单的字符串替换（有关 typedef 和 #define 的区别，请猛击这里了解详情）","page":4,"textblocks":[{"first":[36.349998474121094,201.08511352539062,11.759998321533203,15.5],"last":[383.10919189453125,257.6800842285156,11.760009765625,15.5],"length":135,"rects":[[36.349998474121094,201.08511352539062,373.19742584228516,15.5],[36.349998474121094,238.469970703125,516.9460830688477,14.5],[36.349998474121094,257.6800842285156,358.51920318603516,15.5]],"start":125,"text":"在上面的代码中，“const PCHAR” 是否相当于 “const char*” 呢？ \n答案是否定的，原因很简单，typedef 是用来定义一种类型的新别名的，它不同于宏，不是简单的字\n符串替换（有关 typedef 和 #define 的区别，请猛击这里了解详情）"}],"type":5}],"originaltext":"小心使用 typedef 带来的陷阱","page":4,"textblocks":[{"first":[36.349998474121094,77.885009765625,17.639999389648438,22.5],"last":[256.5677490234375,77.885009765625,17.6400146484375,22.5],"length":18,"rects":[[36.349998474121094,77.885009765625,237.8577651977539,22.5]],"start":72,"text":"小心使用 typedef 带来的陷阱"}],"type":5}],"originaltext":"typedef的4种用法","page":0,"textblocks":[{"first":[36.349998474121094,525.4998779296875,7.302959442138672,22.5],"last":[168.7382049560547,525.4998779296875,17.639999389648438,22.5],"length":12,"rects":[[36.349998474121094,525.4998779296875,150.02820587158203,22.5]],"start":494,"text":"typedef的4种用法"}],"type":5}],"originaltext":"typedef的用法，C语言typedef详解","page":0,"textblocks":[{"first":[36.349998474121094,138.75990295410156,7.128028869628906,24.5],"last":[322.8662414550781,138.75990295410156,19.1099853515625,24.5],"length":23,"rects":[[36.349998474121094,138.75990295410156,305.62622833251953,24.5]],"start":110,"text":"typedef的用法，C语言typedef详解"}],"type":5}],"maxid":13,"scalingratio":50,"title":"typedef的用法，C语言typedef详解","unimportant":[]}