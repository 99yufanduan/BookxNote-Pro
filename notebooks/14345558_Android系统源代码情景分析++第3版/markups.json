{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2023-07-11 15:54:56","docid":0,"id":1,"linecolor":"ff59c6ff","page":0,"rect":[0,0.8046875,1,1.8046875],"title":"封面","type":8,"uuid":"504643d9a41a837a0d22e4159d862a87"},{"date":"2023-07-11 15:54:56","docid":0,"id":2,"linecolor":"ff59c6ff","page":1,"rect":[0,0.2855224609375,1,1.2855224609375],"title":"书名","type":8,"uuid":"b43f9d8171ad51845265fa7e17d59dcd"},{"date":"2023-07-11 15:54:56","docid":0,"id":3,"linecolor":"ff59c6ff","page":2,"rect":[0,0.00921630859375,1,1.00921630859375],"title":"版权","type":8,"uuid":"d5c0d104257820a164e407f56893bfd3"},{"date":"2023-07-11 15:54:56","docid":0,"id":4,"linecolor":"ff59c6ff","page":3,"rect":[0,0.2855224609375,1,1.2855224609375],"title":"前言","type":8,"uuid":"bfd286dde692eae10d202dbb8fa53e33"},{"date":"2023-07-11 15:54:56","docid":0,"id":5,"linecolor":"ff59c6ff","page":5,"rect":[0,0.2855224609375,1,1.2855224609375],"title":"目录","type":8,"uuid":"126bffee9f13459ddb4483f60ff37fd7"},{"date":"2023-07-18 12:22:28","docid":0,"fillcolor":"fffeeb73","id":874,"markups":[{"date":"2023-07-18 12:26:11","docid":0,"fillcolor":"fffeeb73","id":886,"markups":[{"date":"2023-07-18 12:24:37","docid":0,"fillcolor":"fffeeb73","id":878,"originaltext":"最底层的是各种硬件设备，往上一层是Bootloader。当我们按下手机电源键时，Bootloade漫：第一个跑起来的程序，负责初始化硬件，以及将OS启动起来。使用最广泛的Bootloader是一个叫uboot的程序，它支持非常多的体系结构。经过编译后，uhoot会生成一个心叩t.bin镜像，将这个镜像烧到设备上的一个特定分区中，就可以作为Bootloade计吏用了","page":24,"textblocks":[{"first":[56.153900146484375,577.5446166992188,10.731498718261719,9.3599853515625],"last":[248.53817749023438,626.024658203125,7.968109130859375,9.3599853515625],"length":186,"rects":[[56.153900146484375,577.5446166992188,445.91015625,9.3599853515625],[34.79389953613281,593.8546142578125,467.75010681152344,9.1199951171875],[34.54389953613281,609.9446411132812,467.5200653076172,9.3599853515625],[35.034000396728516,626.024658203125,221.47228622436523,9.3599853515625]],"start":935,"text":"最底层的是各种硬件设备，往上一层是Bootloader。当我们按下手机电源键时，Bootloade漫：第一\n个跑起来的程序，负责初始化硬件，以及将OS启动起来。使用最广泛的Bootloader是一个叫uboot的程\n序，它支持非常多的体系结构。经过编译后，uhoot会生成一个心叩t.bin镜像，将这个镜像烧到设备上\n的一个特定分区中，就可以作为Bootloade计吏用了"}],"type":5,"uuid":"ec04241fab968a5d0f65fb65736af24f"},{"date":"2023-07-18 12:24:39","docid":0,"fillcolor":"fffeeb73","id":879,"originaltext":"Bootloader支持交互式启动，也就是说，我们可以让Bootloader初始化完成硬件之后，不是马上去启动OS,而是停留在当前状态，等待用户输人命令告诉它接下来该干什么。这种启动方式就称为Fru叫tboot模式。通常，在关机状态下，同时按下音量下键和电源键，可以进人Fasthoot模式","page":24,"textblocks":[{"first":[56.153900146484375,641.8646240234375,4.728000640869141,9.5999755859375],"last":[433.03399658203125,674.2646484375,8.480010986328125,9.1199951171875],"length":147,"rects":[[56.153900146484375,641.8646240234375,445.9100646972656,9.5999755859375],[34.313899993896484,658.4246215820312,467.51071548461914,9.1199951171875],[34.313899993896484,674.2646484375,407.2001075744629,9.1199951171875]],"start":1123,"text":"Bootloader支持交互式启动，也就是说，我们可以让Bootloader初始化完成硬件之后，不是马上\n去启动OS,而是停留在当前状态，等待用户输人命令告诉它接下来该干什么。这种启动方式就称为\nFru叫tboot模式。通常，在关机状态下，同时按下音量下键和电源键，可以进人Fasthoot模式"}],"type":5,"uuid":"1562998974c8944970b519805f68d349"},{"date":"2023-07-18 12:24:42","docid":0,"fillcolor":"fffeeb73","id":880,"originaltext":"在Fasthoot模式下，我们可以通过fasthootT具将一个镜像(recovery.img)刷人设备的Recovery分区。这个过程就称为刷Recovery。Recovery镜像包含一个小型的系统。通常，在关机状态下，同时按下音量上键和电源键，就可以将这个系统运行起来。这种启动方式就称为Recovery模式。","page":24,"textblocks":[{"first":[55.67399978637695,690.3446044921875,9.84000015258789,9.1199951171875],"last":[436.3039855957031,722.74462890625,3.1199951171875,9.1199951171875],"length":159,"rects":[[55.67399978637695,690.3446044921875,446.1498832702637,9.1199951171875],[35.034000396728516,706.4146118164062,466.31261825561523,9.1199951171875],[34.313899993896484,722.74462890625,405.11008071899414,9.1199951171875]],"start":1272,"text":"在Fasthoot模式下，我们可以通过fasthootT具将一个镜像(recovery.img)刷人设备的Recovery分\n区。这个过程就称为刷Recovery。Recovery镜像包含一个小型的系统。通常，在关机状态下，同时按\n下音量上键和电源键，就可以将这个系统运行起来。这种启动方式就称为Recovery模式。"}],"type":5,"uuid":"ca3d54f71bb97a06f2e9d6901a37c091"},{"date":"2023-07-18 12:24:47","docid":0,"fillcolor":"fffeeb73","id":881,"originaltext":"在Recovery模式下，我们可以修改正常模式下的系统，也就是平时开机进入的系统。在正常模式下，系统包含System和Boot两个核心分区。System分区包含Android运行时框架、系统App以及预装的第芒方App等；而Boot分区包含内核和根文件系统。刷入System和Boot分区的两个镜像分别称为system.img和boot.img。通常将它们打包和压缩成一个zip文件，例如update.zip,并且将它上传到手机的叫card上。这样当进入Recovery模式时，就可以在Recovery界面上使用该zip包更新在正常模式下使用的系统了。这个过程就是通常所说的刷ROM。","page":25,"textblocks":[{"first":[47.9838981628418,55.05284118652344,9.60000228881836,9.360000610351562],"last":[198.2239990234375,135.70269775390625,3.600006103515625,9.1199951171875],"length":297,"rects":[[47.9838981628418,55.05284118652344,447.1234931945801,9.360000610351562],[26.143999099731445,71.38280487060547,468.49003410339355,9.120002746582031],[26.143999099731445,87.22282409667969,468.9600658416748,9.360000610351562],[26.143999099731445,103.54270935058594,468.9602794647217,9.360000610351562],[26.143999099731445,119.85283660888672,468.97099113464355,9.120002746582031],[26.86400032043457,135.70269775390625,174.96000480651855,9.1199951171875]],"start":11,"text":"在Recovery模式下，我们可以修改正常模式下的系统，也就是平时开机进入的系统。在正常模式\n下，系统包含System和Boot两个核心分区。System分区包含Android运行时框架、系统App以及预装的\n第芒方App等；而Boot分区包含内核和根文件系统。刷入System和Boot分区的两个镜像分别称为system.\nimg和boot.img。通常将它们打包和压缩成一个zip文件，例如update.zip,并且将它上传到手机的叫card\n上。这样当进入Recovery模式时，就可以在Recovery界面上使用该zip包更新在正常模式下使用的系统\n了。这个过程就是通常所说的刷ROM。"}],"type":5,"uuid":"631da2dcea5bce70a346c7be00a119e5"},{"date":"2023-07-18 12:24:56","docid":0,"id":882,"imgfile":"84565c55eeda4924c4eb1b45dd747986.png","linecolor":"ffa0ec6f","linewidth":2,"page":25,"rect":[103.79999690651903,167.39999501109136,433.7999870717529,384.5999885380271],"type":2,"uuid":"5468734fba11ed915ed8606beb37a293"}],"originaltext":"1.7 为几机编译ROM","page":24,"textblocks":[{"first":[33.77389907836914,85.05464172363281,7.602100372314453,13.199996948242188],"last":[179.35391235351562,85.05464172363281,13.600006103515625,13.199996948242188],"length":12,"rects":[[33.77389907836914,85.05464172363281,159.1800193786621,13.199996948242188]],"start":25,"text":"1.7 为几机编译ROM"}],"type":5,"uuid":"1e12ca00102983c6809e0e726ef244bb"}],"originaltext":"第一章准备知识","page":12,"textblocks":[{"first":[39.35390090942383,129.2146453857422,16.079998016357422,15.360000610351562],"last":[147.94398498535156,165.46461486816406,36.1199951171875,25.199996948242188],"length":8,"rects":[[39.35390090942383,129.2146453857422,88.30999374389648,15.360000610351562],[39.58399963378906,165.46461486816406,144.47998046875,25.199996948242188]],"start":0,"text":"第勹章\n准备知识"}],"type":5,"uuid":"3dd98e0d0066c0a7d4d57e4171752b25"},{"date":"2023-07-18 12:25:13","docid":0,"fillcolor":"fffeeb73","id":883,"markups":[{"date":"2023-07-18 12:25:49","docid":0,"fillcolor":"fffeeb73","id":884,"originaltext":"Linux内核源代码是遵循GPL'协议的，即如果我们在Android系统所使用的Linux内核中添加或者修改了代码，那么就必须将它们公开","page":31,"textblocks":[{"first":[416.8739013671875,289.3028259277344,4.944000244140625,9.1199951171875],"last":[78.85130310058594,321.6928405761719,10.66290283203125,9.3599853515625],"length":70,"rects":[[416.8739013671875,289.3028259277344,67.19012451171875,9.1199951171875],[14.873900413513184,305.1328125,469.18988132476807,9.600006103515625],[14.873900413513184,321.6928405761719,74.640305519104,9.3599853515625]],"start":234,"text":"Linux内核源代\n码是遵循GPL'协议的，即如果我们在Android系统所使用的Linux内核中添加或者修改了代码，那么就\n必须将它们公开"}],"type":5,"uuid":"4c9841e53dde42acf40a9bfaea79065c"},{"date":"2023-07-18 12:25:53","docid":0,"fillcolor":"fffeeb73","id":885,"originaltext":"，其中，内核空间仍然是以硬件驱动模块的形式来支持，不过它只提供简单的硬件访问通道；而用户空间以硬件抽象层模块的形式来支持，它封装了硬件的实现细节和参数。这样就可以保护移动设备厂商的利益了。","page":31,"textblocks":[{"first":[207.51907348632812,418.662841796875,10.636398315429688,9.1199951171875],"last":[261.5939025878906,451.0628356933594,3.3599853515625,9.3599853515625],"length":96,"rects":[[207.51907348632812,418.662841796875,276.54669189453125,9.1199951171875],[15.11400032043457,434.98272705078125,468.9609203338623,9.1199951171875],[15.343899726867676,451.0628356933594,249.60998821258545,9.3599853515625]],"start":608,"text":"，其中，内核空间仍然是以硬件驱动模块的形式来支持，不\n过它只提供简单的硬件访问通道；而用户空间以硬件抽象层模块的形式来支持，它封装了硬件的实现\n细节和参数。这样就可以保护移动设备厂商的利益了。"}],"type":5,"uuid":"cd840a4c42aaf4de769aeceb0e591542"},{"date":"2023-07-18 12:26:27","docid":0,"fillcolor":"fffeeb73","id":887,"markups":[{"date":"2023-07-18 12:26:40","docid":0,"fillcolor":"fffeeb73","id":888,"originaltext":"硬件访问服务必须册过Java本地接口(Jmal\\atiYe lnterfacp, JNI)来叫用硬件抽象层模块的接rI","page":56,"textblocks":[{"first":[408.82427978515625,217.30462646484375,10.626708984375,9.1199951171875],"last":[377.92401123046875,234.09463500976562,2.763885498046875,8.160003662109375],"length":60,"rects":[[408.82427978515625,217.30462646484375,95.640380859375,9.1199951171875],[36.95389938354492,234.09463500976562,343.7339973449707,8.160003662109375]],"start":487,"text":"硬件访问服务必须册\n过Java本地接口(Jmal\\atiYe lnterfacp, JNI)来叫用硬件抽象层模块的接rI"}],"type":5,"uuid":"351eb883d32d66bbe47147c6feb58d4f"},{"date":"2023-07-18 12:26:49","docid":0,"fillcolor":"fffeeb73","id":889,"originaltext":"Android系统的硬件访问服务通常珆行在系统进程Sy、IPlll1中，间使川这些硬件访问服务的应川行厅己行h另外的进和中，即应川程序需婓通过进和间通估机制来访问这此硬fl访间服务Android系统捉供f种高效的进程间通估机制Bim伈进和间通估机制2.肋川程序就是通过它来访问运们什系统进和SystPlll中的硬件访问服务的Bim加进和间通信机制要求捉供服务的－方必须实现一个具介跨进程访问能力的服务接口．以便使川服务的－方可以通过这个服务接门来访问它因此，在实现硬件访问服务之前，我们首先哎定义它的服务接口","page":56,"textblocks":[{"first":[58.79389953613281,249.46463012695312,4.799999237060547,9.1199951171875],"last":[247.94003295898438,331.0646057128906,10.525787353515625,8.6400146484375],"length":259,"rects":[[58.79389953613281,249.46463012695312,446.16075134277344,9.1199951171875],[37.42399978637695,266.26458740234375,467.04999923706055,8.6400146484375],[36.95389938354492,281.8546142578125,467.7599678039551,8.8800048828125],[38.153900146484375,298.66461181640625,466.3128356933594,8.6400146484375],[36.95389938354492,314.7445983886719,467.75004959106445,8.6400146484375],[37.42399978637695,331.0646057128906,221.04182052612305,8.6400146484375]],"start":549,"text":"Android系统的硬件访问服务通常珆行在系统进程Sy、IPlll1中，间使川这些硬件访问服务的应川行\n厅己行h另外的进和中，即应川程序需婓通过进和间通估机制来访问这此硬fl访间服务Android系\n统捉供f种高效的进程间通估机制Bim伈进和间通估机制2.肋川程序就是通过它来访问运们什\n系统进和SystPlll中的硬件访问服务的Bim加进和间通信机制要求捉供服务的－方必须实现一个具介\n跨进程访问能力的服务接口．以便使川服务的－方可以通过这个服务接门来访问它因此，在实现硬\n件访问服务之前，我们首先哎定义它的服务接口"}],"type":5,"uuid":"747b997b93bf63f1471adf0be734cf09"}],"originaltext":"2.4 Jf发Android硬件访问服务","page":56,"textblocks":[{"first":[36.85390090942383,148.4246368408203,7.572700500488281,13.199996948242188],"last":[247.70404052734375,148.4246368408203,16.040008544921875,13.199996948242188],"length":20,"rects":[[36.85390090942383,148.4246368408203,226.8901481628418,13.199996948242188]],"start":336,"text":"2.4 Jf发Android硬件访问服务"}],"type":5,"uuid":"800a56c505ce6f814972784082af94a4"}],"originaltext":"第章硬件抽象层","page":31,"textblocks":[{"first":[15.82390022277832,120.82280731201172,44.160003662109375,15.120002746582031],"last":[135.10389709472656,157.06283569335938,29.759994506835938,24.959991455078125],"length":8,"rects":[[15.82390022277832,120.82280731201172,88.32000541687012,15.120002746582031],[16.063899993896484,157.06283569335938,148.79999160766602,24.959991455078125]],"start":0,"text":"第章\n硬件抽象层"}],"type":5,"uuid":"6adb40b398506d305384b05b1e068586"},{"date":"2023-07-18 13:57:15","docid":0,"fillcolor":"fffeeb73","id":891,"markups":[{"date":"2023-07-18 13:57:51","docid":0,"fillcolor":"fffeeb73","group":[{"date":"2023-07-18 13:57:51","docid":0,"fillcolor":"fffeeb73","id":893,"originaltext":"","page":68,"textblocks":[{"first":[46.54389953613281,54.104618072509766,10.457199096679688,8.880001068115234],"last":[123.82389831542969,54.104618072509766,8.8800048828125,8.880001068115234],"length":8,"rects":[[46.54389953613281,54.104618072509766,86.16000366210938,8.880001068115234]],"start":61,"text":"不能释放的问题f"}],"type":5,"uuid":"fe099ac105842922bd3c7ce747d8a989"}],"id":892,"originaltext":"在使用强引用计数和弱引用计数的解决方案中，一般将有关联的对象划分为“父－子”和“子－父“关系在“父－子”关系中，“父”对象通过强引用计数来引用“子”对象；而在“子－父”关系中，“子”对象通过弱引用计数来引用“父”对象。这样就可以解决由于相互引用而造成对象\n不能释放的问题f","page":67,"textblocks":[{"first":[71.743896484375,679.0628662109375,10.609298706054688,9.3599853515625],"last":[475.0149841308594,711.4628295898438,10.732391357421875,9.1199951171875],"length":129,"rects":[[71.743896484375,679.0628662109375,413.7629699707031,9.3599853515625],[23.743900299072266,695.3826904296875,456.4798240661621,8.8800048828125],[18.224000930786133,711.4628295898438,467.5233745574951,9.1199951171875]],"start":1255,"text":"在使用强引用计数和弱引用计数的解决方案中，一般将有关联的对象划分为“父－子”和\n“子－父“关系在“父－子”关系中，“父”对象通过强引用计数来引用“子”对象；而在“子－父”\n关系中，“子”对象通过弱引用计数来引用“父”对象。这样就可以解决由于相互引用而造成对象"}],"type":5,"uuid":"d2ac91d854c9ef636185a30df570c5f1"}],"originaltext":"第三章智能指针","page":67,"textblocks":[{"first":[19.183900833129883,122.25272369384766,15.840002059936523,15.599998474121094],"last":[127.66390228271484,158.50282287597656,36.00000762939453,25.199996948242188],"length":9,"rects":[[19.183900833129883,122.25272369384766,87.83999443054199,15.599998474121094],[19.66390037536621,158.50282287597656,144.00000953674316,25.199996948242188]],"start":0,"text":"第：二章\n智能指针"}],"type":5,"uuid":"3471d1e907ca20c6098cf7b313734dcb"},{"date":"2023-07-18 13:58:13","docid":0,"fillcolor":"fffeeb73","id":894,"markups":[{"date":"2023-07-18 13:58:25","docid":0,"fillcolor":"fffeeb73","id":895,"markups":[{"date":"2023-07-13 10:40:53","docid":0,"id":859,"imgfile":"a396865146c10523b8c1b593c9934d38.png","linecolor":"ffa0ec6f","linewidth":2,"page":93,"rect":[28.65115633031415,40.21214923552863,468.97419045935266,364.4226024469782],"type":2,"uuid":"deda0eca76d9913cc1d95999062c267d"}],"originaltext":"Android提供的Logger日志系统是基于内核中的Logger日志驱动程序实现的，它将日志记录保存在内核空间中。为了有效地利用内存空间，Logger日志驱动程序在内部使用一个环形缓冲区来保存日志。因此，当Logger日志驱动程序中的环形缓冲区满了之后，新的H志就会覆盖旧的日志由于新的日志会覆盖旧的日志，因此，Logger日志驱动程序根据H志的类型以及日志的输出量来对日志记录进行分类，避免重要的日志被不重要的日志覆盖，或者数据队大的日志覆盖数据最小的日志。H志的类型一共有四种，它们分别是main、system、radio和events。在Logger日志驱动程序中，这四种类型的日志分别通过/dev/log/main、/dev/log/system、/dev/log/radio和/dev/log/events四个设备文件来访问。类刮为main的日志是应用程序级别的，而类型为system的日志是系统级别的。由于系统级日志要比应用程序级日志重要，因此，把它们分开来记录，可以避免系统级日志被应用程序级H志覆盖类型为radio的日志是与无线设备相关的，它们的量很大，因此，把它们单独记录在一起，可以避免它们覆盖其他类型的H志。类型为events的日志是专门用来诊断系统问题的，应用程序开发者不应该使用此种类型的日志。","page":92,"textblocks":[{"first":[65.50399780273438,234.1046142578125,4.902900695800781,9.1199951171875],"last":[119.50399780273438,452.984619140625,3.1200027465820312,9.1199951171875],"length":573,"rects":[[65.50399780273438,234.1046142578125,447.1300354003906,9.1199951171875],[44.86399841308594,252.33462524414062,466.33058166503906,9.1199951171875],[44.6338996887207,270.3346252441406,411.35090255737305,9.1199951171875],[66.46389770507812,288.5846252441406,446.1608581542969,9.1199951171875],[44.3838996887207,306.8246154785156,466.7985954284668,9.1199951171875],[44.3838996887207,325.30462646484375,468.0103874206543,9.1199951171875],[45.11399841308594,343.30462646484375,467.52040100097656,9.3599853515625],[44.153900146484375,362.0246276855469,25.43000030517578,9.1199951171875],[65.26390075683594,380.02459716796875,447.61012268066406,8.8800048828125],[45.58399963378906,398.0246276855469,467.51988220214844,9.1199951171875],[44.6338996887207,416.0246276855469,467.98981857299805,9.3599853515625],[44.6338996887207,434.254638671875,467.7502555847168,9.3599853515625],[44.3838996887207,452.984619140625,78.2401008605957,9.1199951171875]],"start":15,"text":"Android提供的Logger日志系统是基于内核中的Logger日志驱动程序实现的，它将日志记录保存在\n内核空间中。为了有效地利用内存空间，Logger日志驱动程序在内部使用一个环形缓冲区来保存日\n志。因此，当Logger日志驱动程序中的环形缓冲区满了之后，新的H志就会覆盖旧的日志\n由于新的日志会覆盖旧的日志，因此，Logger日志驱动程序根据H志的类型以及日志的输出量来\n对日志记录进行分类，避免重要的日志被不重要的日志覆盖，或者数据队大的日志覆盖数据最小的日\n志。H志的类型一共有四种，它们分别是main、system、radio和events。在Logger日志驱动程序中，这\n四种类型的日志分别通过/dev/log/main、/dev/log/system、/dev/log/radio和/dev/log/events四个设备文件来\n访问。\n类刮为main的日志是应用程序级别的，而类型为system的日志是系统级别的。由于系统级日志要\n比应用程序级日志重要，因此，把它们分开来记录，可以避免系统级日志被应用程序级H志覆盖类\n型为radio的日志是与无线设备相关的，它们的量很大，因此，把它们单独记录在一起，可以避免它们\n覆盖其他类型的H志。类型为events的日志是专门用来诊断系统问题的，应用程序开发者不应该使用\n此种类型的日志。"}],"type":5,"uuid":"916dd31623dd6e7aee57af60ecdb72a4"}],"originaltext":"第t章Logger日志系统","page":92,"position":{"x":21,"y":1844},"textblocks":[{"first":[44.86399841308594,129.93460083007812,16.080001831054688,15.839996337890625],"last":[237.34388732910156,166.17465209960938,28.560012817382812,24.959991455078125],"length":14,"rects":[[44.86399841308594,129.93460083007812,88.55990600585938,15.839996337890625],[45.83399963378906,166.17465209960938,220.0699005126953,24.959991455078125]],"start":0,"text":"第t章\nLogger日志系统"}],"type":5,"uuid":"e7b4a39cc51f62c5c9878fa47091d744"},{"date":"2023-07-18 12:21:08","docid":0,"fillcolor":"fffeeb73","id":872,"markups":[{"date":"2023-07-18 13:59:05","docid":0,"fillcolor":"fffeeb73","id":899,"markups":[{"date":"2023-07-13 13:59:59","docid":0,"id":860,"imgfile":"e761f1cf8b05d04620de297c50a1f63d.png","linecolor":"ffa0ec6f","linewidth":2,"page":163,"rect":[58.810268256960626,27.143200733981825,455.90524195780586,277.9664815905917],"type":2,"uuid":"d2a582cbea72d7e0d02f54f83b4645f1","width":558}],"originaltext":"以L描述的Bin<伈进程间通估机制,1,涉及八:lif-'111、St>rvil'P,沁·vin、Manag<-'1利Bindf-'1驱动程序四个用色，它1(j的关系如图汇II听小","page":162,"textblocks":[{"first":[60.70389938354492,569.6246337890625,8.15999984741211,8.8800048828125],"last":[172.55389404296875,586.4146118164062,8.639999389648438,8.4000244140625],"length":91,"rects":[[60.70389938354492,569.6246337890625,446.64995193481445,8.8800048828125],[39.11399841308594,586.4146118164062,142.07989501953125,8.4000244140625]],"start":1253,"text":"以L描述的Bin<伈进程间通估机制,1,涉及八:lif-'111、St>rvil'P,沁·vin、Manag<-'1利Bindf-'1驱动程序四个\n用色，它1(j的关系如图汇II听小"}],"type":5,"uuid":"875c398ddd83ed091325355e8099425e"}],"originaltext":"第五章Binder进程间通信系统","page":162,"position":{"x":384,"y":2676},"textblocks":[{"first":[39.58399963378906,161.85464477539062,15.319999694824219,24.959991455078125],"last":[314.69287109375,161.85464477539062,30.1715087890625,24.959991455078125],"length":13,"rects":[[39.58399963378906,161.85464477539062,305.28038024902344,24.959991455078125]],"start":3,"text":"Binder进程间通信系统"}],"type":5,"uuid":"39ae0ee2ace9d752dce5144f05a4f4b9"},{"date":"2023-08-07 09:57:50","docid":0,"fillcolor":"fffeeb73","id":900,"markups":[{"date":"2023-08-07 10:06:32","docid":0,"fillcolor":"fffeeb73","id":911,"markups":[{"date":"2023-08-07 09:59:28","docid":0,"fillcolor":"fffeeb73","id":901,"originaltext":"Activity是Android应用程序的四大组件之一，它负责管理Android应用程序的用户界面","page":410,"textblocks":[{"first":[53.02389907836914,228.3345947265625,4.170101165771484,9.1199951171875],"last":[436.3839111328125,228.3345947265625,10.720001220703125,9.1199951171875],"length":49,"rects":[[53.02389907836914,228.3345947265625,394.0800132751465,9.1199951171875]],"start":20,"text":"Activity是Android应用程序的四大组件之一，它负责管理Android应用程序的用户界面"}],"type":5,"uuid":"44244da86e72f59f140113cb873a8df7"},{"date":"2023-08-07 10:03:07","docid":0,"fillcolor":"fffeeb73","id":903,"markups":[{"date":"2023-08-07 10:02:07","docid":0,"fillcolor":"fffeeb73","id":902,"originaltext":"它由兰个Activity组件MainActivity、SubActivitylnProcess和SubActivitylnNewProcess组成，其中，MainActivity是根Activity,SuhActivitylnProcess 和SubActivitylnNewProcess是子Activity。SuhActivitylnProcess与MainActivit戎扦子在同一个进程中，而SubActivitylnNewProcess运行在一个独立的进程中","page":410,"textblocks":[{"first":[341.51434326171875,577.5446166992188,10.560089111328125,9.1199951171875],"last":[245.23098754882812,623.1445922851562,10.60369873046875,8.8800048828125],"length":237,"rects":[[341.51434326171875,577.5446166992188,153.58956909179688,9.1199951171875],[31.423999786376953,592.6546020507812,471.95698165893555,9.1199951171875],[31.903900146484375,607.78466796875,468.72998046875,9.3599853515625],[31.66390037536621,623.1445922851562,224.17078590393066,8.8800048828125]],"start":957,"text":"它由兰个Activity组件MainActivity、\nSubActivitylnProcess和SubActivitylnNewProcess组成，其中，MainActivity是根Activity,SuhActivitylnProcess \n和SubActivitylnNewProcess是子Activity。SuhActivitylnProcess与MainActivit戎扦子在同一个进程中，而\nSubActivitylnNewProcess运行在一个独立的进程中"}],"type":5,"uuid":"8d336cecedf09ea088f5e08ab25e718e"},{"date":"2023-08-07 10:05:56","docid":0,"fillcolor":"fffeeb73","id":909,"originaltext":"运行在不同进程中的Activity组件通过Bind面柱程间通信机制来协作完成应用程序的功能","page":410,"textblocks":[{"first":[246.2239990234375,260.984619140625,10.6400146484375,9.1199951171875],"last":[167.7680206298828,276.81463623046875,10.488006591796875,9.3599853515625],"length":46,"rects":[[246.2239990234375,260.984619140625,254.63992309570312,9.1199951171875],[31.423999786376953,276.81463623046875,146.83202743530273,9.3599853515625]],"start":149,"text":"运行在不同进程中的Activity组件通过Bind面柱程间通信\n机制来协作完成应用程序的功能"}],"type":5,"uuid":"bdcbc3d86f8a31ed98c20427d18d27d8"}],"originaltext":"7 .1 Activity组件应用实例","page":410,"textblocks":[{"first":[31.743900299072266,540.5846557617188,7.5,13.91998291015625],"last":[206.9839324951172,540.5846557617188,15.960006713867188,13.91998291015625],"length":19,"rects":[[31.743900299072266,540.5846557617188,191.2000389099121,13.91998291015625]],"start":901,"text":"7 .1 Activity组件应用实例"}],"type":5,"uuid":"36d6365da764c23abf4ef3ccf1164cbb"},{"date":"2023-08-07 10:03:37","docid":0,"fillcolor":"fffeeb73","id":905,"originaltext":"7.2 根Activity组件的启动过程","page":416,"textblocks":[{"first":[37.26390075683594,312.8146057128906,7.6053009033203125,13.20001220703125],"last":[245.959716796875,312.8146057128906,16.114288330078125,13.20001220703125],"length":20,"rects":[[37.26390075683594,312.8146057128906,224.8101043701172,13.20001220703125]],"start":193,"text":"7.2 根Activity组件的启动过程"}],"type":5,"uuid":"5d995824b8d10056819517e26873a3fd"},{"date":"2023-08-07 10:04:42","docid":0,"fillcolor":"fffeeb73","id":906,"originaltext":"7.3 子Activity组件在进程内的启动过程","page":450,"textblocks":[{"first":[42.784000396728516,395.3746337890625,7.549999237060547,13.67999267578125],"last":[316.22698974609375,395.3746337890625,16.16729736328125,13.67999267578125],"length":24,"rects":[[42.784000396728516,395.3746337890625,289.6102867126465,13.67999267578125]],"start":889,"text":"7.3 子Activity组件在进程内的启动过程"}],"type":5,"uuid":"e5fd87582feded6dead416b04b71b249"},{"date":"2023-08-07 10:05:01","docid":0,"fillcolor":"fffeeb73","id":908,"originaltext":"7.4 子Activity组件在新进程中的启动过程","page":458,"textblocks":[{"first":[48.54389953613281,449.3746032714844,7.514751434326172,13.20001220703125],"last":[337.6250305175781,449.3746032714844,16.120086669921875,13.20001220703125],"length":25,"rects":[[48.54389953613281,449.3746032714844,305.2012176513672,13.20001220703125]],"start":836,"text":"7.4 子Activity组件在新进程中的启动过程"}],"type":5,"uuid":"d3d6c494c9f9afa998c623787029e5de"}],"originaltext":"第七章Activity组件的启动过程","page":410,"textblocks":[{"first":[32.26390075683594,121.98621368408203,16.55999755859375,16.31999969482422],"last":[325.50299072265625,160.90463256835938,30.1715087890625,24.720001220703125],"length":19,"rects":[[32.26390075683594,121.98621368408203,16.55999755859375,16.31999969482422],[104.14399719238281,123.70464324951172,17.040000915527344,15.120002746582031],[31.66390037536621,160.90463256835938,324.01059913635254,24.720001220703125]],"start":0,"text":"第\n章\nActivity组件的启动过程"}],"type":5,"uuid":"322fbcf3dafcd91e191159358df82f2a"},{"date":"2023-08-07 10:09:30","docid":0,"fillcolor":"fffeeb73","id":913,"markups":[{"date":"2023-08-07 10:10:11","docid":0,"fillcolor":"fffeeb73","id":914,"originaltext":"它主要用来处理与用户界面无关的业务逻辑。由于Service组件不直接与用户交互，因此，它涉及的业务逻辑一般都是计算型的，适合在后台运行。","page":461,"textblocks":[{"first":[397.3212890625,224.7328338623047,10.78289794921875,9.360000610351562],"last":[125.9940185546875,258.58282470703125,10.080001831054688,9.3599853515625],"length":70,"rects":[[397.3212890625,224.7328338623047,86.26318359375,9.360000610351562],[15.11400032043457,241.29281616210938,468.72157096862793,9.600006103515625],[15.11400032043457,258.58282470703125,120.96002006530762,9.3599853515625]],"start":65,"text":"它主要用来处理与\n用户界面无关的业务逻辑。由于Service组件不直接与用户交互，因此，它涉及的业务逻辑一般都是计\n算型的，适合在后台运行。"}],"type":5,"uuid":"f17362fcc602ceb7562ccb72c0fbeb3f"},{"date":"2023-08-07 10:11:42","docid":0,"fillcolor":"fffeeb73","id":915,"markups":[{"date":"2023-08-07 10:15:19","docid":0,"fillcolor":"fffeeb73","id":916,"originaltext":"CounterService是应用程序Counter的一个Service组件，因此，它必须要从Service类继承下来。CounterService组件同时实现了计数器接口ICounterService,用来提供计数器服务","page":464,"textblocks":[{"first":[57.11399841308594,50.02464294433594,4.868598937988281,9.360000610351562],"last":[404.3722839355469,66.57463836669922,10.887298583984375,9.120002746582031],"length":112,"rects":[[57.11399841308594,50.02464294433594,441.58995056152344,9.360000610351562],[35.743900299072266,66.57463836669922,379.515682220459,9.120002746582031]],"start":26,"text":"CounterService是应用程序Counter的一个Service组件，因此，它必须要从Service类继承下来。\nCounterService组件同时实现了计数器接口ICounterService,用来提供计数器服务"}],"type":5,"uuid":"f72cc59247c0f0fdfcc1906e96a17ec2"}],"originaltext":"8.1 Service组件应用实例","page":461,"textblocks":[{"first":[15.313899993896484,512.7427368164062,7.450000762939453,13.44000244140625],"last":[184.90391540527344,512.7427368164062,15.960006713867188,13.44000244140625],"length":17,"rects":[[15.313899993896484,512.7427368164062,185.55002212524414,13.44000244140625]],"start":728,"text":"8.1 Service组件应用实例"}],"type":5,"uuid":"5c6c74d361cd8cbefdd84c533482a998"},{"date":"2023-08-07 10:15:35","docid":0,"fillcolor":"fffeeb73","id":917,"originaltext":"8.2 Service组件在新进程中的启动过程","page":469,"textblocks":[{"first":[11.463899612426758,84.58269500732422,7.75,13.680000305175781],"last":[272.8251037597656,84.58269500732422,16.120086669921875,13.680000305175781],"length":23,"rects":[[11.463899612426758,84.58269500732422,277.48129081726074,13.680000305175781]],"start":44,"text":"8.2 Service组件在新进程中的启动过程"}],"type":5,"uuid":"cce35b9e11688b4d9741f294d3a1518d"},{"date":"2023-08-07 14:54:27","docid":0,"fillcolor":"fffeeb73","id":918,"originaltext":"8.3 Service组件在进程内的绑定过程","page":481,"textblocks":[{"first":[21.313899993896484,646.4227294921875,7.450000762939453,13.67999267578125],"last":[272.7550048828125,646.4227294921875,16.1890869140625,13.67999267578125],"length":22,"rects":[[21.313899993896484,646.4227294921875,267.6301918029785,13.67999267578125]],"start":1389,"text":"8.3 Service组件在进程内的绑定过程"}],"type":5,"uuid":"314de85f8e30cd449b01691890cca450"}],"originaltext":"第八章Service组件的启动过程","page":461,"textblocks":[{"first":[15.343900680541992,118.41322326660156,16.799997329711914,16.080001831054688],"last":[303.2756042480469,157.30270385742188,30.068603515625,24.959991455078125],"length":18,"rects":[[15.343900680541992,118.41322326660156,16.799997329711914,16.080001831054688],[87.22389221191406,118.35565185546875,17.040000915527344,16.55999755859375],[15.82390022277832,157.30270385742188,317.52030754089355,24.959991455078125]],"start":0,"text":"第\n章\nService组件的启动过程"}],"type":5,"uuid":"c880c42ff7eb9a238570eb0b9f22af06"},{"date":"2023-08-07 14:55:37","docid":0,"fillcolor":"fffeeb73","id":919,"markups":[{"date":"2023-08-07 14:56:41","docid":0,"fillcolor":"fffeeb73","id":920,"originaltext":"广播(Broadcast)是一种在组件之间进行消息传递的方式。这些组件可以运行在同一个进程中，也可以运行在不同的进程中。当两个不在同一个进程中的组件通过广播机制来传递消息时，广播机制就有点类似Binder进程间通信机制。事实上，．广播机制就是在Binder进程间通信机制的基础上实现的。","page":504,"textblocks":[{"first":[141.0240020751953,234.3346405029297,10.720001220703125,9.360000610351562],"last":[126.46389770507812,283.78460693359375,3.3600006103515625,9.1199951171875],"length":146,"rects":[[141.0240020751953,234.3346405029297,357.21022033691406,9.360000610351562],[29.743900299072266,250.90463256835938,468.96169662475586,9.1199951171875],[29.743900299072266,266.734619140625,468.73000717163086,9.600006103515625],[29.743900299072266,283.78460693359375,100.07999801635742,9.1199951171875]],"start":30,"text":"广播(Broadcast)是一种在组件之间进行消息传递的方式。这些组件可以运\n行在同一个进程中，也可以运行在不同的进程中。当两个不在同一个进程中的组件通过广播机制来传\n递消息时，广播机制就有点类似Binder进程间通信机制。事实上，．广播机制就是在Binder进程间通信\n机制的基础上实现的。"}],"type":5,"uuid":"d1e543a5a274a4775793a290970e3b4f"},{"date":"2023-08-07 14:57:20","docid":0,"fillcolor":"fffeeb73","id":921,"originaltext":"Binder进程间通信机制中，Client组件在和Service组件通信之前，必须要先获得它的一个代理对象，即Clientffl件事先要知道Service组件的存在","page":504,"textblocks":[{"first":[390.7138977050781,299.8646240234375,5.1199951171875,9.3599853515625],"last":[102.52200317382812,332.74462890625,10.512001037597656,9.1199951171875],"length":84,"rects":[[390.7138977050781,299.8646240234375,107.030029296875,9.3599853515625],[30.703899383544922,316.42462158203125,467.7700996398926,9.1199951171875],[29.743900299072266,332.74462890625,83.29010391235352,9.1199951171875]],"start":211,"text":"Binder进程间通信机制\n中，Client组件在和Service组件通信之前，必须要先获得它的一个代理对象，即Clientffl件事先要知道\nService组件的存在"}],"type":5,"uuid":"b6b88420e02789738939fa6ac32741ec"},{"date":"2023-08-07 14:59:28","docid":0,"fillcolor":"fffeeb73","id":926,"originaltext":"广播机制存在一个注册中心．它是由ActivityManagerService来担当的。广播接收者订阅消息的表现形式就是将自己注册到ActivityManagerService中，并且指定要接收的广播的类型","page":504,"textblocks":[{"first":[51.58399963378906,463.78460693359375,10.680000305175781,9.1199951171875],"last":[401.4080810546875,480.1046142578125,10.656005859375,9.1199951171875],"length":103,"rects":[[51.58399963378906,463.78460693359375,447.1306915283203,9.1199951171875],[29.98390007019043,480.1046142578125,382.08018684387207,9.1199951171875]],"start":615,"text":"广播机制存在一个注册中心．它是由ActivityManagerService来担当的。广播接收者订阅消息的表\n现形式就是将自己注册到ActivityManagerService中，并且指定要接收的广播的类型"}],"type":5,"uuid":"f92e73667ca34c3e737f87a9eee5d5c1"},{"date":"2023-08-07 14:57:25","docid":0,"fillcolor":"fffeeb73","id":922,"markups":[{"date":"2023-08-07 14:59:00","docid":0,"fillcolor":"fffeeb73","id":925,"markups":[{"CL":[326.221060673226,365.4279061778664,353.4703360249721,372.4650322940839,373.4703360249721,372.4650322940839],"date":"2023-08-07 14:58:29","docid":0,"id":924,"linecolor":"ffd01a11","linewidth":7,"originaltext":"相当于ros中的topic通信","page":504,"rect":[373.4703360249721,363.91995058153407,520.7420288692076,382.0101140066338],"type":9,"uuid":"dc85d73092ef5c15134b0ce12ed24131"}],"originaltext":"广播机制是一种基于消息发布和订阅的事件驱动模型","page":504,"textblocks":[{"first":[51.58399963378906,381.93463134765625,10.899600982666016,9.1199951171875],"last":[291.3751525878906,381.93463134765625,10.89959716796875,9.1199951171875],"length":23,"rects":[[51.58399963378906,381.93463134765625,250.6907501220703,9.1199951171875]],"start":395,"text":"广播机制是一种基于消息发布和订阅的事件驱动模型"}],"type":5,"uuid":"fb2997fa8b3e128d21450fa613dfc669"}],"originaltext":"在广播机制中，广播发送者事先是不需要知道广播接收者的存在的，这样就可以降低广播发送者和广播接收者之间的耦合度，进而提高系统的可扩展性和可维护性。","page":504,"textblocks":[{"first":[156.81381225585938,332.74462890625,10.676605224609375,9.1199951171875],"last":[456.7138977050781,349.05462646484375,3.600006103515625,9.1199951171875],"length":73,"rects":[[156.81381225585938,332.74462890625,341.6513671875,9.1199951171875],[29.98390007019043,349.05462646484375,430.3300037384033,9.1199951171875]],"start":299,"text":"在广播机制中，广播发送者事先是不需要知道广播接收者的存在的，这样\n就可以降低广播发送者和广播接收者之间的耦合度，进而提高系统的可扩展性和可维护性。"}],"type":5,"uuid":"48aaa16b5125a3da6f53675aef0d1a18"}],"originaltext":"第九章Android系统广播机制","page":504,"textblocks":[{"first":[30.23390007019043,127.98621368408203,16.799997329711914,16.31999969482422],"last":[297.07440185546875,166.66464233398438,29.80010986328125,24.959991455078125],"length":17,"rects":[[30.23390007019043,127.98621368408203,16.799997329711914,16.31999969482422],[102.343994140625,127.67863464355469,17.040000915527344,16.800003051757812],[29.743900299072266,166.66464233398438,297.13061141967773,24.959991455078125]],"start":0,"text":"第\n章\nAndroid系统广播机制"}],"type":5,"uuid":"9d29de6701332e2ec9f8605e46c7844d"},{"date":"2023-08-07 15:02:41","docid":0,"fillcolor":"fffeeb73","id":929,"markups":[{"date":"2023-08-07 15:03:37","docid":0,"fillcolor":"fffeeb73","id":930,"originaltext":"ContentProvider组件除了可以用来作为数据访问接口之外，还可以在不同的应用程序之间进行数据共享。","page":542,"textblocks":[{"first":[371.98388671875,247.30459594726562,4.59429931640625,9.600006103515625],"last":[374.0123596191406,263.6246337890625,10.454193115234375,9.3599853515625],"length":55,"rects":[[371.98388671875,247.30459594726562,124.55996704101562,9.600006103515625],[29.02389907836914,263.6246337890625,355.44265365600586,9.3599853515625]],"start":139,"text":"ContentProvider组件除了可\n以用来作为数据访问接口之外，还可以在不同的应用程序之间进行数据共享。"}],"type":5,"uuid":"778f79db3ad66981e9b6e44bb4fd2dd3"},{"date":"2023-08-07 15:05:33","docid":0,"fillcolor":"fffeeb73","id":931,"originaltext":"在Android系统中，每一个应用程序被安装时，都会分配到一个不同的Linux用户ID1o这样，Android系统就可以基于Linux用户ID来保护每一个应用程序的数据不会被其他应用程序破坏，即每一个应用程序只可以访问自己创建的数据","page":542,"textblocks":[{"first":[102.70389556884766,279.93463134765625,10.55999755859375,9.1199951171875],"last":[230.10794067382812,312.1046142578125,10.595993041992188,9.600006103515625],"length":118,"rects":[[102.70389556884766,279.93463134765625,388.0899887084961,9.1199951171875],[27.583999633789062,296.0246276855469,462.48020935058594,9.3599853515625],[28.784000396728516,312.1046142578125,211.9199333190918,9.600006103515625]],"start":200,"text":"在Android系统中，每一个应用程序被安装时，都会分配到一个不同的Linux用户ID1o\n这样，Android系统就可以基于Linux用户ID来保护每一个应用程序的数据不会被其他应用程序破坏，\n即每一个应用程序只可以访问自己创建的数据"}],"type":5,"uuid":"f93c4992f8712b197bb9dd90a2f319fb"},{"date":"2023-08-07 15:05:52","docid":0,"fillcolor":"fffeeb73","id":932,"originaltext":"由于通讯录本身是一个独立的应用程序，因此，其他应用程序是不能直接访问它的联系人信息的，这时候就需要使用ContentProvider组件来共享通讯录中的联系人信息了。","page":542,"textblocks":[{"first":[445.18389892578125,328.4146423339844,10.272003173828125,9.3599853515625],"last":[290.8739013671875,360.8246154785156,3.839996337890625,9.1199951171875],"length":85,"rects":[[445.18389892578125,328.4146423339844,51.360015869140625,9.3599853515625],[28.063899993896484,344.2646179199219,468.48129653930664,9.600006103515625],[27.82390022277832,360.8246154785156,266.8899974822998,9.1199951171875]],"start":382,"text":"由于通讯录\n本身是一个独立的应用程序，因此，其他应用程序是不能直接访问它的联系人信息的，这时候就需要\n使用ContentProvider组件来共享通讯录中的联系人信息了。"}],"type":5,"uuid":"3cd9ebfc009808f43f15a0398dbefc05"},{"date":"2023-08-07 15:07:09","docid":0,"id":933,"imgfile":"42fd12aa88890e8984d153bb1fd63907.png","linecolor":"ffa0ec6f","linewidth":2,"page":542,"rect":[105.55689174326265,493.1014800006698,424.23817443482704,698.1834411018658],"type":2,"uuid":"5e2a421009ecf02f2326e71cc8dcc968"},{"date":"2023-08-07 15:09:22","docid":0,"fillcolor":"fffeeb73","id":934,"markups":[{"date":"2023-08-07 15:09:33","docid":0,"fillcolor":"fffeeb73","id":935,"originaltext":"因此．Content Provider组件就可以通过Binde嗖t程间通信机制将它里面的数据传递给业务层中的Android应用程序。然而，事情没有那么简单，因为ContentProvider组件一次传递给业务层中的Android应用程序的数据的屈可能是非常大的。在这种情况下，如果直接使用Binde戌t程间通信机制来传递数据，那么数据传输效率就会成为问题。从前面第6章的内容可以知道，不同的应用程序进程可以通过匿名共享内存来传输大数据，因为无论多大的数据，对匿名共享内存来说，需要在进程间传递的仅仅是一个文件描述符而已。这样．结合Binde氓t程间通信机制以及匿名共享内存机制，ContentProvider组件就可以高效地将它里面的数据传递给业务层中的Android应用程序访问了","page":543,"textblocks":[{"first":[453.833984375,179.61285400390625,10.32000732421875,9.1199951171875],"last":[311.4014587402344,292.662841796875,10.42291259765625,9.1199951171875],"length":348,"rects":[[453.833984375,179.61285400390625,30.96002197265625,9.1199951171875],[22.683900833129883,195.70269775390625,468.3400249481201,9.1199951171875],[22.784000396728516,211.78282165527344,467.9999656677246,9.360000610351562],[22.784000396728516,228.10284423828125,468.7201499938965,9.1199951171875],[22.784000396728516,244.18283081054688,467.5304527282715,9.1199951171875],[22.543899536132812,260.4928283691406,468.72325134277344,9.1199951171875],[22.784000396728516,276.57281494140625,467.76000595092773,8.8800048828125],[22.784000396728516,292.662841796875,299.0403709411621,9.1199951171875]],"start":463,"text":"因此．\nContent Provider组件就可以通过Binde嗖t程间通信机制将它里面的数据传递给业务层中的Android应用\n程序。然而，事情没有那么简单，因为ContentProvider组件一次传递给业务层中的Android应用程序的\n数据的屈可能是非常大的。在这种情况下，如果直接使用Binde戌t程间通信机制来传递数据，那么数\n据传输效率就会成为问题。从前面第6章的内容可以知道，不同的应用程序进程可以通过匿名共享内\n存来传输大数据，因为无论多大的数据，对匿名共享内存来说，需要在进程间传递的仅仅是一个文件\n描述符而已。这样．结合Binde氓t程间通信机制以及匿名共享内存机制，ContentProvider组件就可以\n高效地将它里面的数据传递给业务层中的Android应用程序访问了"}],"type":5,"uuid":"9087fc9b2340cb1287d2b75b6772a55a"}],"originaltext":"ContentProvider组件是运行在一个独立的应用程序进程中的，即它本身也是一个Android应用程序","page":543,"textblocks":[{"first":[162.2239990234375,147.2228240966797,4.59429931640625,9.360000610351562],"last":[132.34390258789062,163.5428466796875,10.600006103515625,9.1199951171875],"length":55,"rects":[[162.2239990234375,147.2228240966797,328.8002624511719,9.360000610351562],[22.784000396728516,163.5428466796875,120.15990829467773,9.1199951171875]],"start":327,"text":"ContentProvider组件是运行在一个独立的应用程序进程中的，即它本身\n也是一个Android应用程序"}],"type":5,"uuid":"f7de7b23e15571477ccca6c0a3205be6"}],"originaltext":"第十章Content Provider组件的实现原理","page":542,"textblocks":[{"first":[29.02389907836914,126.57459259033203,16.560001373291016,11.760002136230469],"last":[456.6356201171875,164.26461791992188,30.068603515625,24.720001220703125],"length":27,"rects":[[29.02389907836914,126.57459259033203,122.16999435424805,11.760002136230469],[28.57390022277832,164.26461791992188,458.1303234100342,24.720001220703125]],"start":0,"text":"第1章\nContent Provider组件的实现原理"}],"type":5,"uuid":"44ba8d25eccef79f842adc29f17e4eba"},{"date":"2023-08-07 15:12:15","docid":0,"fillcolor":"fffeeb73","id":936,"markups":[{"date":"2023-08-07 15:12:49","docid":0,"fillcolor":"fffeeb73","id":937,"originaltext":"在Android系统中，所有的应用程序进程，以及用来运行系统关键服务的System进程都是由Zygote进程负责创建的，因此，我们将它称为进程孵化器。Zygote进程是通过复制自身的方式来创建System进程和应用程序进程的","page":629,"textblocks":[{"first":[36.2239990234375,227.61285400390625,9.599998474121094,9.1199951171875],"last":[112.65550994873047,260.0228271484375,10.892402648925781,9.1199951171875],"length":114,"rects":[[36.2239990234375,227.61285400390625,447.1199035644531,9.1199951171875],[14.623900413513184,243.6928253173828,468.4806833267212,9.360000610351562],[14.623900413513184,260.0228271484375,108.92401218414307,9.1199951171875]],"start":25,"text":"在Android系统中，所有的应用程序进程，以及用来运行系统关键服务的System进程都是由Zygote\n进程负责创建的，因此，我们将它称为进程孵化器。Zygote进程是通过复制自身的方式来创建System\n进程和应用程序进程的"}],"type":5,"uuid":"0960c3abead9041ebfaf6bc36f9217f3"},{"date":"2023-08-07 15:17:27","docid":0,"fillcolor":"fffeeb73","id":938,"originaltext":"11.1 Zygote进程的启动脚本","page":629,"textblocks":[{"first":[15.053999900817871,393.9328308105469,7.59999942779541,13.67999267578125],"last":[209.12705993652344,393.9328308105469,16.217193603515625,13.67999267578125],"length":18,"rects":[[15.053999900817871,393.9328308105469,210.2902536392212,13.67999267578125]],"start":495,"text":"11.1 Zygote进程的启动脚本"}],"type":5,"uuid":"beb8f6db6757a7632731ec587679ac69"},{"date":"2023-08-07 15:18:04","docid":0,"fillcolor":"fffeeb73","id":939,"originaltext":"11.2 Zygote进程的H动过程","page":632,"textblocks":[{"first":[41.444000244140625,606.8146362304688,7.700000762939453,13.91998291015625],"last":[235.9840087890625,606.8146362304688,15.520004272460938,13.91998291015625],"length":18,"rects":[[41.444000244140625,606.8146362304688,210.0600128173828,13.91998291015625]],"start":1471,"text":"11.2 Zygote进程的H动过程"}],"type":5,"uuid":"7e8302027081e774b9613f0a1750f73a"},{"date":"2023-08-07 15:30:27","docid":0,"fillcolor":"fffeeb73","id":941,"originaltext":"Activity管理服务ActivityManagerService在启动一个应用程序组件时，如果发现这个组件所需要的应用程序进程还没有启动起来，那么它就会请求Zygote进程将这个应用程序进程启动起来。","page":648,"textblocks":[{"first":[249.11399841308594,230.74462890625,4.0800018310546875,9.1199951171875],"last":[162.3907012939453,263.3846130371094,10.153900146484375,8.8800048828125],"length":104,"rects":[[249.11399841308594,230.74462890625,260.39988708496094,9.1199951171875],[40.313899993896484,247.05462646484375,469.430118560791,9.1199951171875],[40.54389953613281,263.3846130371094,132.00070190429688,8.8800048828125]],"start":42,"text":"Activity管理服务ActivityManagerService在启动一个应用程\n序组件时，如果发现这个组件所需要的应用程序进程还没有启动起来，那么它就会请求Zygote进程将\n这个应用程序进程启动起来。"}],"type":5,"uuid":"32c8d5f9cacc9bb9b2420256b5a8cac3"}],"originaltext":"第十一章Zygote和System进程的启动过程","page":629,"textblocks":[{"first":[15.223999977111816,121.53309631347656,16.560001373291016,16.080001831054688],"last":[437.65142822265625,160.18270874023438,30.1029052734375,24.720001220703125],"length":24,"rects":[[15.223999977111816,121.53309631347656,16.560001373291016,16.080001831054688],[120.46399688720703,121.23565673828125,16.79999542236328,16.55999755859375],[15.343899726867676,160.18270874023438,452.4104337692261,24.720001220703125]],"start":0,"text":"第\n章\nZygote和System进程的启动过程"}],"type":5,"uuid":"72467044bcc9c5f0af89ff2889348dc5"},{"date":"2023-08-07 15:26:57","docid":0,"fillcolor":"fffeeb73","id":940,"originaltext":"第十二章Android应用程序进程的启动过程","page":648,"position":{"x":430,"y":4047},"textblocks":[{"first":[40.91400146484375,124.37616729736328,16.55999755859375,16.31999969482422],"last":[460.9368896484375,162.81459045410156,30.327301025390625,25.199996948242188],"length":22,"rects":[[40.91400146484375,124.37616729736328,16.55999755859375,16.31999969482422],[146.38389587402344,126.34461212158203,17.039993286132812,14.879997253417969],[40.313899993896484,162.81459045410156,450.95029067993164,25.199996948242188]],"start":0,"text":"第\n章\nAndroid应用程序进程的启动过程"}],"type":5,"uuid":"d18c6569eb21e109ce729e95d69544b6"},{"date":"2023-08-07 15:38:39","docid":0,"fillcolor":"fffeeb73","id":942,"markups":[{"date":"2023-08-07 15:41:11","docid":0,"fillcolor":"fffeeb73","id":943,"originaltext":"Android应用程序的每一个线程在启动时，都可以首先在内部创建一个消息队列，然后再进入到一个无限循环中，不断检查它的消息队列是否有新的消息需要处理。如果有新的消息需要处理，那么线程就会将它从消息队列中取出来，并且对它进行处理；否则，线程就会进入睡眠等待状态，直到有新的消息需要处理为止。这样就可以通过消息来驱动Android应用程序的执行了。","page":663,"textblocks":[{"first":[273.8340148925781,225.6927947998047,4.90289306640625,9.360000610351562],"last":[142.7938995361328,292.4227294921875,3.1199951171875,9.1199951171875],"length":176,"rects":[[273.8340148925781,225.6927947998047,206.6304931640625,9.360000610351562],[11.98390007019043,242.74282836914062,468.4904041290283,9.1199951171875],[12.463899612426758,259.0628356933594,468.001859664917,9.3599853515625],[11.98390007019043,275.8628234863281,468.2438220977783,9.1199951171875],[11.98390007019043,292.4227294921875,133.92999458312988,9.1199951171875]],"start":48,"text":"Android应用程序的每一个线程在启动时，都\n可以首先在内部创建一个消息队列，然后再进入到一个无限循环中，不断检查它的消息队列是否有新\n的消息需要处理。如果有新的消息需要处理，那么线程就会将它从消息队列中取出来，并且对它进行\n处理；否则，线程就会进入睡眠等待状态，直到有新的消息需要处理为止。这样就可以通过消息来驱\n动Android应用程序的执行了。"}],"type":5,"uuid":"44cf6d9aba37132db0cf942a80fb1ae8"},{"date":"2023-08-07 15:42:00","docid":0,"fillcolor":"fffeeb73","id":944,"originaltext":"一个线程的生命周期划分为创建消息队列和进入消息循环两个阶段，其中，消息循环阶段又划分为发送消息和处理消息两个子阶段，它们是交替进行的。","page":663,"textblocks":[{"first":[278.031494140625,342.58282470703125,10.64190673828125,9.1199951171875],"last":[44.3838996887207,376.4127197265625,3.3600006103515625,8.8800048828125],"length":69,"rects":[[278.031494140625,342.58282470703125,202.19622802734375,9.1199951171875],[11.98390007019043,359.3827209472656,468.48130989074707,8.8800048828125],[11.98390007019043,376.4127197265625,35.760000228881836,8.8800048828125]],"start":341,"text":"一个线程的生命周期划分为创建消息队列和\n进入消息循环两个阶段，其中，消息循环阶段又划分为发送消息和处理消息两个子阶段，它们是交替\n进行的。"}],"type":5,"uuid":"16046eb89265d84795633ff9ec7b0663"},{"date":"2023-08-07 15:42:34","docid":0,"fillcolor":"fffeeb73","id":945,"originaltext":"Android系统主要通过MessageQueue、Looper和Handler勹个类来实现Android应用程序的消息处理机制，其中，MessageQueue类用来描述消息队列；Looper类用来创建消息队列，以及进入消息循环；Handler类用来发送消息和处理消息","page":663,"textblocks":[{"first":[33.11399841308594,392.4928283691406,4.971500396728516,9.1199951171875],"last":[165.99099731445312,425.8628234863281,10.836105346679688,9.1199951171875],"length":136,"rects":[[33.11399841308594,392.4928283691406,447.5900115966797,9.1199951171875],[11.98390007019043,409.0628356933594,461.7715015411377,9.3599853515625],[11.98390007019043,425.8628234863281,164.84320259094238,9.1199951171875]],"start":411,"text":"Android系统主要通过MessageQueue、Looper和Handler勹个类来实现Android应用程序的消息处理\n机制，其中，MessageQueue类用来描述消息队列；Looper类用来创建消息队列，以及进入消息循环；\nHandler类用来发送消息和处理消息"}],"type":5,"uuid":"de0efcd6d360598b11cec753fcb45d8a"}],"originaltext":"第十三章Android应用程序的消息处理机制","page":663,"textblocks":[{"first":[12.463899612426758,119.85322570800781,16.31999969482422,16.080001831054688],"last":[431.323974609375,158.26284790039062,29.459991455078125,24.959991455078125],"length":22,"rects":[[12.463899612426758,119.85322570800781,16.31999969482422,16.080001831054688],[117.58390045166016,119.4880142211914,16.79999542236328,17.040000915527344],[11.98390007019043,158.26284790039062,448.8000659942627,24.959991455078125]],"start":0,"text":"第\n章\nAndroid应用程序的消息处理机制"}],"type":5,"uuid":"d9bc0e912ac50174e51ebe9b909cbbd0"}],"originaltext":"第3篇AndroicJ应川程序柜架","page":409,"textblocks":[{"first":[35.034000396728516,150.81283569335938,27.84000015258789,26.160003662109375],"last":[417.1439208984375,150.81283569335938,31.8800048828125,26.160003662109375],"length":17,"rects":[[35.034000396728516,150.81283569335938,413.9899253845215,26.160003662109375]],"start":0,"text":"第3篇AndroicJ应川程序柜架"}],"type":5,"uuid":"3a4eca3b7f5ab20cd5ce8f8ce97a1fb2"}],"maxid":945,"notelinks":[],"scalingratio":70,"summaries":[],"title":"14345558_Android系统源代码情景分析++第3版","unimportant":[]}