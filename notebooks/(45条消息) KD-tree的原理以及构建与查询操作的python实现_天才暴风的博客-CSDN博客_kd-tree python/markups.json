{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-04-09 13:32:52","docid":0,"fillcolor":"fffeeb73","id":1,"markups":[{"date":"2022-04-09 13:33:08","docid":0,"fillcolor":"fffeeb73","id":2,"markups":[{"date":"2022-04-09 13:34:06","docid":0,"fillcolor":"fffeeb73","id":3,"originaltext":"递归定义如下：如果左子树上的节点存储的数值都小于根节点中存储的数值，并且右子树上的节点存储的数值都大于根节点中存储的数值，那么这样的二叉树就是一颗二叉查找树","page":0,"textblocks":[{"first":[224.5333251953125,194.01748657226562,9.82666015625,12.5],"last":[300.6899719238281,209.98580932617188,9.82666015625,12.5],"length":79,"rects":[[224.5333251953125,194.01748657226562,510.98663330078125,12.5],[55.0233268737793,209.98580932617188,255.49330520629883,12.5]],"start":259,"text":"递归定义如下：如果左子树上的节点存储的数值都小于根节点中存储的数值，并且右子树上的节点存储的数值都大于根\n节点中存储的数值，那么这样的二叉树就是一颗二叉查找树"}],"type":5,"uuid":"847c533bc2ebc0d3109f6082ceaf4523"}],"originaltext":"不过首先得说一下bst( 二叉查找树)","page":0,"textblocks":[{"first":[55.0233268737793,194.01748657226562,9.826663970947266,12.5],"last":[211.43429565429688,194.01748657226562,3.27227783203125,12.5],"length":19,"rects":[[55.0233268737793,194.01748657226562,159.68324661254883,12.5]],"start":239,"text":"不过首先得说一下bst( 二叉查找树)"}],"type":5,"uuid":"a4b68cdac04329ff62a271433b68767e"}],"originaltext":"KD-tree的原理以及构建与查询操作的python实现","page":0,"textblocks":[{"first":[55.0233268737793,12.094165802001953,11.917285919189453,22.499996185302734],"last":[425.1842346191406,12.094165802001953,17.1966552734375,22.499996185302734],"length":28,"rects":[[55.0233268737793,12.094165802001953,387.3575630187988,22.499996185302734]],"start":61,"text":"KD-tree的原理以及构建与查询操作的python实现"}],"type":5,"uuid":"d942ac66cd2ea98fd7023d2f0d5bfe59"},{"date":"2022-04-09 13:35:07","docid":0,"fillcolor":"fffeeb73","id":5,"markups":[{"date":"2022-04-09 13:35:21","docid":0,"fillcolor":"fffeeb73","id":6,"originaltext":"kd-tree采取的思想就是计算所有数据点在每个维度上的数值的方差然后方差最大的维度就作为当前节点的划分维度，这样做的原理其实就是：方差越大，说明这个维度上的数据波动越大","page":1,"textblocks":[{"first":[450.82012939453125,311.55169677734375,4.913330078125,13.5],"last":[556.1832885742188,338.3466796875,9.82666015625,13.5],"length":86,"rects":[[450.82012939453125,311.55169677734375,286.076904296875,13.5],[55.0233268737793,338.3466796875,510.98662185668945,13.5]],"start":755,"text":"kd-tree采取的思想就是计算所有数据点在每个维度上的数值的方差\n然后方差最大的维度就作为当前节点的划分维度，这样做的原理其实就是：方差越大，说明这个维度上的数据波动越大"}],"type":5,"uuid":"bcb43113458e244783d711523c8987b4"}],"originaltext":"kd-tree与bst不同的地方在于进行分支决策的时候，还需要选择一个维度的值进行比较，选择哪个维度呢？","page":0,"textblocks":[{"first":[695.9829711914062,235.7808074951172,4.913330078125,12.5],"last":[461.1985778808594,251.7491455078125,9.82666015625,12.5],"length":53,"rects":[[695.9829711914062,235.7808074951172,40.41021728515625,12.5],[55.0233268737793,251.7491455078125,416.0019111633301,12.5]],"start":417,"text":"kd-tree与\nbst不同的地方在于进行分支决策的时候，还需要选择一个维度的值进行比较，选择哪个维度呢？"}],"type":5,"uuid":"ad00a11124d38c2d83fbdb0b45473162"},{"date":"2022-04-09 13:36:33","docid":0,"fillcolor":"fffeeb73","id":7,"markups":[{"date":"2022-04-09 13:36:42","docid":0,"fillcolor":"fffeeb73","id":8,"markups":[{"date":"2022-04-09 13:36:52","docid":0,"fillcolor":"fffeeb73","id":9,"markups":[{"date":"2022-04-09 13:37:24","docid":0,"fillcolor":"fffeeb73","id":10,"originaltext":"我们首先扫描到叶子节点，扫描的过程中记录的最近点为p（5，4），最短距离为d, 现在开始回溯，假设分割的维度为ss，其实回溯的过程就是确定是否有必要进入相邻子空间进行搜索，确定的依据就是当前点到最近点的距离d是否大于当前点到分割面（在二维空间中实际上就是一条线）的距离L，如果d < L,那么说明完全没有必要进入到另一个子空间进行搜索，直接继续向上一层回溯；如果有d > L,那么说明相邻子空间中可能有距查询点更近的点","page":4,"textblocks":[{"first":[55.0233268737793,308.48095703125,9.826663970947266,13.5],"last":[610.5226440429688,340.417724609375,9.82666015625,13.5],"length":211,"rects":[[55.0233268737793,308.48095703125,685.707447052002,13.5],[55.0233268737793,324.44921875,684.349536895752,13.5],[55.0233268737793,340.417724609375,565.3259773254395,13.5]],"start":393,"text":"我们首先扫描到叶子节点，扫描的过程中记录的最近点为p（5，4），最短距离为d, 现在开始回溯，假设分割的维度为ss，其实回溯的过程就是确定是否有必要\n进入相邻子空间进行搜索，确定的依据就是当前点到最近点的距离d是否大于当前点到分割面（在二维空间中实际上就是一条线）的距离L，如果d < L,那么说明\n完全没有必要进入到另一个子空间进行搜索，直接继续向上一层回溯；如果有d > L,那么说明相邻子空间中可能有距查询点更近的点"}],"type":5,"uuid":"0aacc0c335f4446b729712072df512f4"}],"originaltext":"2.回溯查找：通过计算查找点到分割平面的距离(这个距离比较的是分割维度上的值的差，并不是分割节点到分割平面上的距离，虽然两者的值是相等的)与当前最短距离进行比较，决定是否需要进入节点的相邻子空间进行查找","page":4,"textblocks":[{"first":[55.0233268737793,77.940185546875,5.463626861572266,12.5],"last":[330.16998291015625,93.908447265625,9.82666015625,12.5],"length":102,"rects":[[55.0233268737793,77.940185546875,682.953296661377,12.5],[55.0233268737793,93.908447265625,284.97331619262695,12.5]],"start":181,"text":"2.回溯查找：通过计算查找点到分割平面的距离(这个距离比较的是分割维度上的值的差，并不是分割节点到分割平面上的距离，虽然两者的值是相等的)与当前\n最短距离进行比较，决定是否需要进入节点的相邻子空间进行查找"}],"type":5,"uuid":"2d495553b6ba75b975e1b4a472305599"}],"originaltext":"1.二叉查找：从根节点开始进行查找，直到叶子节点；","page":4,"textblocks":[{"first":[55.0233268737793,51.84502029418945,5.463626861572266,13.499996185302734],"last":[279.4052734375,51.84502029418945,9.82666015625,13.499996185302734],"length":25,"rects":[[55.0233268737793,51.84502029418945,234.2086067199707,13.499996185302734]],"start":115,"text":"1.二叉查找：从根节点开始进行查找，直到叶子节点；"}],"type":5,"uuid":"6b014a8e8308f6ea1c63dd3c233a37ef"}],"originaltext":"说完了kd-tree的构建，现在再来说一下如何利用kd-tree进行最近邻的查找","page":4,"textblocks":[{"first":[55.0233268737793,0.18924808502197266,9.826663970947266,13.582409858703613],"last":[361.8571472167969,0.18924808502197266,9.82666015625,13.582409858703613],"length":40,"rects":[[55.0233268737793,0.18924808502197266,316.6604804992676,13.582409858703613]],"start":61,"text":"说完了kd-tree的构建，现在再来说一下如何利用kd-tree进行最近邻的查找"}],"type":5,"uuid":"e22f08e001c22e1f64e0cac4ec3bccbb"}],"maxid":10,"notelinks":[],"scalingratio":60,"title":"(45条消息) KD-tree的原理以及构建与查询操作的python实现_天才暴风的博客-CSDN博客_kd-tree python","unimportant":[]}