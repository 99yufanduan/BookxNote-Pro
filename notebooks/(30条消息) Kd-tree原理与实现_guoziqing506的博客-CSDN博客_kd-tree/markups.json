{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-03-30 17:50:12","docid":0,"fillcolor":"fffeeb73","id":1,"markups":[{"date":"2022-03-30 17:51:33","docid":0,"fillcolor":"fffeeb73","id":3,"originaltext":"数据应用当中，最近邻查询是非常重要的功能。不论是 信息检索","page":0,"textblocks":[{"first":[55.0233268737793,137.14822387695312,9.826663970947266,13.582412719726562],"last":[322.1858215332031,137.14822387695312,9.82666015625,13.582412719726562],"length":29,"rects":[[55.0233268737793,137.14822387695312,276.9891548156738,13.582412719726562]],"start":113,"text":"数据应用当中，最近邻查询是非常重要的功能。不论是 信息检索"}],"type":5},{"date":"2022-03-30 17:50:46","docid":0,"fillcolor":"fffeeb73","id":2,"originaltext":"1. 基本原理","page":0,"textblocks":[{"first":[55.0233268737793,195.6166534423828,8.33669662475586,16.5],"last":[111.78582763671875,195.6166534423828,13.511665344238281,16.5],"length":7,"rects":[[55.0233268737793,195.6166534423828,70.27416610717773,16.5]],"start":292,"text":"1. 基本原理"}],"type":5},{"date":"2022-03-30 17:52:04","docid":0,"fillcolor":"fffeeb73","id":4,"markups":[{"date":"2022-03-30 17:53:40","docid":0,"fillcolor":"fffeeb73","id":7,"markups":[{"date":"2022-03-30 17:52:14","docid":0,"fillcolor":"fffeeb73","id":5,"originaltext":"我们不比较全部的k维数据，而是选择其中某一个维度比较","page":1,"textblocks":[{"first":[165.8612060546875,461.4083251953125,9.82666015625,13.5],"last":[406.6145324707031,461.4083251953125,9.82666015625,13.5],"length":26,"rects":[[165.8612060546875,461.4083251953125,250.57998657226562,13.5]],"start":436,"text":"我们不比较全部的k维数据，而是选择其中某一个维度比较"}],"type":5}],"originaltext":"可是在多维空间就存在一个关键问题：每个数据条目由多个数值组成，我们怎么比较？","page":1,"textblocks":[{"first":[163.1166534423828,435.61328125,9.82666015625,13.5],"last":[526.7033081054688,435.61328125,9.82666015625,13.5],"length":38,"rects":[[163.1166534423828,435.61328125,373.41331481933594,13.5]],"start":382,"text":"可是在多维空间就存在一个关键问题：每个数据条目由多个数值组成，我们怎么比较？"}],"type":5},{"date":"2022-03-30 17:54:27","docid":0,"fillcolor":"fffeeb73","id":9,"originaltext":"对于一个由n维数据构成的数据集，我们首先寻找方差最大的那个维度，设这个维度是 ，然后找出在维度 上所有数据项的中位数","page":2,"textblocks":[{"first":[74.6766586303711,146.7266845703125,9.826667785644531,12.5],"last":[623.1178588867188,146.7266845703125,9.82666015625,12.5],"length":58,"rects":[[74.6766586303711,146.7266845703125,558.2678604125977,12.5]],"start":389,"text":"对于一个由n维数据构成的数据集，我们首先寻找方差最大的那个维度，设这个维度是 ，然后找出在维度 上所有数据项的中位数"}],"title":"第一步","type":5},{"date":"2022-03-30 17:56:23","docid":0,"fillcolor":"fffeeb73","id":12,"originaltext":"按划分数据集，一分为二，记这两个数据子集为。建立树节点，存储这次划分的情况（记录划分的维度 以及中位数）；","page":2,"textblocks":[{"first":[653.5382690429688,146.7266845703125,9.82666015625,12.5],"last":[556.7686767578125,162.695068359375,9.82666015625,12.5],"length":54,"rects":[[653.5382690429688,146.7266845703125,79.55377197265625,12.5],[74.6766586303711,162.695068359375,491.9186782836914,12.5]],"start":448,"text":"按划分数据集，\n一分为二，记这两个数据子集为。建立树节点，存储这次划分的情况（记录划分的维度 以及中位数）；"}],"title":"第二步","type":5},{"date":"2022-03-30 17:56:56","docid":0,"fillcolor":"fffeeb73","id":13,"originaltext":"递归地进行以上两步，直到不能再划分为止（所谓不能划分是说当前节点中包含的数据项的数量小于了我们事先规定的阈值，不失一般性，我在此篇博客中默认这个阈值是2，也就是说所有叶子节点包含的数据项不会多于2条），不能再划分时，将对应的数据保存至最后的节点中，这些最后的节点也就是叶子节点。","page":2,"textblocks":[{"first":[74.6766586303711,203.4583740234375,9.826667785644531,13.5],"last":[94.32998657226562,235.39501953125,9.826667785644531,13.5],"length":141,"rects":[[74.6766586303711,203.4583740234375,668.2132949829102,13.5],[74.6766586303711,219.4267578125,659.4902114868164,13.5],[74.6766586303711,235.39501953125,29.479995727539062,13.5]],"start":539,"text":"递归地进行以上两步，直到不能再划分为止（所谓不能划分是说当前节点中包含的数据项的数量小于了我们事先规定的阈值，不失一般性，我在此篇博客中\n默认这个阈值是2，也就是说所有叶子节点包含的数据项不会多于2条），不能再划分时，将对应的数据保存至最后的节点中，这些最后的节点也就是叶子\n节点。"}],"title":"第三步","type":5}],"originaltext":"2. kd-tree的构建","page":1,"textblocks":[{"first":[55.0233268737793,392.76416015625,8.33669662475586,16.5],"last":[148.020751953125,392.76416015625,13.51165771484375,16.5],"length":13,"rects":[[55.0233268737793,392.76416015625,106.50908279418945,16.5]],"start":286,"text":"2. kd-tree的构建"}],"type":5}],"originaltext":"Kd-tree原理与实现","page":0,"textblocks":[{"first":[55.0233268737793,14.308330535888672,11.917285919189453,20.5],"last":[188.80023193359375,14.308330535888672,17.196670532226562,20.5],"length":12,"rects":[[55.0233268737793,14.308330535888672,150.97357559204102,20.5]],"start":63,"text":"Kd-tree原理与实现"}],"type":5}],"maxid":13,"title":"(30条消息) Kd-tree原理与实现_guoziqing506的博客-CSDN博客_kd-tree","unimportant":[]}