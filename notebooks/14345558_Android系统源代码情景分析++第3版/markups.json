{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2023-07-11 15:54:56","docid":0,"id":1,"linecolor":"ff59c6ff","page":0,"rect":[0,0.8046875,1,1.8046875],"title":"封面","type":8,"uuid":"504643d9a41a837a0d22e4159d862a87"},{"date":"2023-07-11 15:54:56","docid":0,"id":2,"linecolor":"ff59c6ff","page":1,"rect":[0,0.2855224609375,1,1.2855224609375],"title":"书名","type":8,"uuid":"b43f9d8171ad51845265fa7e17d59dcd"},{"date":"2023-07-11 15:54:56","docid":0,"id":3,"linecolor":"ff59c6ff","page":2,"rect":[0,0.00921630859375,1,1.00921630859375],"title":"版权","type":8,"uuid":"d5c0d104257820a164e407f56893bfd3"},{"date":"2023-07-11 15:54:56","docid":0,"id":4,"linecolor":"ff59c6ff","page":3,"rect":[0,0.2855224609375,1,1.2855224609375],"title":"前言","type":8,"uuid":"bfd286dde692eae10d202dbb8fa53e33"},{"date":"2023-07-11 15:54:56","docid":0,"id":5,"linecolor":"ff59c6ff","page":5,"rect":[0,0.2855224609375,1,1.2855224609375],"title":"目录","type":8,"uuid":"126bffee9f13459ddb4483f60ff37fd7"},{"date":"2023-07-18 12:22:28","docid":0,"fillcolor":"fffeeb73","id":874,"markups":[{"date":"2023-07-18 12:26:11","docid":0,"fillcolor":"fffeeb73","id":886,"markups":[{"date":"2023-07-18 12:24:37","docid":0,"fillcolor":"fffeeb73","id":878,"originaltext":"最底层的是各种硬件设备，往上一层是Bootloader。当我们按下手机电源键时，Bootloade漫：第一个跑起来的程序，负责初始化硬件，以及将OS启动起来。使用最广泛的Bootloader是一个叫uboot的程序，它支持非常多的体系结构。经过编译后，uhoot会生成一个心叩t.bin镜像，将这个镜像烧到设备上的一个特定分区中，就可以作为Bootloade计吏用了","page":24,"textblocks":[{"first":[56.153900146484375,577.5446166992188,10.731498718261719,9.3599853515625],"last":[248.53817749023438,626.024658203125,7.968109130859375,9.3599853515625],"length":186,"rects":[[56.153900146484375,577.5446166992188,445.91015625,9.3599853515625],[34.79389953613281,593.8546142578125,467.75010681152344,9.1199951171875],[34.54389953613281,609.9446411132812,467.5200653076172,9.3599853515625],[35.034000396728516,626.024658203125,221.47228622436523,9.3599853515625]],"start":935,"text":"最底层的是各种硬件设备，往上一层是Bootloader。当我们按下手机电源键时，Bootloade漫：第一\n个跑起来的程序，负责初始化硬件，以及将OS启动起来。使用最广泛的Bootloader是一个叫uboot的程\n序，它支持非常多的体系结构。经过编译后，uhoot会生成一个心叩t.bin镜像，将这个镜像烧到设备上\n的一个特定分区中，就可以作为Bootloade计吏用了"}],"type":5,"uuid":"ec04241fab968a5d0f65fb65736af24f"},{"date":"2023-07-18 12:24:39","docid":0,"fillcolor":"fffeeb73","id":879,"originaltext":"Bootloader支持交互式启动，也就是说，我们可以让Bootloader初始化完成硬件之后，不是马上去启动OS,而是停留在当前状态，等待用户输人命令告诉它接下来该干什么。这种启动方式就称为Fru叫tboot模式。通常，在关机状态下，同时按下音量下键和电源键，可以进人Fasthoot模式","page":24,"textblocks":[{"first":[56.153900146484375,641.8646240234375,4.728000640869141,9.5999755859375],"last":[433.03399658203125,674.2646484375,8.480010986328125,9.1199951171875],"length":147,"rects":[[56.153900146484375,641.8646240234375,445.9100646972656,9.5999755859375],[34.313899993896484,658.4246215820312,467.51071548461914,9.1199951171875],[34.313899993896484,674.2646484375,407.2001075744629,9.1199951171875]],"start":1123,"text":"Bootloader支持交互式启动，也就是说，我们可以让Bootloader初始化完成硬件之后，不是马上\n去启动OS,而是停留在当前状态，等待用户输人命令告诉它接下来该干什么。这种启动方式就称为\nFru叫tboot模式。通常，在关机状态下，同时按下音量下键和电源键，可以进人Fasthoot模式"}],"type":5,"uuid":"1562998974c8944970b519805f68d349"},{"date":"2023-07-18 12:24:42","docid":0,"fillcolor":"fffeeb73","id":880,"originaltext":"在Fasthoot模式下，我们可以通过fasthootT具将一个镜像(recovery.img)刷人设备的Recovery分区。这个过程就称为刷Recovery。Recovery镜像包含一个小型的系统。通常，在关机状态下，同时按下音量上键和电源键，就可以将这个系统运行起来。这种启动方式就称为Recovery模式。","page":24,"textblocks":[{"first":[55.67399978637695,690.3446044921875,9.84000015258789,9.1199951171875],"last":[436.3039855957031,722.74462890625,3.1199951171875,9.1199951171875],"length":159,"rects":[[55.67399978637695,690.3446044921875,446.1498832702637,9.1199951171875],[35.034000396728516,706.4146118164062,466.31261825561523,9.1199951171875],[34.313899993896484,722.74462890625,405.11008071899414,9.1199951171875]],"start":1272,"text":"在Fasthoot模式下，我们可以通过fasthootT具将一个镜像(recovery.img)刷人设备的Recovery分\n区。这个过程就称为刷Recovery。Recovery镜像包含一个小型的系统。通常，在关机状态下，同时按\n下音量上键和电源键，就可以将这个系统运行起来。这种启动方式就称为Recovery模式。"}],"type":5,"uuid":"ca3d54f71bb97a06f2e9d6901a37c091"},{"date":"2023-07-18 12:24:47","docid":0,"fillcolor":"fffeeb73","id":881,"originaltext":"在Recovery模式下，我们可以修改正常模式下的系统，也就是平时开机进入的系统。在正常模式下，系统包含System和Boot两个核心分区。System分区包含Android运行时框架、系统App以及预装的第芒方App等；而Boot分区包含内核和根文件系统。刷入System和Boot分区的两个镜像分别称为system.img和boot.img。通常将它们打包和压缩成一个zip文件，例如update.zip,并且将它上传到手机的叫card上。这样当进入Recovery模式时，就可以在Recovery界面上使用该zip包更新在正常模式下使用的系统了。这个过程就是通常所说的刷ROM。","page":25,"textblocks":[{"first":[47.9838981628418,55.05284118652344,9.60000228881836,9.360000610351562],"last":[198.2239990234375,135.70269775390625,3.600006103515625,9.1199951171875],"length":297,"rects":[[47.9838981628418,55.05284118652344,447.1234931945801,9.360000610351562],[26.143999099731445,71.38280487060547,468.49003410339355,9.120002746582031],[26.143999099731445,87.22282409667969,468.9600658416748,9.360000610351562],[26.143999099731445,103.54270935058594,468.9602794647217,9.360000610351562],[26.143999099731445,119.85283660888672,468.97099113464355,9.120002746582031],[26.86400032043457,135.70269775390625,174.96000480651855,9.1199951171875]],"start":11,"text":"在Recovery模式下，我们可以修改正常模式下的系统，也就是平时开机进入的系统。在正常模式\n下，系统包含System和Boot两个核心分区。System分区包含Android运行时框架、系统App以及预装的\n第芒方App等；而Boot分区包含内核和根文件系统。刷入System和Boot分区的两个镜像分别称为system.\nimg和boot.img。通常将它们打包和压缩成一个zip文件，例如update.zip,并且将它上传到手机的叫card\n上。这样当进入Recovery模式时，就可以在Recovery界面上使用该zip包更新在正常模式下使用的系统\n了。这个过程就是通常所说的刷ROM。"}],"type":5,"uuid":"631da2dcea5bce70a346c7be00a119e5"},{"date":"2023-07-18 12:24:56","docid":0,"id":882,"imgfile":"84565c55eeda4924c4eb1b45dd747986.png","linecolor":"ffa0ec6f","linewidth":2,"page":25,"rect":[103.79999690651903,167.39999501109136,433.7999870717529,384.5999885380271],"type":2,"uuid":"5468734fba11ed915ed8606beb37a293"}],"originaltext":"1.7 为几机编译ROM","page":24,"textblocks":[{"first":[33.77389907836914,85.05464172363281,7.602100372314453,13.199996948242188],"last":[179.35391235351562,85.05464172363281,13.600006103515625,13.199996948242188],"length":12,"rects":[[33.77389907836914,85.05464172363281,159.1800193786621,13.199996948242188]],"start":25,"text":"1.7 为几机编译ROM"}],"type":5,"uuid":"1e12ca00102983c6809e0e726ef244bb"}],"originaltext":"第一章准备知识","page":12,"textblocks":[{"first":[39.35390090942383,129.2146453857422,16.079998016357422,15.360000610351562],"last":[147.94398498535156,165.46461486816406,36.1199951171875,25.199996948242188],"length":8,"rects":[[39.35390090942383,129.2146453857422,88.30999374389648,15.360000610351562],[39.58399963378906,165.46461486816406,144.47998046875,25.199996948242188]],"start":0,"text":"第勹章\n准备知识"}],"type":5,"uuid":"3dd98e0d0066c0a7d4d57e4171752b25"},{"date":"2023-07-18 12:25:13","docid":0,"fillcolor":"fffeeb73","id":883,"markups":[{"date":"2023-07-18 12:25:49","docid":0,"fillcolor":"fffeeb73","id":884,"originaltext":"Linux内核源代码是遵循GPL'协议的，即如果我们在Android系统所使用的Linux内核中添加或者修改了代码，那么就必须将它们公开","page":31,"textblocks":[{"first":[416.8739013671875,289.3028259277344,4.944000244140625,9.1199951171875],"last":[78.85130310058594,321.6928405761719,10.66290283203125,9.3599853515625],"length":70,"rects":[[416.8739013671875,289.3028259277344,67.19012451171875,9.1199951171875],[14.873900413513184,305.1328125,469.18988132476807,9.600006103515625],[14.873900413513184,321.6928405761719,74.640305519104,9.3599853515625]],"start":234,"text":"Linux内核源代\n码是遵循GPL'协议的，即如果我们在Android系统所使用的Linux内核中添加或者修改了代码，那么就\n必须将它们公开"}],"type":5,"uuid":"4c9841e53dde42acf40a9bfaea79065c"},{"date":"2023-07-18 12:25:53","docid":0,"fillcolor":"fffeeb73","id":885,"originaltext":"，其中，内核空间仍然是以硬件驱动模块的形式来支持，不过它只提供简单的硬件访问通道；而用户空间以硬件抽象层模块的形式来支持，它封装了硬件的实现细节和参数。这样就可以保护移动设备厂商的利益了。","page":31,"textblocks":[{"first":[207.51907348632812,418.662841796875,10.636398315429688,9.1199951171875],"last":[261.5939025878906,451.0628356933594,3.3599853515625,9.3599853515625],"length":96,"rects":[[207.51907348632812,418.662841796875,276.54669189453125,9.1199951171875],[15.11400032043457,434.98272705078125,468.9609203338623,9.1199951171875],[15.343899726867676,451.0628356933594,249.60998821258545,9.3599853515625]],"start":608,"text":"，其中，内核空间仍然是以硬件驱动模块的形式来支持，不\n过它只提供简单的硬件访问通道；而用户空间以硬件抽象层模块的形式来支持，它封装了硬件的实现\n细节和参数。这样就可以保护移动设备厂商的利益了。"}],"type":5,"uuid":"cd840a4c42aaf4de769aeceb0e591542"},{"date":"2023-07-18 12:26:27","docid":0,"fillcolor":"fffeeb73","id":887,"markups":[{"date":"2023-07-18 12:26:40","docid":0,"fillcolor":"fffeeb73","id":888,"originaltext":"硬件访问服务必须册过Java本地接口(Jmal\\atiYe lnterfacp, JNI)来叫用硬件抽象层模块的接rI","page":56,"textblocks":[{"first":[408.82427978515625,217.30462646484375,10.626708984375,9.1199951171875],"last":[377.92401123046875,234.09463500976562,2.763885498046875,8.160003662109375],"length":60,"rects":[[408.82427978515625,217.30462646484375,95.640380859375,9.1199951171875],[36.95389938354492,234.09463500976562,343.7339973449707,8.160003662109375]],"start":487,"text":"硬件访问服务必须册\n过Java本地接口(Jmal\\atiYe lnterfacp, JNI)来叫用硬件抽象层模块的接rI"}],"type":5,"uuid":"351eb883d32d66bbe47147c6feb58d4f"},{"date":"2023-07-18 12:26:49","docid":0,"fillcolor":"fffeeb73","id":889,"originaltext":"Android系统的硬件访问服务通常珆行在系统进程Sy、IPlll1中，间使川这些硬件访问服务的应川行厅己行h另外的进和中，即应川程序需婓通过进和间通估机制来访问这此硬fl访间服务Android系统捉供f种高效的进程间通估机制Bim伈进和间通估机制2.肋川程序就是通过它来访问运们什系统进和SystPlll中的硬件访问服务的Bim加进和间通信机制要求捉供服务的－方必须实现一个具介跨进程访问能力的服务接口．以便使川服务的－方可以通过这个服务接门来访问它因此，在实现硬件访问服务之前，我们首先哎定义它的服务接口","page":56,"textblocks":[{"first":[58.79389953613281,249.46463012695312,4.799999237060547,9.1199951171875],"last":[247.94003295898438,331.0646057128906,10.525787353515625,8.6400146484375],"length":259,"rects":[[58.79389953613281,249.46463012695312,446.16075134277344,9.1199951171875],[37.42399978637695,266.26458740234375,467.04999923706055,8.6400146484375],[36.95389938354492,281.8546142578125,467.7599678039551,8.8800048828125],[38.153900146484375,298.66461181640625,466.3128356933594,8.6400146484375],[36.95389938354492,314.7445983886719,467.75004959106445,8.6400146484375],[37.42399978637695,331.0646057128906,221.04182052612305,8.6400146484375]],"start":549,"text":"Android系统的硬件访问服务通常珆行在系统进程Sy、IPlll1中，间使川这些硬件访问服务的应川行\n厅己行h另外的进和中，即应川程序需婓通过进和间通估机制来访问这此硬fl访间服务Android系\n统捉供f种高效的进程间通估机制Bim伈进和间通估机制2.肋川程序就是通过它来访问运们什\n系统进和SystPlll中的硬件访问服务的Bim加进和间通信机制要求捉供服务的－方必须实现一个具介\n跨进程访问能力的服务接口．以便使川服务的－方可以通过这个服务接门来访问它因此，在实现硬\n件访问服务之前，我们首先哎定义它的服务接口"}],"type":5,"uuid":"747b997b93bf63f1471adf0be734cf09"}],"originaltext":"2.4 Jf发Android硬件访问服务","page":56,"textblocks":[{"first":[36.85390090942383,148.4246368408203,7.572700500488281,13.199996948242188],"last":[247.70404052734375,148.4246368408203,16.040008544921875,13.199996948242188],"length":20,"rects":[[36.85390090942383,148.4246368408203,226.8901481628418,13.199996948242188]],"start":336,"text":"2.4 Jf发Android硬件访问服务"}],"type":5,"uuid":"800a56c505ce6f814972784082af94a4"}],"originaltext":"第章硬件抽象层","page":31,"textblocks":[{"first":[15.82390022277832,120.82280731201172,44.160003662109375,15.120002746582031],"last":[135.10389709472656,157.06283569335938,29.759994506835938,24.959991455078125],"length":8,"rects":[[15.82390022277832,120.82280731201172,88.32000541687012,15.120002746582031],[16.063899993896484,157.06283569335938,148.79999160766602,24.959991455078125]],"start":0,"text":"第章\n硬件抽象层"}],"type":5,"uuid":"6adb40b398506d305384b05b1e068586"},{"date":"2023-07-18 13:57:15","docid":0,"fillcolor":"fffeeb73","id":891,"markups":[{"date":"2023-07-18 13:57:51","docid":0,"fillcolor":"fffeeb73","group":[{"date":"2023-07-18 13:57:51","docid":0,"fillcolor":"fffeeb73","id":893,"originaltext":"","page":68,"textblocks":[{"first":[46.54389953613281,54.104618072509766,10.457199096679688,8.880001068115234],"last":[123.82389831542969,54.104618072509766,8.8800048828125,8.880001068115234],"length":8,"rects":[[46.54389953613281,54.104618072509766,86.16000366210938,8.880001068115234]],"start":61,"text":"不能释放的问题f"}],"type":5,"uuid":"fe099ac105842922bd3c7ce747d8a989"}],"id":892,"originaltext":"在使用强引用计数和弱引用计数的解决方案中，一般将有关联的对象划分为“父－子”和“子－父“关系在“父－子”关系中，“父”对象通过强引用计数来引用“子”对象；而在“子－父”关系中，“子”对象通过弱引用计数来引用“父”对象。这样就可以解决由于相互引用而造成对象\n不能释放的问题f","page":67,"textblocks":[{"first":[71.743896484375,679.0628662109375,10.609298706054688,9.3599853515625],"last":[475.0149841308594,711.4628295898438,10.732391357421875,9.1199951171875],"length":129,"rects":[[71.743896484375,679.0628662109375,413.7629699707031,9.3599853515625],[23.743900299072266,695.3826904296875,456.4798240661621,8.8800048828125],[18.224000930786133,711.4628295898438,467.5233745574951,9.1199951171875]],"start":1255,"text":"在使用强引用计数和弱引用计数的解决方案中，一般将有关联的对象划分为“父－子”和\n“子－父“关系在“父－子”关系中，“父”对象通过强引用计数来引用“子”对象；而在“子－父”\n关系中，“子”对象通过弱引用计数来引用“父”对象。这样就可以解决由于相互引用而造成对象"}],"type":5,"uuid":"d2ac91d854c9ef636185a30df570c5f1"}],"originaltext":"第三章智能指针","page":67,"textblocks":[{"first":[19.183900833129883,122.25272369384766,15.840002059936523,15.599998474121094],"last":[127.66390228271484,158.50282287597656,36.00000762939453,25.199996948242188],"length":9,"rects":[[19.183900833129883,122.25272369384766,87.83999443054199,15.599998474121094],[19.66390037536621,158.50282287597656,144.00000953674316,25.199996948242188]],"start":0,"text":"第：二章\n智能指针"}],"type":5,"uuid":"3471d1e907ca20c6098cf7b313734dcb"},{"date":"2023-07-18 13:58:13","docid":0,"fillcolor":"fffeeb73","id":894,"markups":[{"date":"2023-07-18 13:58:25","docid":0,"fillcolor":"fffeeb73","id":895,"markups":[{"date":"2023-07-13 10:40:53","docid":0,"id":859,"imgfile":"a396865146c10523b8c1b593c9934d38.png","linecolor":"ffa0ec6f","linewidth":2,"page":93,"rect":[28.65115633031415,40.21214923552863,468.97419045935266,364.4226024469782],"type":2,"uuid":"deda0eca76d9913cc1d95999062c267d"}],"originaltext":"Android提供的Logger日志系统是基于内核中的Logger日志驱动程序实现的，它将日志记录保存在内核空间中。为了有效地利用内存空间，Logger日志驱动程序在内部使用一个环形缓冲区来保存日志。因此，当Logger日志驱动程序中的环形缓冲区满了之后，新的H志就会覆盖旧的日志由于新的日志会覆盖旧的日志，因此，Logger日志驱动程序根据H志的类型以及日志的输出量来对日志记录进行分类，避免重要的日志被不重要的日志覆盖，或者数据队大的日志覆盖数据最小的日志。H志的类型一共有四种，它们分别是main、system、radio和events。在Logger日志驱动程序中，这四种类型的日志分别通过/dev/log/main、/dev/log/system、/dev/log/radio和/dev/log/events四个设备文件来访问。类刮为main的日志是应用程序级别的，而类型为system的日志是系统级别的。由于系统级日志要比应用程序级日志重要，因此，把它们分开来记录，可以避免系统级日志被应用程序级H志覆盖类型为radio的日志是与无线设备相关的，它们的量很大，因此，把它们单独记录在一起，可以避免它们覆盖其他类型的H志。类型为events的日志是专门用来诊断系统问题的，应用程序开发者不应该使用此种类型的日志。","page":92,"textblocks":[{"first":[65.50399780273438,234.1046142578125,4.902900695800781,9.1199951171875],"last":[119.50399780273438,452.984619140625,3.1200027465820312,9.1199951171875],"length":573,"rects":[[65.50399780273438,234.1046142578125,447.1300354003906,9.1199951171875],[44.86399841308594,252.33462524414062,466.33058166503906,9.1199951171875],[44.6338996887207,270.3346252441406,411.35090255737305,9.1199951171875],[66.46389770507812,288.5846252441406,446.1608581542969,9.1199951171875],[44.3838996887207,306.8246154785156,466.7985954284668,9.1199951171875],[44.3838996887207,325.30462646484375,468.0103874206543,9.1199951171875],[45.11399841308594,343.30462646484375,467.52040100097656,9.3599853515625],[44.153900146484375,362.0246276855469,25.43000030517578,9.1199951171875],[65.26390075683594,380.02459716796875,447.61012268066406,8.8800048828125],[45.58399963378906,398.0246276855469,467.51988220214844,9.1199951171875],[44.6338996887207,416.0246276855469,467.98981857299805,9.3599853515625],[44.6338996887207,434.254638671875,467.7502555847168,9.3599853515625],[44.3838996887207,452.984619140625,78.2401008605957,9.1199951171875]],"start":15,"text":"Android提供的Logger日志系统是基于内核中的Logger日志驱动程序实现的，它将日志记录保存在\n内核空间中。为了有效地利用内存空间，Logger日志驱动程序在内部使用一个环形缓冲区来保存日\n志。因此，当Logger日志驱动程序中的环形缓冲区满了之后，新的H志就会覆盖旧的日志\n由于新的日志会覆盖旧的日志，因此，Logger日志驱动程序根据H志的类型以及日志的输出量来\n对日志记录进行分类，避免重要的日志被不重要的日志覆盖，或者数据队大的日志覆盖数据最小的日\n志。H志的类型一共有四种，它们分别是main、system、radio和events。在Logger日志驱动程序中，这\n四种类型的日志分别通过/dev/log/main、/dev/log/system、/dev/log/radio和/dev/log/events四个设备文件来\n访问。\n类刮为main的日志是应用程序级别的，而类型为system的日志是系统级别的。由于系统级日志要\n比应用程序级日志重要，因此，把它们分开来记录，可以避免系统级日志被应用程序级H志覆盖类\n型为radio的日志是与无线设备相关的，它们的量很大，因此，把它们单独记录在一起，可以避免它们\n覆盖其他类型的H志。类型为events的日志是专门用来诊断系统问题的，应用程序开发者不应该使用\n此种类型的日志。"}],"type":5,"uuid":"916dd31623dd6e7aee57af60ecdb72a4"}],"originaltext":"第t章Logger日志系统","page":92,"position":{"x":21,"y":1844},"textblocks":[{"first":[44.86399841308594,129.93460083007812,16.080001831054688,15.839996337890625],"last":[237.34388732910156,166.17465209960938,28.560012817382812,24.959991455078125],"length":14,"rects":[[44.86399841308594,129.93460083007812,88.55990600585938,15.839996337890625],[45.83399963378906,166.17465209960938,220.0699005126953,24.959991455078125]],"start":0,"text":"第t章\nLogger日志系统"}],"type":5,"uuid":"e7b4a39cc51f62c5c9878fa47091d744"},{"date":"2023-07-18 12:21:08","docid":0,"fillcolor":"fffeeb73","id":872,"markups":[{"date":"2023-07-18 13:59:05","docid":0,"fillcolor":"fffeeb73","id":899,"markups":[{"date":"2023-07-13 13:59:59","docid":0,"id":860,"imgfile":"e761f1cf8b05d04620de297c50a1f63d.png","linecolor":"ffa0ec6f","linewidth":2,"page":163,"rect":[58.810268256960626,27.143200733981825,455.90524195780586,277.9664815905917],"type":2,"uuid":"d2a582cbea72d7e0d02f54f83b4645f1","width":558}],"originaltext":"以L描述的Bin<伈进程间通估机制,1,涉及八:lif-'111、St>rvil'P,沁·vin、Manag<-'1利Bindf-'1驱动程序四个用色，它1(j的关系如图汇II听小","page":162,"textblocks":[{"first":[60.70389938354492,569.6246337890625,8.15999984741211,8.8800048828125],"last":[172.55389404296875,586.4146118164062,8.639999389648438,8.4000244140625],"length":91,"rects":[[60.70389938354492,569.6246337890625,446.64995193481445,8.8800048828125],[39.11399841308594,586.4146118164062,142.07989501953125,8.4000244140625]],"start":1253,"text":"以L描述的Bin<伈进程间通估机制,1,涉及八:lif-'111、St>rvil'P,沁·vin、Manag<-'1利Bindf-'1驱动程序四个\n用色，它1(j的关系如图汇II听小"}],"type":5,"uuid":"875c398ddd83ed091325355e8099425e"}],"originaltext":"第五章Binder进程间通信系统","page":162,"position":{"x":384,"y":2676},"textblocks":[{"first":[39.58399963378906,161.85464477539062,15.319999694824219,24.959991455078125],"last":[314.69287109375,161.85464477539062,30.1715087890625,24.959991455078125],"length":13,"rects":[[39.58399963378906,161.85464477539062,305.28038024902344,24.959991455078125]],"start":3,"text":"Binder进程间通信系统"}],"type":5,"uuid":"39ae0ee2ace9d752dce5144f05a4f4b9"}],"maxid":899,"notelinks":[],"scalingratio":60,"summaries":[],"title":"14345558_Android系统源代码情景分析++第3版","unimportant":[]}