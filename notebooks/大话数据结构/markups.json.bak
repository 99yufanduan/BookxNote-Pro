{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-02-28 17:46:08","docid":0,"id":1,"linecolor":"ff59c6ff","page":2,"rect":[0,36.07000732421875,1,37.07000732421875],"title":"前言","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":2,"linecolor":"ff59c6ff","page":9,"rect":[0,34.07000732421875,1,35.07000732421875],"title":"目录","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":3,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-28 17:46:08","docid":0,"id":4,"linecolor":"ff59c6ff","page":26,"rect":[0,7.07000732421875,1,8.07000732421875],"title":"1.1 开场白","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":5,"linecolor":"ff59c6ff","page":27,"rect":[0,17.07000732421875,1,18.07000732421875],"title":"1.2 你数据结构怎么学的？","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":6,"linecolor":"ff59c6ff","page":28,"rect":[0,257.07000732421875,1,258.07000732421875],"title":"1.3 数据结构起源","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":7,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-01 19:46:07","docid":0,"fillcolor":"ffffed99","id":215,"markups":[{"date":"2022-03-01 19:47:39","docid":0,"fillcolor":"ff60bb46","id":220,"originaltext":"数据:是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。","page":29,"textblocks":[{"first":[87.22000122070312,251.48321533203125,10.871597290039062,9.126800537109375],"last":[237.3000030517578,268.72320556640625,3.04229736328125,9.126800537109375],"length":52,"rects":[[87.22000122070312,251.48321533203125,369.63458251953125,9.126800537109375],[67.94999694824219,268.72320556640625,172.39230346679688,9.126800537109375]],"start":128,"text":"数据:是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识\n别，并输入给计算机处理的符号集合。"}],"type":5}],"originaltext":"1.4.1数据","page":29,"textblocks":[{"first":[69.47000122070312,224.10910034179688,4.056396484375,10.140899658203125],"last":[116.46019744873047,224.10910034179688,12.845100402832031,10.140899658203125],"length":7,"rects":[[69.47000122070312,224.10910034179688,59.835296630859375,10.140899658203125]],"start":120,"text":"1.4.丁数据"}],"type":5},{"date":"2022-03-01 19:46:17","docid":0,"fillcolor":"ffffed99","id":216,"markups":[{"date":"2022-03-01 19:47:45","docid":0,"fillcolor":"ff60bb46","id":221,"originaltext":"数据元素:是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。","page":29,"textblocks":[{"first":[87.72000122070312,548.1101684570312,10.569900512695312,8.61981201171875],"last":[153.63999938964844,565.8501586914062,3.04229736328125,8.61981201171875],"length":45,"rects":[[87.72000122070312,548.1101684570312,370.1457824707031,8.61981201171875],[68.95999908447266,565.8501586914062,87.72229766845703,8.61981201171875]],"start":473,"text":"数据元素:是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处\n理。也被称为记录。"}],"type":5}],"originaltext":"1.4.2数据元素","page":29,"textblocks":[{"first":[70.4800033569336,521.2291259765625,4.056396484375,10.140869140625],"last":[143.3686981201172,521.2291259765625,12.802902221679688,10.140869140625],"length":9,"rects":[[70.4800033569336,521.2291259765625,85.69159698486328,10.140869140625]],"start":463,"text":"1.4.2数据元素"}],"type":5},{"date":"2022-03-01 19:46:25","docid":0,"fillcolor":"ffffed99","id":217,"markups":[{"date":"2022-03-01 19:47:50","docid":0,"fillcolor":"ff60bb46","id":222,"originaltext":"数据项:一个数据元素可以自若干个数据项组成。","page":30,"textblocks":[{"first":[84.68000030517578,94.30319213867188,10.334098815917969,9.126800537109375],"last":[303.2200012207031,94.30319213867188,3.04229736328125,9.126800537109375],"length":22,"rects":[[84.68000030517578,94.30319213867188,221.5822982788086,9.126800537109375]],"start":13,"text":"数据项:一个数据元素可以自若干个数据项组成。"}],"type":5},{"date":"2022-03-01 19:47:54","docid":0,"fillcolor":"ff60bb46","id":223,"originaltext":"数据项是数据不可分割的最小单位。","page":30,"textblocks":[{"first":[84.68000030517578,172.39321899414062,10.546501159667969,9.126800537109375],"last":[243.38999938964844,172.39321899414062,10.5718994140625,9.126800537109375],"length":16,"rects":[[84.68000030517578,172.39321899414062,169.28189849853516,9.126800537109375]],"start":117,"text":"数据项是数据不可分割的最小单位。"}],"type":5}],"originaltext":"1.4.3数据项","page":30,"textblocks":[{"first":[66.93000030517578,66.42210388183594,5.374702453613281,10.647903442382812],"last":[126.76220703125,66.42210388183594,12.676101684570312,10.647903442382812],"length":8,"rects":[[66.93000030517578,66.42210388183594,72.50830841064453,10.647903442382812]],"start":4,"text":"1.4.3数据项"}],"type":5},{"date":"2022-03-01 19:46:31","docid":0,"fillcolor":"ffffed99","id":218,"markups":[{"date":"2022-03-01 19:47:58","docid":0,"fillcolor":"ff60bb46","id":224,"originaltext":"数据对象:是性质相同的数据元素的集合，是数据的子集。","page":30,"textblocks":[{"first":[84.68000030517578,301.1802062988281,10.343696594238281,8.61981201171875],"last":[344.2900085449219,301.1802062988281,3.549285888671875,8.61981201171875],"length":26,"rects":[[84.68000030517578,301.1802062988281,263.15929412841797,8.61981201171875]],"start":298,"text":"数据对象:是性质相同的数据元素的集合，是数据的子集。"}],"type":5},{"date":"2022-03-01 19:48:01","docid":0,"fillcolor":"ff60bb46","id":225,"originaltext":"什么叫性质相同呢，是指数据元素具有相同数量和类型的数据项，比如，还是刚才的例子，人都有姓名、生日、性别等相同的数据项。","page":30,"textblocks":[{"first":[85.19000244140625,322.9801940917969,10.546501159667969,8.61981201171875],"last":[298.2125549316406,340.2173156738281,10.0775146484375,8.112701416015625],"length":60,"rects":[[85.19000244140625,322.9801940917969,369.1275939941406,8.61981201171875],[66.43000030517578,340.2173156738281,241.86006927490234,8.112701416015625]],"start":325,"text":"什么叫性质相同呢，是指数据元素具有相同数量和类型的数据项，比如，还是刚\n才的例子，人都有姓名、生日、性别等相同的数据项。"}],"type":5}],"originaltext":"1.4.4数据对象","page":30,"textblocks":[{"first":[67.44000244140625,273.2890930175781,4.056396484375,10.140899658203125],"last":[139.4383087158203,273.2890930175781,12.676101684570312,10.140899658203125],"length":9,"rects":[[67.44000244140625,273.2890930175781,84.67440795898438,10.140899658203125]],"start":288,"text":"1.4.4数据对象"}],"type":5},{"date":"2022-03-01 19:46:38","docid":0,"fillcolor":"ffffed99","id":219,"markups":[{"date":"2022-03-01 19:48:05","docid":0,"fillcolor":"ff60bb46","id":226,"originaltext":"数据结梅:是相互之间存在-种或多种特定关系的数据元蠢的集舍。","page":30,"textblocks":[{"first":[109.0199966430664,558.7501831054688,10.525497436523438,8.61981201171875],"last":[415.2699890136719,558.7501831054688,4.056396484375,8.61981201171875],"length":30,"rects":[[109.0199966430664,558.7501831054688,310.30638885498047,8.61981201171875]],"start":627,"text":"数据结梅:是相互之间存在-种或多种特定关系的数据元蠢的集舍。"}],"type":5}],"originaltext":"1.4.5数据结构","page":30,"textblocks":[{"first":[67.94999694824219,454.3091125488281,4.056396484375,10.140899658203125],"last":[140.4582977294922,454.3091125488281,12.676101684570312,10.140899658203125],"length":9,"rects":[[67.94999694824219,454.3091125488281,85.18440246582031,10.140899658203125]],"start":497,"text":"1.4.5数据结构"}],"type":5}],"page":29,"rect":[0,64.07000732421875,1,65.07000732421875],"title":"1.4 基本概念和术语","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":8,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-28 18:04:57","docid":0,"id":130,"imgfile":"26fe0bbf03310ccf782083d093fe350f.png","linecolor":"ffa0ec6f","linewidth":2,"page":31,"rect":[65.12415427901396,219.01011883460993,156.780371412441,237.82376340410283],"type":2},{"date":"2022-03-01 19:49:16","docid":0,"fillcolor":"ffffed99","id":227,"markups":[{"date":"2022-03-01 19:49:23","docid":0,"fillcolor":"ff60bb46","id":228,"originaltext":"逻辑结构:是指数据对象中数据元素之间的相互关系。","page":31,"textblocks":[{"first":[85.69999694824219,249.46022033691406,10.503097534179688,8.619796752929688],"last":[328.57000732421875,249.46022033691406,10.43060302734375,8.619796752929688],"length":24,"rects":[[85.69999694824219,249.46022033691406,253.3006134033203,8.619796752929688]],"start":124,"text":"逻辑结构:是指数据对象中数据元素之间的相互关系。"}],"type":5},{"date":"2022-03-01 19:49:27","docid":0,"fillcolor":"ffffed99","id":229,"markups":[{"date":"2022-03-01 19:49:29","docid":0,"fillcolor":"ff60bb46","id":230,"markups":[{"date":"2022-02-28 18:08:55","docid":0,"id":176,"imgfile":"5bdcd28622177ccdfdae93992b279bab.png","linecolor":"ffa0ec6f","linewidth":2,"page":31,"rect":[177.0412194103565,356.976845677558,348.77602624983035,526.7820479458019],"type":2}],"originaltext":"集合结构:集合结构中的数据元素除了同属于一个集合外，宫们之间没有其他关系。","page":31,"textblocks":[{"first":[85.69999694824219,307.26019287109375,10.530899047851562,8.61981201171875],"last":[74.79220581054688,323.9931945800781,7.352203369140625,9.126800537109375],"length":38,"rects":[[85.69999694824219,307.26019287109375,369.12254333496094,8.61981201171875],[67.44000244140625,323.9931945800781,14.70440673828125,9.126800537109375]],"start":187,"text":"集合结构:集合结构中的数据元素除了同属于一个集合外，宫们之间没有其他关\n系。"}],"type":5}],"originaltext":"1.集合结构","page":31,"textblocks":[{"first":[85.69999694824219,285.9701843261719,3.5493011474609375,8.61981201171875],"last":[131.45230102539062,285.9701843261719,10.01409912109375,8.61981201171875],"length":6,"rects":[[85.69999694824219,285.9701843261719,55.76640319824219,8.61981201171875]],"start":180,"text":"1.集合结构"}],"type":5},{"date":"2022-03-01 19:49:40","docid":0,"fillcolor":"ffffed99","id":231,"markups":[{"date":"2022-03-01 19:49:42","docid":0,"fillcolor":"ff60bb46","id":232,"markups":[{"date":"2022-02-28 18:08:57","docid":0,"id":177,"imgfile":"97dde07e5a43bf3d18741e7185c7a060.png","linecolor":"ffa0ec6f","linewidth":2,"page":32,"rect":[181.38282969562408,51.61692228040366,349.74082853544536,175.59401598193395],"type":2}],"originaltext":"线性结构:统性结构中的数据元素之间是一对一的关系","page":31,"textblocks":[{"first":[88.2300033569336,554.7032470703125,10.358200073242188,9.12677001953125],"last":[326.0299987792969,554.7032470703125,10.140899658203125,9.12677001953125],"length":24,"rects":[[88.2300033569336,554.7032470703125,247.9408950805664,9.12677001953125]],"start":319,"text":"线性结构:统性结构中的数据元素之间是一对一的关系"}],"type":5}],"originaltext":"2.线性结构","page":31,"textblocks":[{"first":[87.22000122070312,534.4202270507812,3.8029022216796875,8.61981201171875],"last":[133.35269165039062,534.4202270507812,10.140899658203125,8.61981201171875],"length":6,"rects":[[87.22000122070312,534.4202270507812,56.273590087890625,8.61981201171875]],"start":290,"text":"2.线性结构"}],"type":5},{"date":"2022-03-01 19:49:46","docid":0,"fillcolor":"ffffed99","id":233,"markups":[{"date":"2022-03-01 19:49:50","docid":0,"fillcolor":"ff60bb46","id":234,"markups":[{"date":"2022-02-28 18:09:01","docid":0,"id":178,"imgfile":"e64a7a7a27bf70dbc829c5b6376831d6.png","linecolor":"ffa0ec6f","linewidth":2,"page":32,"rect":[169.3228011254363,233.48215311883524,358.42404910598054,330.4447828231449],"type":2}],"originaltext":"树形结构:树形结构中的数据元素之间存在一种一对多的层次关系","page":32,"textblocks":[{"first":[85.69999694824219,203.32020568847656,10.57550048828125,8.619796752929688],"last":[382.38299560546875,203.32020568847656,10.57550048828125,8.619796752929688],"length":29,"rects":[[85.69999694824219,203.32020568847656,307.2584991455078,8.619796752929688]],"start":14,"text":"树形结构:树形结构中的数据元素之间存在一种一对多的层次关系"}],"type":5}],"originaltext":"3.树形结构","page":32,"textblocks":[{"first":[85.19000244140625,181.51730346679688,5.070503234863281,8.112701416015625],"last":[131.33270263671875,181.51730346679688,10.140899658203125,8.112701416015625],"length":6,"rects":[[85.19000244140625,181.51730346679688,56.283599853515625,8.112701416015625]],"start":7,"text":"3.树形结构"}],"type":5},{"date":"2022-03-01 19:49:53","docid":0,"fillcolor":"ffffed99","id":235,"markups":[{"date":"2022-03-01 19:59:05","docid":0,"id":268,"linecolor":"ffd01a11","linewidth":7,"originaltext":"也叫网形结构","page":32,"rect":[167.49999500811114,356.4999893754724,228.49999321997186,372.9999889135364],"type":11},{"date":"2022-03-01 19:49:56","docid":0,"fillcolor":"ff60bb46","id":236,"markups":[{"date":"2022-02-28 18:09:04","docid":0,"id":179,"imgfile":"e00616918af1be3e86a446709bb3292c.png","linecolor":"ffa0ec6f","linewidth":2,"page":32,"rect":[177.0412194103565,395.5689371021589,361.80085710563316,534.9828673735295],"type":2}],"originaltext":"图形结构:图形结构的数据元素是多对多的关系","page":32,"textblocks":[{"first":[86.70999908447266,380.7801818847656,10.285797119140625,8.61981201171875],"last":[292.42596435546875,380.7801818847656,10.285797119140625,8.61981201171875],"length":21,"rects":[[86.70999908447266,380.7801818847656,216.00176239013672,8.61981201171875]],"start":77,"text":"图形结构:图形结构的数据元素是多对多的关系"}],"type":5},{"date":"2022-03-01 19:50:01","docid":0,"fillcolor":"ff60bb46","id":237,"originaltext":"如果这个关系是有方向的，那么用带箭头的连续表示。","page":32,"textblocks":[{"first":[307.2740173339844,590.190185546875,9.836700439453125,8.61981201171875],"last":[184.31509399414062,607.934326171875,6.8450927734375,7.605712890625],"length":25,"rects":[[307.2740173339844,590.190185546875,147.55050659179688,8.61981201171875],[110.54000091552734,607.934326171875,80.62018585205078,7.605712890625]],"start":189,"text":"如果这个关系是有方向的，那么用\n带箭头的连续表示。"}],"type":5}],"originaltext":"4.图形结构","page":32,"textblocks":[{"first":[85.19000244140625,358.9801940917969,5.070503234863281,8.61981201171875],"last":[131.45230102539062,358.9801940917969,10.01409912109375,8.61981201171875],"length":6,"rects":[[85.19000244140625,358.9801940917969,56.276397705078125,8.61981201171875]],"start":70,"text":"4.图形结构"}],"type":5}],"originaltext":"1.5.1逻辑结构","page":31,"textblocks":[{"first":[67.94999694824219,221.5720977783203,5.5774993896484375,10.647903442382812],"last":[140.4582977294922,221.5720977783203,12.676101684570312,10.647903442382812],"length":9,"rects":[[67.94999694824219,221.5720977783203,85.18440246582031,10.647903442382812]],"start":114,"text":"1.5.1逻辑结构"}],"type":5},{"date":"2022-03-01 19:51:59","docid":0,"fillcolor":"ffffed99","id":240,"markups":[{"date":"2022-03-01 19:52:16","docid":0,"fillcolor":"ff60bb46","id":242,"markups":[{"date":"2022-03-01 19:52:03","docid":0,"fillcolor":"ff60bb46","id":241,"originaltext":"(很多书中也叫做存储结构","page":33,"textblocks":[{"first":[315.8900146484375,142.98318481445312,10.104705810546875,9.126800537109375],"last":[427.0417785644531,142.98318481445312,10.104705810546875,9.126800537109375],"length":12,"rects":[[315.8900146484375,142.98318481445312,121.2564697265625,9.126800537109375]],"start":114,"text":"(很多书中也叫做存储结构"}],"type":5}],"originaltext":"物理结构:是指数据的逻辑结构在计算机中的存储形式。","page":33,"textblocks":[{"first":[88.2300033569336,182.0202178955078,10.339302062988281,8.619796752929688],"last":[333.1357116699219,182.0202178955078,7.605712890625,8.619796752929688],"length":25,"rects":[[88.2300033569336,182.0202178955078,252.51142120361328,8.619796752929688]],"start":149,"text":"物理结构:是指数据的逻辑结构在计算机中的存储形式。"}],"type":5},{"date":"2022-03-01 19:52:19","docid":0,"fillcolor":"ffffed99","id":243,"markups":[{"date":"2022-03-01 19:52:21","docid":0,"fillcolor":"ff60bb46","id":244,"originaltext":"顺序存储结构:是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的","page":33,"textblocks":[{"first":[88.2300033569336,347.3201904296875,10.591598510742188,8.61981201171875],"last":[162.61700439453125,365.5672912597656,10.292999267578125,8.112701416015625],"length":46,"rects":[[88.2300033569336,347.3201904296875,370.1378860473633,8.61981201171875],[69.9800033569336,365.5672912597656,102.93000030517578,8.112701416015625]],"start":370,"text":"顺序存储结构:是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关\n系和物理关系是一致的"}],"type":5}],"originaltext":"1.顺序存储结构","page":33,"textblocks":[{"first":[87.72000122070312,325.5173034667969,3.5493011474609375,8.112701416015625],"last":[154.5670166015625,325.5173034667969,10.22540283203125,8.112701416015625],"length":8,"rects":[[87.72000122070312,325.5173034667969,77.07241821289062,8.112701416015625]],"start":361,"text":"1.顺序存储结构"}],"type":5},{"date":"2022-03-01 19:52:25","docid":0,"fillcolor":"ffffed99","id":245,"markups":[{"date":"2022-03-01 19:52:30","docid":0,"fillcolor":"ff60bb46","id":246,"originaltext":"链式存储结构:是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。","page":34,"textblocks":[{"first":[83.66999816894531,139.9361114501953,10.57550048828125,9.633895874023438],"last":[182.02999877929688,157.1761016845703,3.04229736328125,9.633895874023438],"length":48,"rects":[[83.66999816894531,139.9361114501953,370.1425018310547,9.633895874023438],[65.41000366210938,157.1761016845703,119.66229248046875,9.633895874023438]],"start":136,"text":"链式存储结构:是把数据元素存放在任意的存储单元里，这组存储单元可以是连\n续的，也可以是不连续的。"}],"type":5}],"originaltext":"2.链式存储结构","page":33,"textblocks":[{"first":[88.73999786376953,530.3601684570312,3.8029022216796875,8.61981201171875],"last":[156.00950622558594,530.3601684570312,10.309906005859375,8.61981201171875],"length":8,"rects":[[88.73999786376953,530.3601684570312,77.57941436767578,8.61981201171875]],"start":631,"text":"2.链式存储结构"}],"type":5}],"originaltext":"1.5.2物理结构","page":33,"textblocks":[{"first":[70.4800033569336,115.08908081054688,3.5493011474609375,10.140899658203125],"last":[142.98829650878906,115.08908081054688,12.676101684570312,10.140899658203125],"length":9,"rects":[[70.4800033569336,115.08908081054688,85.18439483642578,10.140899658203125]],"start":83,"text":"1.5.2物理结构"}],"type":5}],"page":31,"rect":[0,85.07000732421875,1,86.07000732421875],"title":"1.5 逻辑结构和物理结构","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":9,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-01 19:53:10","docid":0,"fillcolor":"ffffed99","id":247,"originaltext":"1.6.1数据类型","page":35,"textblocks":[{"first":[69.9800033569336,113.56912231445312,4.056396484375,10.140899658203125],"last":[142.48829650878906,113.56912231445312,12.676101684570312,10.140899658203125],"length":9,"rects":[[69.9800033569336,113.56912231445312,85.18439483642578,10.140899658203125]],"start":22,"text":"1.6.1数据类型"}],"type":5},{"date":"2022-03-01 19:53:16","docid":0,"fillcolor":"ffffed99","id":248,"originaltext":"1.6.2抽象数据类型","page":36,"textblocks":[{"first":[67.44000244140625,132.32913208007812,4.056396484375,10.140899658203125],"last":[165.72300720214844,132.32913208007812,12.760604858398438,10.140899658203125],"length":11,"rects":[[67.44000244140625,132.32913208007812,111.04360961914062,10.140899658203125]],"start":90,"text":"1.6.2抽象数据类型"}],"type":5}],"page":35,"rect":[0,25.07000732421875,1,26.07000732421875],"title":"1.6 抽象数据结构类型","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":10,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-01 16:48:23","docid":0,"id":194,"imgfile":"1a85f7284a7719fdb5196394457c675f.png","linecolor":"ffa0ec6f","linewidth":2,"page":38,"rect":[62.34118355242229,202.22871737736986,460.7165516191208,364.4171623918018],"type":2},{"date":"2022-03-01 16:48:32","docid":0,"id":195,"imgfile":"adec564c642776de3975fa41d8cbdbce.png","linecolor":"ffa0ec6f","linewidth":2,"page":38,"rect":[136.84650048092698,412.5668570054613,380.12916800257494,575.2621409105634],"type":2}],"page":38,"rect":[0,31.07000732421875,1,32.07000732421875],"title":"1.7 总结回顾","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":11,"linecolor":"ff59c6ff","page":39,"rect":[0,17.07000732421875,1,18.07000732421875],"title":"1.8 结尾语","type":8}],"page":25,"rect":[0,22.07000732421875,1,23.07000732421875],"title":"第1章 数据结构绪论","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":12,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-28 17:46:08","docid":0,"id":13,"linecolor":"ff59c6ff","page":42,"rect":[0,48.07000732421875,1,49.07000732421875],"title":"2.1 开场白","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":14,"linecolor":"ff59c6ff","page":42,"rect":[0,48.07000732421875,1,49.07000732421875],"title":"2.2 数据结构和算法关系","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":15,"linecolor":"ff59c6ff","page":43,"rect":[0,161.07000732421875,1,162.07000732421875],"title":"2.3 两种算法的比较","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":16,"linecolor":"ff59c6ff","page":44,"rect":[0,324.07000732421875,1,325.07000732421875],"title":"2.4 算法定义","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":17,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-01 19:53:41","docid":0,"fillcolor":"ff60bb46","id":249,"originaltext":"算法具有五个基本特性:输入、输出、有穷性、确定性和可行性。","page":45,"textblocks":[{"first":[52.7400016784668,159.71322631835938,10.343700408935547,9.126800537109375],"last":[336.51177978515625,159.71322631835938,9.802886962890625,9.126800537109375],"length":29,"rects":[[52.7400016784668,159.71322631835938,293.5746650695801,9.126800537109375]],"start":77,"text":"算法具有五个基本特性:输入、输出、有穷性、确定性和可行性。"}],"type":5},{"date":"2022-03-01 19:54:11","docid":0,"fillcolor":"ffffed99","id":250,"originaltext":"2.5.1输入输出","page":45,"textblocks":[{"first":[33.97999954223633,191.65908813476562,5.374698638916016,10.140899658203125],"last":[107.24549865722656,191.65908813476562,11.915496826171875,10.140899658203125],"length":9,"rects":[[33.97999954223633,191.65908813476562,85.18099594116211,10.140899658203125]],"start":107,"text":"2.5.1输入输出"}],"type":5},{"date":"2022-03-01 19:54:12","docid":0,"fillcolor":"ffffed99","id":251,"originaltext":"2.5.2有穷性","page":45,"textblocks":[{"first":[33.97999954223633,321.9691162109375,6.084598541259766,10.140899658203125],"last":[94.82220458984375,321.9691162109375,12.676101684570312,10.140899658203125],"length":8,"rects":[[33.97999954223633,321.9691162109375,73.51830673217773,10.140899658203125]],"start":291,"text":"2.5.2有穷性"}],"type":5},{"date":"2022-03-01 19:54:14","docid":0,"fillcolor":"ffffed99","id":252,"originaltext":"2.5.3确定性","page":45,"textblocks":[{"first":[33.97999954223633,452.77911376953125,6.084598541259766,10.140899658203125],"last":[94.48420715332031,452.77911376953125,12.507102966308594,10.140899658203125],"length":8,"rects":[[33.97999954223633,452.77911376953125,73.01131057739258,10.140899658203125]],"start":482,"text":"2.5.3确定性"}],"type":5},{"date":"2022-03-01 19:54:15","docid":0,"fillcolor":"ffffed99","id":253,"originaltext":"2.5.4可行性","page":45,"textblocks":[{"first":[32.959999084472656,548.109130859375,7.098598480224609,10.140869140625],"last":[94.31220245361328,548.109130859375,12.676101684570312,10.140869140625],"length":8,"rects":[[32.959999084472656,548.109130859375,74.02830505371094,10.140869140625]],"start":573,"text":"2.5.4可行性"}],"type":5}],"page":45,"rect":[0,80.07000732421875,1,81.07000732421875],"title":"2.5 算法的特征","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":18,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-01 19:54:44","docid":0,"fillcolor":"ffffed99","id":254,"originaltext":"2.6.1正确性","page":46,"textblocks":[{"first":[89.75,333.6291198730469,6.5915985107421875,10.140899658203125],"last":[151.10220336914062,333.6291198730469,12.676101684570312,10.140899658203125],"length":8,"rects":[[89.75,333.6291198730469,74.02830505371094,10.140899658203125]],"start":315,"text":"2.6.1正确性"}],"type":5},{"date":"2022-03-01 19:54:49","docid":0,"fillcolor":"ffffed99","id":255,"originaltext":"2.6.2可读性","page":47,"textblocks":[{"first":[68.95999908447266,96.32913208007812,6.084602355957031,10.140899658203125],"last":[129.3022003173828,96.32913208007812,12.676101684570312,10.140899658203125],"length":8,"rects":[[68.95999908447266,96.32913208007812,73.01830291748047,10.140899658203125]],"start":30,"text":"2.6.2可读性"}],"type":5},{"date":"2022-03-01 19:54:52","docid":0,"fillcolor":"ffffed99","id":256,"originaltext":"2.6.3健壮性","page":47,"textblocks":[{"first":[68.45999908447266,341.74212646484375,6.5915985107421875,10.64788818359375],"last":[129.3022003173828,341.74212646484375,12.676101684570312,10.64788818359375],"length":8,"rects":[[68.45999908447266,341.74212646484375,73.51830291748047,10.64788818359375]],"start":365,"text":"2.6.3健壮性"}],"type":5},{"date":"2022-03-01 19:54:54","docid":0,"fillcolor":"ffffed99","id":257,"originaltext":"2.6.4时间效率高和存储量低","page":47,"textblocks":[{"first":[69.47000122070312,456.8421325683594,6.084602355957031,10.64788818359375],"last":[219.72000122070312,456.8421325683594,12,10.64788818359375],"length":15,"rects":[[69.47000122070312,456.8421325683594,162.25,10.64788818359375]],"start":466,"text":"2.6.4时间效率高和存储量低"}],"type":5}],"page":46,"rect":[0,90.07000732421875,1,91.07000732421875],"title":"2.6 算法设计的要求","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":19,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-01 19:55:16","docid":0,"fillcolor":"ffffed99","id":258,"originaltext":"2.7.1事后统计方法","page":48,"textblocks":[{"first":[67.44000244140625,274.8091125488281,6.5915985107421875,10.140899658203125],"last":[166.3105010986328,274.8091125488281,12.676101684570312,10.140899658203125],"length":11,"rects":[[67.44000244140625,274.8091125488281,111.54660034179688,10.140899658203125]],"start":206,"text":"2.7.1事后统计方法"}],"type":5},{"date":"2022-03-01 19:55:19","docid":0,"fillcolor":"ffffed99","id":259,"originaltext":"2.7.2事前分析估算方法","page":49,"textblocks":[{"first":[68.95999908447266,62.36211013793945,5.5774993896484375,10.647899627685547],"last":[193.1265106201172,62.36211013793945,12.739501953125,10.647899627685547],"length":13,"rects":[[68.95999908447266,62.36211013793945,136.90601348876953,10.647899627685547]],"start":6,"text":"2.7.2事前分析估算方法"}],"type":5}],"page":48,"rect":[0,111.07000732421875,1,112.07000732421875],"title":"2.7 算法效率的度量方法","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":20,"linecolor":"ff59c6ff","page":51,"rect":[0,321.07000732421875,1,322.07000732421875],"title":"2.8 函数的渐进增长","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":21,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-01 19:55:53","docid":0,"fillcolor":"ffffed99","id":260,"originaltext":"2.9.1算法时间复杂度定义","page":53,"textblocks":[{"first":[77.58000183105469,565.34912109375,6.5915985107421875,10.140869140625],"last":[214.5383758544922,565.34912109375,12.619796752929688,10.140869140625],"length":14,"rects":[[77.58000183105469,565.34912109375,149.5781707763672,10.140869140625]],"start":797,"text":"2.9.1算法时间复杂度定义"}],"type":5},{"date":"2022-03-01 19:55:55","docid":0,"fillcolor":"ffffed99","id":261,"markups":[{"date":"2022-03-01 19:56:41","docid":0,"fillcolor":"ff60bb46","id":267,"originaltext":"推导大O阶:\n1.用常鼓1取代运行时闺中的所有加法常颤。\n2.在修改后的运行次搬画锺中，只保留最高阶项。\n3.如果最高阶项存在且不是1，则去除与这个项相乘的常敢。得到的结果就是大O阶。","page":54,"textblocks":[{"first":[101.41000366210938,313.8501892089844,10.140899658203125,8.61981201171875],"last":[210.42999267578125,388.8973083496094,4.056396484375,8.112701416015625],"length":93,"rects":[[101.41000366210938,313.8501892089844,59.32820129394531,8.61981201171875],[102.43000030517578,332.6173095703125,203.3233871459961,8.112701416015625],[101.41000366210938,350.8702087402344,224.62640380859375,8.61981201171875],[101.91999816894531,370.14019775390625,275.32640075683594,8.61981201171875],[101.41000366210938,388.8973083496094,113.07638549804688,8.112701416015625]],"start":386,"text":"推导大O阶:\n1.用常鼓1取代运行时闺中的所有加法常颤。\n2.在修改后的运行次搬画锺中，只保留最高阶项。\n3.如果最高阶项存在且不是1，则去除与这个项相乘的常敢。\n得到的结果就是大O阶。"}],"type":5}],"originaltext":"2.9.2推导大O阶方法","page":54,"textblocks":[{"first":[60.34000015258789,247.42910766601562,5.746501922607422,10.140899658203125],"last":[175.43820190429688,247.42910766601562,12.169097900390625,10.140899658203125],"length":12,"rects":[[60.34000015258789,247.42910766601562,127.26729965209961,10.140899658203125]],"start":311,"text":"2.9.2推导大O阶方法"}],"type":5},{"date":"2022-03-01 19:55:59","docid":0,"fillcolor":"ffffed99","id":262,"originaltext":"2.9.3常数阶","page":54,"textblocks":[{"first":[60.849998474121094,479.6590881347656,6.5915985107421875,10.140899658203125],"last":[121.52619934082031,479.6590881347656,12.338104248046875,10.140899658203125],"length":8,"rects":[[60.849998474121094,479.6590881347656,73.0143051147461,10.140899658203125]],"start":561,"text":"2.9.3常数阶"}],"type":5},{"date":"2022-03-01 19:56:06","docid":0,"fillcolor":"ffffed99","id":264,"originaltext":"2.9.4线性阶","page":55,"textblocks":[{"first":[73.0199966430664,478.6391296386719,6.5915985107421875,10.140899658203125],"last":[133.52420043945312,478.6391296386719,12.507095336914062,10.140899658203125],"length":8,"rects":[[73.0199966430664,478.6391296386719,73.01129913330078,10.140899658203125]],"start":613,"text":"2.9.4线性阶"}],"type":5},{"date":"2022-03-01 19:56:09","docid":0,"fillcolor":"ffffed99","id":265,"originaltext":"2.9.5对数阶","page":56,"textblocks":[{"first":[64.39889526367188,126.25007629394531,5.746498107910156,9.633895874023438],"last":[124.90310668945312,126.25007629394531,12.507095336914062,9.633895874023438],"length":8,"rects":[[64.39889526367188,126.25007629394531,73.01130676269531,9.633895874023438]],"start":25,"text":"2.9.5对数阶"}],"type":5},{"date":"2022-03-01 19:56:12","docid":0,"fillcolor":"ffffed99","id":266,"originaltext":"2.9.6平方阶","page":56,"textblocks":[{"first":[64.90889739990234,338.1930847167969,5.746498107910156,10.140899658203125],"last":[125.41310119628906,338.1930847167969,12.507095336914062,10.140899658203125],"length":8,"rects":[[64.90889739990234,338.1930847167969,73.01129913330078,10.140899658203125]],"start":224,"text":"2.9.6平方阶"}],"type":5}],"page":53,"rect":[0,393.07000732421875,1,394.07000732421875],"title":"2.9 算法时间的复杂度","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":22,"linecolor":"ff59c6ff","page":59,"rect":[0,100.07000732421875,1,101.07000732421875],"title":"2.10 常见的时间复杂度","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":23,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-01 19:41:31","docid":0,"fillcolor":"ff60bb46","id":210,"originaltext":"通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。","page":60,"textblocks":[{"first":[164.2899932861328,219.033203125,10.394393920898438,9.126800537109375],"last":[91.2699966430664,236.2801971435547,3.04229736328125,8.619796752929688],"length":32,"rects":[[164.2899932861328,219.033203125,294.07789611816406,9.126800537109375],[69.9800033569336,236.2801971435547,24.332290649414062,8.619796752929688]],"start":292,"text":"通常，除非特别指定，我们提到的运行时间都是最坏情况的运行\n时间。"}],"type":5}],"page":59,"rect":[0,406.07000732421875,1,407.07000732421875],"title":"2.11 最坏情况和平均情况","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":24,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 19:41:34","docid":0,"fillcolor":"ffffed99","id":270,"originaltext":"我们在写代码时，完全可以用空间来换取时间，","page":60,"textblocks":[{"first":[89.23999786376953,471.0401916503906,10.237503051757812,8.61981201171875],"last":[293.989990234375,471.0401916503906,10.23748779296875,8.61981201171875],"length":21,"rects":[[89.23999786376953,471.0401916503906,214.98748016357422,8.61981201171875]],"start":614,"text":"我们在写代码时，完全可以用空间来换取时间，"}],"type":5}],"page":60,"rect":[0,340.07000732421875,1,341.07000732421875],"title":"2.12 算法空间复杂度","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":25,"linecolor":"ff59c6ff","page":61,"rect":[0,248.07000732421875,1,249.07000732421875],"title":"2.13 总结回顾","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":26,"linecolor":"ff59c6ff","page":62,"rect":[0,310.07000732421875,1,311.07000732421875],"title":"2.14 结尾语","type":8}],"page":41,"rect":[0,63.07000732421875,1,64.07000732421875],"title":"第2章 算法","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":27,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-28 17:46:08","docid":0,"id":28,"linecolor":"ff59c6ff","page":66,"rect":[0,21.07000732421875,1,22.07000732421875],"title":"3.1 开场白","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":29,"linecolor":"ff59c6ff","page":66,"rect":[0,403.07000732421875,1,404.07000732421875],"title":"3.2 线性表的定义","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":30,"linecolor":"ff59c6ff","page":69,"rect":[-1.5211000442504883,2.083984375,-0.5211000442504883,3.083984375],"title":"3.3 线性表的抽象数据类型","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":31,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 15:17:07","docid":0,"fillcolor":"ffffed99","id":272,"markups":[{"date":"2022-03-05 15:17:16","docid":0,"fillcolor":"ffa0ec6e","id":273,"originaltext":"雄性亵的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性褒的触据元素。","page":71,"textblocks":[{"first":[111.05000305175781,178.47023010253906,10.847099304199219,8.619796752929688],"last":[216.50999450683594,194.18728637695312,4.056396484375,8.112701416015625],"length":40,"rects":[[111.05000305175781,178.47023010253906,303.71897888183594,8.619796752929688],[110.54000091552734,194.18728637695312,110.0263900756836,8.112701416015625]],"start":72,"text":"雄性亵的顺序存储结构，指的是用一段地址连续的存储单元依次\n存储线性褒的触据元素。"}],"type":5}],"originaltext":"3.4.1顺序存储定义","page":71,"textblocks":[{"first":[69.9800033569336,112.04910278320312,6.5915985107421875,10.140899658203125],"last":[168.3404998779297,112.04910278320312,12.676101684570312,10.140899658203125],"length":11,"rects":[[69.9800033569336,112.04910278320312,111.0365982055664,10.140899658203125]],"start":21,"text":"3.4.1顺序存储定义"}],"type":5},{"date":"2022-03-05 15:17:20","docid":0,"fillcolor":"ffffed99","id":274,"originaltext":"3.4.2 J顺序存储方式","page":71,"textblocks":[{"first":[72.3499984741211,579.5421142578125,6.599998474121094,10.64788818359375],"last":[171.72052001953125,579.5421142578125,12.338104248046875,10.64788818359375],"length":13,"rects":[[72.3499984741211,579.5421142578125,111.70862579345703,10.64788818359375]],"start":421,"text":"3.4.2 J顺序存储方式"}],"type":5},{"date":"2022-03-05 15:17:28","docid":0,"fillcolor":"ffffed99","id":275,"originaltext":"3.4.3数据长度与线性表长度区别","page":72,"textblocks":[{"first":[67.44000244140625,590.7020874023438,6.5915985107421875,10.64788818359375],"last":[242.3671112060547,590.7020874023438,12.676101684570312,10.64788818359375],"length":17,"rects":[[67.44000244140625,590.7020874023438,187.60321044921875,10.64788818359375]],"start":872,"text":"3.4.3数据长度与线性表长度区别"}],"type":5},{"date":"2022-03-05 15:17:32","docid":0,"fillcolor":"ffffed99","id":276,"originaltext":"3.4.4地址计算方法","page":73,"textblocks":[{"first":[68.95999908447266,211.93499755859375,5.476097106933594,11.154998779296875],"last":[167.33050537109375,211.93499755859375,12.676101684570312,11.154998779296875],"length":11,"rects":[[68.95999908447266,211.93499755859375,111.0466079711914,11.154998779296875]],"start":212,"text":"3.4.4地址计算方法"}],"type":5}],"page":71,"rect":[0,23.07000732421875,1,24.07000732421875],"title":"3.4 线性表的顺序存储结构","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":32,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 15:17:42","docid":0,"fillcolor":"ffffed99","id":277,"originaltext":"3.5.1获得元素操作","page":74,"textblocks":[{"first":[67.44000244140625,419.8291015625,5.171897888183594,10.140899658203125],"last":[166.3105010986328,419.8291015625,12.676101684570312,10.140899658203125],"length":11,"rects":[[67.44000244140625,419.8291015625,111.54660034179688,10.140899658203125]],"start":299,"text":"3.5.1获得元素操作"}],"type":5},{"date":"2022-03-05 15:17:46","docid":0,"fillcolor":"ffffed99","id":278,"originaltext":"3.5.2插入操作","page":75,"textblocks":[{"first":[71.5,228.15911865234375,6.084602355957031,10.140899658203125],"last":[144.50830078125,228.15911865234375,12.676101684570312,10.140899658203125],"length":9,"rects":[[71.5,228.15911865234375,85.68440246582031,10.140899658203125]],"start":183,"text":"3.5.2插入操作"}],"type":5},{"date":"2022-03-05 15:17:51","docid":0,"fillcolor":"ffffed99","id":279,"markups":[{"date":"2022-03-05 15:18:06","docid":0,"fillcolor":"ffa0ec6e","id":281,"originaltext":"现在我们来分析一下，插入和删除的时间复杂度。","page":78,"textblocks":[{"first":[81.63999938964844,240.84022521972656,10.2677001953125,8.619796752929688],"last":[293.7860412597656,240.84022521972656,8.92401123046875,8.619796752929688],"length":22,"rects":[[81.63999938964844,240.84022521972656,221.07005310058594,8.619796752929688]],"start":218,"text":"现在我们来分析一下，插入和删除的时间复杂度。"}],"type":5}],"originaltext":"3.5.3删除操作","page":76,"textblocks":[{"first":[64.91000366210938,568.38916015625,6.5915985107421875,10.140869140625],"last":[138.4282989501953,568.38916015625,12.676101684570312,10.140869140625],"length":9,"rects":[[64.91000366210938,568.38916015625,86.19439697265625,10.140869140625]],"start":609,"text":"3.5.3删除操作"}],"type":5},{"date":"2022-03-05 15:18:02","docid":0,"fillcolor":"ffffed99","id":280,"markups":[{"date":"2022-03-05 15:18:39","docid":0,"id":282,"imgfile":"a60da0690041d576cc4723d320aba99c.png","linecolor":"ffa0ec6e","linewidth":2,"page":79,"rect":[107.57545484607492,51.13452113759615,412.4529771004218,230.10534511918266],"type":2}],"originaltext":"3.5.4线性表I1随序存储结构的优缺点线性表的顺序存储结构的优缺点如图3-5-3","page":78,"textblocks":[{"first":[64.91000366210938,563.8220825195312,6.084602355957031,10.64788818359375],"last":[270.25677490234375,591.210205078125,4.563385009765625,8.61981201171875],"length":42,"rects":[[64.91000366210938,563.8220825195312,200.78900146484375,10.64788818359375],[83.16000366210938,591.210205078125,191.66015625,8.61981201171875]],"start":718,"text":"3.5.4线性表I1随序存储结构的优缺点\n线性表的顺序存储结构的优缺点如图3-5-3"}],"type":5}],"page":74,"rect":[0,334.07000732421875,1,335.07000732421875],"title":"3.5 顺序存储结构的插入与删除","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":33,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 15:20:25","docid":0,"fillcolor":"ffffed99","id":285,"originaltext":"3.6.1顺序存储结构不足的解决办法","page":79,"textblocks":[{"first":[69.9800033569336,319.93609619140625,5.171897888183594,9.6339111328125],"last":[258.0092468261719,319.93609619140625,12.75408935546875,9.6339111328125],"length":18,"rects":[[69.9800033569336,319.93609619140625,200.78333282470703,9.6339111328125]],"start":170,"text":"3.6.1顺序存储结构不足的解决办法"}],"type":5},{"date":"2022-03-05 15:22:52","docid":0,"fillcolor":"ffffed99","id":286,"originaltext":"3.6.2线性表链式存储结构定义","page":80,"textblocks":[{"first":[65.91999816894531,243.87911987304688,6.5915985107421875,10.140899658203125],"last":[227.7100372314453,243.87911987304688,12.6300048828125,10.140899658203125],"length":16,"rects":[[65.91999816894531,243.87911987304688,174.4200439453125,10.140899658203125]],"start":275,"text":"3.6.2线性表链式存储结构定义"}],"type":5},{"date":"2022-03-05 15:27:47","docid":0,"fillcolor":"ffffed99","id":287,"markups":[{"date":"2022-03-05 15:30:42","docid":0,"id":290,"imgfile":"9de5c104b87ecc0e957cb726b6a87f2e.png","linecolor":"ffa0ec6f","linewidth":2,"page":82,"rect":[117.70587884503264,287.99348225608395,400.8753496730415,467.9291085232855],"type":2}],"originaltext":"3.6.3头指针与头结点的异同","page":82,"textblocks":[{"first":[66.43000030517578,240.8421173095703,6.5915985107421875,10.647903442382812],"last":[216.00491333007812,240.8421173095703,12.676101684570312,10.647903442382812],"length":15,"rects":[[66.43000030517578,240.8421173095703,162.25101470947266,10.647903442382812]],"start":120,"text":"3.6.3头指针与头结点的异同"}],"type":5},{"date":"2022-03-05 15:27:49","docid":0,"fillcolor":"ffffed99","id":288,"markups":[{"date":"2022-03-05 15:34:03","docid":0,"id":292,"imgfile":"3056e705d2979898b99c6d3e2a6578ed.png","linecolor":"ffa0ec6f","linewidth":2,"page":83,"rect":[68.98336342147405,433.67862738395223,358.42404910598054,538.8420765159896],"type":2}],"originaltext":"3.6.4线性表链式存储结构代码描述","page":82,"textblocks":[{"first":[68.45999908447266,484.22210693359375,6.084602355957031,10.64788818359375],"last":[257.077392578125,484.22210693359375,12.169097900390625,10.64788818359375],"length":18,"rects":[[68.45999908447266,484.22210693359375,200.78649139404297,10.64788818359375]],"start":391,"text":"3.6.4线性表链式存储结构代码描述"}],"type":5}],"page":79,"rect":[0,259.07000732421875,1,260.07000732421875],"title":"3.6 线性表的链式存储结构","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":34,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 15:37:22","docid":0,"fillcolor":"ffffed99","id":297,"markups":[{"date":"2022-03-05 15:37:13","docid":0,"fillcolor":"ff60bb46","id":293,"originaltext":"1.声明一个结点p指向链表第一个结点，初始化j从1开始;","page":84,"textblocks":[{"first":[84.16999816894531,348.8402099609375,4.056396484375,8.61981201171875],"last":[353.4154052734375,348.8402099609375,8.112701416015625,8.61981201171875],"length":28,"rects":[[84.16999816894531,348.8402099609375,277.3581085205078,8.61981201171875]],"start":181,"text":"1.声明一个结点p指向链表第一个结点，初始化j从1开始;"}],"type":5},{"date":"2022-03-05 15:37:15","docid":0,"fillcolor":"ff60bb46","id":294,"originaltext":"2.当j<i时，就遍历链裴，让p的指针向后移动，不断指向下一结点，j累加1;","page":84,"textblocks":[{"first":[84.16999816894531,370.64019775390625,4.309898376464844,8.61981201171875],"last":[440.8799133300781,370.64019775390625,4.309906005859375,8.61981201171875],"length":38,"rects":[[84.16999816894531,370.64019775390625,361.0198211669922,8.61981201171875]],"start":210,"text":"2.当j<i时，就遍历链裴，让p的指针向后移动，不断指向下一结点，j累加1;"}],"type":5},{"date":"2022-03-05 15:37:17","docid":0,"fillcolor":"ff60bb46","id":295,"originaltext":"3.若到链表末尾p为空，则说明第i个元素不存在;","page":84,"textblocks":[{"first":[84.16999816894531,392.4501953125,4.309898376464844,8.61981201171875],"last":[310.0945129394531,392.4501953125,9.344085693359375,8.61981201171875],"length":24,"rects":[[84.16999816894531,392.4501953125,235.2686004638672,8.61981201171875]],"start":249,"text":"3.若到链表末尾p为空，则说明第i个元素不存在;"}],"type":5},{"date":"2022-03-05 15:37:19","docid":0,"fillcolor":"ff60bb46","id":296,"originaltext":"4.否则查找成功，返回结点p的数据。","page":84,"textblocks":[{"first":[84.16999816894531,414.2431945800781,5.070503234863281,9.126800537109375],"last":[257.0799865722656,414.2431945800781,3.04229736328125,9.126800537109375],"length":18,"rects":[[84.16999816894531,414.2431945800781,175.95228576660156,9.126800537109375]],"start":274,"text":"4.否则查找成功，返回结点p的数据。"}],"type":5}],"originaltext":"获得链裴第i个数据的算法思路:","page":84,"textblocks":[{"first":[83.16000366210938,327.0401916503906,10.242301940917969,8.61981201171875],"last":[219.6695556640625,327.0401916503906,9.521194458007812,8.61981201171875],"length":15,"rects":[[83.16000366210938,327.0401916503906,146.03074645996094,8.61981201171875]],"start":165,"text":"获得链裴第i个数据的算法思路:"}],"type":5}],"page":84,"rect":[0,181.07000732421875,1,182.07000732421875],"title":"3.7 单链表的读取","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":35,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 15:40:13","docid":0,"fillcolor":"ffffed99","id":298,"markups":[{"date":"2022-03-05 15:40:18","docid":0,"fillcolor":"ff60bb46","id":299,"markups":[{"date":"2022-03-05 15:40:25","docid":0,"id":300,"imgfile":"89d1da42a41d04f089ff73380fe83936.png","linecolor":"ff60bb46","linewidth":2,"page":85,"rect":[182.3476319812391,490.60196223523855,364.2128628196707,592.3886033676233],"type":2}],"originaltext":"根本用不着惊动其他结点，只需要让s->next和p->next的指针做一点改变即可。","page":85,"textblocks":[{"first":[93.80999755859375,615.543212890625,10.362701416015625,9.12677001953125],"last":[446.5390319824219,615.543212890625,9.295806884765625,9.12677001953125],"length":42,"rects":[[93.80999755859375,615.543212890625,362.02484130859375,9.12677001953125]],"start":521,"text":"根本用不着惊动其他结点，只需要让s->next和p->next的指针做一点改变即可。"}],"type":5}],"originaltext":"3.8.1单链袤的插入","page":85,"textblocks":[{"first":[74.54000091552734,412.72210693359375,5.746498107910156,10.64788818359375],"last":[173.41050720214844,412.72210693359375,12.676101684570312,10.64788818359375],"length":11,"rects":[[74.54000091552734,412.72210693359375,111.5466079711914,10.64788818359375]],"start":400,"text":"3.8.1单链袤的插入"}],"type":5},{"date":"2022-03-05 15:41:13","docid":0,"fillcolor":"ffffed99","id":301,"originaltext":"3.8.2单链表的删除","page":88,"textblocks":[{"first":[62.880001068115234,97.34909057617188,5.577503204345703,10.140899658203125],"last":[161.36790466308594,97.34909057617188,12.549301147460938,10.140899658203125],"length":11,"rects":[[62.880001068115234,97.34909057617188,111.03720474243164,10.140899658203125]],"start":19,"text":"3.8.2单链表的删除"}],"type":5}],"page":85,"rect":[0,344.07000732421875,1,345.07000732421875],"title":"3.8 单链表的插入与删除","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":36,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 16:08:19","docid":0,"fillcolor":"ffffed99","id":305,"markups":[{"date":"2022-03-05 16:08:23","docid":0,"fillcolor":"ff60bb46","id":306,"markups":[{"date":"2022-03-05 16:08:00","docid":0,"fillcolor":"ff60bb46","id":304,"markups":[{"date":"2022-03-05 16:11:13","docid":0,"id":307,"imgfile":"97ea84f9185aba1ff5d1c3b510a69151.png","linecolor":"ffa0ec6f","linewidth":2,"page":91,"rect":[137.86017826226717,324.88372891953406,402.43007919205934,426.7583459442241],"type":2}],"originaltext":"这段算法代码里，我们其实用的是插队的办法，就是始终让新结点在第一的位置。我也可以把这种算法简称为头插法","page":91,"textblocks":[{"first":[84.16999816894531,289.01019287109375,10.871597290039062,8.61981201171875],"last":[230.5044403076172,306.247314453125,10.318405151367188,8.112701416015625],"length":52,"rects":[[84.16999816894531,289.01019287109375,369.6345977783203,8.61981201171875],[65.41000366210938,306.247314453125,175.412841796875,8.112701416015625]],"start":325,"text":"这段算法代码里，我们其实用的是插队的办法，就是始终让新结点在第一的位\n置。我也可以把这种算法简称为头插法"}],"type":5}],"originaltext":"1.声明一结点p和计数器变量i;\n2.初始化一空链表L;\n3.让L的头结点的指针指向NULL，即建立一个带头结点的单链表i\n4.循环:\n\t• 生成一新结点赋值给p;\n\t• 随机生成一数字赋值给p的数据域p->data;\n\t• 将p插入到头结点与前一新结点之间。","page":90,"textblocks":[{"first":[86.70999908447266,428.9501953125,8.746498107910156,8.61981201171875],"last":[292.6730041503906,559.2591552734375,10.03948974609375,10.140869140625],"length":127,"rects":[[86.70999908447266,428.9501953125,149.06529998779297,8.61981201171875],[86.70999908447266,451.2572937011719,99.88680267333984,8.112701416015625],[86.70999908447266,471.543212890625,306.2481918334961,9.126800537109375],[86.70999908447266,495.3742980957031,39.55120086669922,7.605712890625],[109.37000274658203,516.6660766601562,126.4098129272461,9.6339111328125],[109.87000274658203,537.9632568359375,217.17708587646484,9.12677001953125],[109.87999725341797,559.2591552734375,192.8324966430664,10.140869140625]],"start":574,"text":"1.声明一结点p和计数器变量i;\n2.初始化一空链表L;\n3.让L的头结点的指针指向NULL，即建立一个带头结点的单链表i\n4.循环:\n• 生成一新结点赋值给p;\n• 随机生成一数字赋值给p的数据域p->data;\n• 将p插入到头结点与前一新结点之间。"}],"type":5}],"originaltext":"单链衰整表创建的算法思路:","page":90,"textblocks":[{"first":[85.69999694824219,407.15020751953125,10.352203369140625,8.61981201171875],"last":[211.44000244140625,407.15020751953125,2.0281982421875,8.61981201171875],"length":13,"rects":[[85.69999694824219,407.15020751953125,127.76820373535156,8.61981201171875]],"start":560,"text":"单链衰整表创建的算法思路:"}],"type":5}],"page":90,"rect":[0,241.07000732421875,1,242.07000732421875],"title":"3.9 单链表的整表创建","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":37,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 16:20:36","docid":0,"fillcolor":"ffffed99","id":309,"markups":[{"date":"2022-03-05 16:20:37","docid":0,"fillcolor":"ff60bb46","id":310,"markups":[{"date":"2022-03-05 16:21:30","docid":0,"fillcolor":"ffffed99","id":311,"markups":[{"date":"2022-03-05 16:22:19","docid":0,"fillcolor":"ffffed99","id":314,"originaltext":"官使得下一个结点是谁得到了记录，以便于等当前结点释放后，把下一结点拿回来补充。","page":94,"textblocks":[{"first":[165.17678833007812,135.88320922851562,10.10919189453125,9.126800537109375],"last":[167.4453125,152.6101837158203,9.867904663085938,8.619796752929688],"length":40,"rects":[[165.17678833007812,135.88320922851562,283.057373046875,9.126800537109375],[67.44000244140625,152.6101837158203,109.87321472167969,8.619796752929688]],"start":168,"text":"官使得下一个结点是谁得到了记录，以便于等当前结点释放后，\n把下一结点拿回来补充。"}],"type":5}],"originaltext":"常见的错误就是有同学会觉得q变量没有存在的必要。在循环体内直接写free( p) ;p=p->next;li!p可。可这样会带来什么问题?","page":93,"textblocks":[{"first":[169.892822265625,570.9232177734375,10.3341064453125,9.12677001953125],"last":[346.5928955078125,588.6702270507812,9.864288330078125,8.61981201171875],"length":70,"rects":[[169.892822265625,570.9232177734375,286.95391845703125,9.12677001953125],[68.95999908447266,588.6702270507812,287.49718475341797,8.61981201171875]],"start":401,"text":"常见的错误就是有同学会觉得q变量没有存在的必要。在循环\n体内直接写free( p) ;p=p->next;li!p可。可这样会带来什么问题?"}],"type":5}],"originaltext":"1.声明一结点p和q;\n2.将第一个结点赋值给p;\n3.循环:\n\t• 将下一结点赋值给q;\n\t• 释放p;\n\t• 将q赋值给p。","page":93,"textblocks":[{"first":[87.22000122070312,210.9232177734375,4.056396484375,9.126800537109375],"last":[191.16000366210938,307.2621154785156,3.04229736328125,10.64788818359375],"length":61,"rects":[[87.22000122070312,210.9232177734375,99.88819885253906,9.126800537109375],[86.70999908447266,233.23020935058594,120.67679595947266,8.619796752929688],[86.70999908447266,255.54730224609375,39.551109313964844,8.112701416015625],[109.37000274658203,275.82611083984375,115.24980926513672,9.6339111328125],[109.37000274658203,291.5450134277344,53.39679718017578,11.154998779296875],[109.37000274658203,307.2621154785156,84.8322982788086,10.64788818359375]],"start":115,"text":"1.声明一结点p和q;\n2.将第一个结点赋值给p;\n3.循环:\n• 将下一结点赋值给q;\n• 释放p;\n• 将q赋值给p。"}],"type":5}],"originaltext":"单链表整表删除的算法思路如下:","page":93,"textblocks":[{"first":[86.19999694824219,189.1201934814453,9.870498657226562,8.619796752929688],"last":[224.38697814941406,189.1201934814453,9.870498657226562,8.619796752929688],"length":15,"rects":[[86.19999694824219,189.1201934814453,148.05747985839844,8.619796752929688]],"start":99,"text":"单链表整表删除的算法思路如下:"}],"type":5}],"page":93,"rect":[0,100.07000732421875,1,101.07000732421875],"title":"3.10 单链表的整表删除","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":38,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 16:22:42","docid":0,"id":315,"imgfile":"51ce604575e93df7f436358059836fe5.png","linecolor":"ffa0ec6f","linewidth":2,"page":94,"rect":[49.99999850988392,248.99999257922195,465.4999861270193,474.4999858587984],"type":2},{"date":"2022-03-05 16:23:33","docid":0,"fillcolor":"ffffed99","id":316,"markups":[{"date":"2022-03-05 16:23:38","docid":0,"fillcolor":"ff60bb46","id":317,"originaltext":"若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链裴结构。","page":94,"textblocks":[{"first":[111.05000305175781,503.99609375,10.790496826171875,9.6339111328125],"last":[344.33050537109375,521.2332153320312,10.491912841796875,9.12677001953125],"length":56,"rects":[[111.05000305175781,503.99609375,345.29591369628906,9.6339111328125],[111.55000305175781,521.2332153320312,243.2724151611328,9.12677001953125]],"start":561,"text":"若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结\n构。若需要频繁插入和删除时，宜采用单链裴结构。"}],"type":5}],"originaltext":"我们可以得出一些经验性的结论:","page":94,"textblocks":[{"first":[167.288818359375,482.1932067871094,10.00860595703125,9.126800537109375],"last":[307.4093017578125,482.1932067871094,10.00860595703125,9.126800537109375],"length":15,"rects":[[167.288818359375,482.1932067871094,150.12908935546875,9.126800537109375]],"start":470,"text":"我们可以得出一些经验性的结论:"}],"type":5}],"page":94,"rect":[0,184.07000732421875,1,185.07000732421875],"title":"3.11 单链表结构与顺序存储结构优缺点","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":39,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 16:38:27","docid":0,"fillcolor":"ff60bb46","id":318,"markups":[{"date":"2022-03-05 16:40:11","docid":0,"fillcolor":"ff60bb46","id":319,"originaltext":"另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为0的元素的cur就存放备用链袤的第一个结点的下标i而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为02","page":96,"textblocks":[{"first":[85.19000244140625,99.88020324707031,10.394401550292969,8.619796752929688],"last":[428.9599914550781,151.09323120117188,3.04229736328125,9.126800537109375],"length":150,"rects":[[85.19000244140625,99.88020324707031,368.62176513671875,8.619796752929688],[65.91999816894531,117.12019348144531,387.8880157470703,8.619796752929688],[65.91999816894531,134.3601837158203,387.3805694580078,8.619796752929688],[65.91999816894531,151.09323120117188,366.08229064941406,9.126800537109375]],"start":73,"text":"另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常\n把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为0的元素的cur\n就存放备用链袤的第一个结点的下标i而数组的最后一个元素的cur则存放第一个有\n数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为02"}],"type":5}],"originaltext":"数据域也ta，用来存放数据元素，也就是通常我们要处理的数据;而游标cur相当于单链表中的next指针，存放该元素的后继在数组中的下标。","page":95,"textblocks":[{"first":[238.30999755859375,426.4132080078125,10.394393920898438,9.126800537109375],"last":[105.67599487304688,462.4173278808594,8.923995971679688,8.112701416015625],"length":69,"rects":[[238.30999755859375,426.4132080078125,218.5384521484375,9.126800537109375],[69.47000122070312,443.6531982421875,387.37786865234375,9.126800537109375],[69.9800033569336,462.4173278808594,44.61998748779297,8.112701416015625]],"start":525,"text":"数据域也ta，用来存放数据元素，也就是通常我\n们要处理的数据;而游标cur相当于单链表中的next指针，存放该元素的后继在数组\n中的下标。"}],"type":5},{"date":"2022-03-05 16:40:36","docid":0,"fillcolor":"ffffed99","id":321,"originaltext":"3.12.1静态链表的插入操作","page":97,"textblocks":[{"first":[69.47000122070312,268.2191162109375,6.5915985107421875,10.140899658203125],"last":[213.46881103515625,268.2191162109375,12.676101684570312,10.140899658203125],"length":15,"rects":[[69.47000122070312,268.2191162109375,156.67491149902344,10.140899658203125]],"start":155,"text":"3.12.1静态链表的插入操作"}],"type":5},{"date":"2022-03-05 16:41:48","docid":0,"fillcolor":"ffffed99","id":322,"originaltext":"3.12.2静态链袤的删除操作","page":99,"textblocks":[{"first":[65.91999816894531,460.3891296386719,6.084602355957031,10.140899658203125],"last":[209.85923767089844,460.3891296386719,12.732406616210938,10.140899658203125],"length":15,"rects":[[65.91999816894531,460.3891296386719,156.67164611816406,10.140899658203125]],"start":468,"text":"3.12.2静态链袤的删除操作"}],"type":5},{"date":"2022-03-05 16:42:21","docid":0,"fillcolor":"ffffed99","id":324,"markups":[{"date":"2022-03-05 16:42:15","docid":0,"id":323,"imgfile":"a7b9c85a8aefaac34ff51c88566fb4e3.png","linecolor":"ff60bb46","linewidth":2,"page":101,"rect":[72.99999782443054,330.49999015033274,412.9999876916412,504.4999849647288],"type":2}],"originaltext":"3.12.3静态链表优缺点","page":101,"textblocks":[{"first":[66.43000030517578,306.75909423828125,5.746498107910156,10.140899658203125],"last":[185.0010223388672,306.75909423828125,12.748504638671875,10.140899658203125],"length":13,"rects":[[66.43000030517578,306.75909423828125,131.31952667236328,10.140899658203125]],"start":201,"text":"3.12.3静态链表优缺点"}],"type":5}],"page":95,"rect":[0,190.07000732421875,1,191.07000732421875],"title":"3.12 静态链表","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":40,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 17:37:16","docid":0,"fillcolor":"ff60bb46","id":325,"originaltext":"这种头尾:相接的单链表称为单循环链表，简称循环链表(circularlinked list)。","page":103,"textblocks":[{"first":[105.5403060913086,216.50320434570312,11.010101318359375,9.126800537109375],"last":[93.30000305175781,234.2443084716797,3.04229736328125,7.6056976318359375],"length":48,"rects":[[105.5403060913086,216.50320434570312,357.74051666259766,9.126800537109375],[72.51000213623047,234.2443084716797,23.832298278808594,7.6056976318359375]],"start":267,"text":"这种头尾:相接的单链表称为单循环链表，简称循环链表(circularlinked \nlist)。"}],"type":5},{"date":"2022-03-05 17:40:43","docid":0,"fillcolor":"ff60bb46","id":326,"markups":[{"date":"2022-03-05 17:40:57","docid":0,"fillcolor":"ff60bb46","id":329,"markups":[{"date":"2022-03-05 17:40:59","docid":0,"fillcolor":"ff60bb46","id":330,"markups":[{"date":"2022-03-06 15:56:47","docid":0,"id":372,"linecolor":"ffd01a11","linewidth":7,"originaltext":"循环链表的头结点的数据域放的是头指针的地址","page":104,"rect":[251.33099540271314,37.627289138985816,392.7097279596988,65.64175313620642],"type":11}],"originaltext":"针来表示循环链表(如图3.13.5所示)，此时查找开始结点和终端结点都很方便了。","page":104,"textblocks":[{"first":[62.880001068115234,66.41909790039062,10.27920150756836,10.140899658203125],"last":[434.5400085449219,66.41909790039062,3.549285888671875,10.140899658203125],"length":40,"rects":[[62.880001068115234,66.41909790039062,375.2092933654785,10.140899658203125]],"start":5,"text":"针来表示循环链表(如图3.13.5所示)，此时查找开始结点和终端结点都很方便了。"}],"type":5}],"originaltext":"不过我们需要改造一下这个循环链粟，不用头指针，而是用指向终端结点的尾指","page":103,"textblocks":[{"first":[93.30000305175781,613.5132446289062,10.521202087402344,9.12677001953125],"last":[451.77789306640625,613.5132446289062,10.64788818359375,9.12677001953125],"length":35,"rects":[[93.30000305175781,613.5132446289062,369.1257781982422,9.12677001953125]],"start":672,"text":"不过我们需要改造一下这个循环链粟，不用头指针，而是用指向终端结点的尾指"}],"type":5}],"originaltext":"有没有可能用0(1)的时间由链表指针访问到最后一个结点呢?当然可以。","page":103,"textblocks":[{"first":[92.79000091552734,592.22021484375,10.22540283203125,8.61981201171875],"last":[409.2919921875,592.22021484375,10.035308837890625,8.61981201171875],"length":34,"rects":[[92.79000091552734,592.22021484375,326.5373001098633,8.61981201171875]],"start":637,"text":"有没有可能用0(1)的时间由链表指针访问到最后一个结点呢?当然可以。"}],"type":5}],"page":102,"rect":[0,45.07000732421875,1,46.07000732421875],"title":"3.13 循环链表","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":41,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 17:44:05","docid":0,"fillcolor":"ff60bb46","id":332,"originaltext":"双向链表(也ublelinked List)是在单链袤的每个结点中，再设置一个指向其前驱结点的指针域","page":105,"textblocks":[{"first":[412.8904113769531,541.0132446289062,10.824310302734375,9.12677001953125],"last":[68.95999908447266,574.9832153320312,10.647895812988281,9.12677001953125],"length":52,"rects":[[412.8904113769531,541.0132446289062,43.955352783203125,9.12677001953125],[69.47000122070312,557.7432250976562,387.3778991699219,9.12677001953125],[68.95999908447266,574.9832153320312,10.647895812988281,9.12677001953125]],"start":610,"text":"双向链表\n(也ublelinked List)是在单链袤的每个结点中，再设置一个指向其前驱结点的指针\n域"}],"type":5},{"date":"2022-03-05 17:46:14","docid":0,"fillcolor":"ffffed99","id":333,"markups":[{"date":"2022-03-05 17:46:31","docid":0,"id":334,"imgfile":"36be08dd94c8a0f07c737b9814275d0d.png","linecolor":"ffa0ec6f","linewidth":2,"page":107,"rect":[151.4739588415584,125.90669827276032,382.5441062463561,291.85269139854404],"type":2}],"originaltext":"插入操作时","page":107,"textblocks":[{"first":[91.2699966430664,70.97608947753906,10.123397827148438,9.633895874023438],"last":[131.7635955810547,70.97608947753906,10.123397827148438,9.633895874023438],"length":5,"rects":[[91.2699966430664,70.97608947753906,50.61699676513672,9.633895874023438]],"start":10,"text":"插入操作时"}],"type":5},{"date":"2022-03-05 17:46:51","docid":0,"fillcolor":"ffffed99","id":335,"markups":[{"date":"2022-03-05 17:46:56","docid":0,"id":336,"imgfile":"b8672fd0a77417bcac030d63aeec4724.png","linecolor":"ffa0ec6f","linewidth":2,"page":107,"rect":[104.68104798922985,472.75311995136065,436.0906330979898,592.8710045104308],"type":2}],"originaltext":"若要删除结点p","page":107,"textblocks":[{"first":[91.77999877929688,455.8302001953125,10.309898376464844,8.61981201171875],"last":[157.19000244140625,455.8302001953125,5.07049560546875,8.61981201171875],"length":7,"rects":[[91.77999877929688,455.8302001953125,70.48049926757812,8.61981201171875]],"start":471,"text":"若要删除结点p"}],"type":5}],"page":105,"rect":[0,88.07000732421875,1,89.07000732421875],"title":"3.14 双向链表","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":42,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-05 17:47:49","docid":0,"fillcolor":"ffffed99","id":338,"markups":[{"date":"2022-03-05 17:47:22","docid":0,"id":337,"imgfile":"67e58f793396201ca826f3d1b224fcc1.png","linecolor":"ffa0ec6f","linewidth":2,"page":108,"rect":[83.93779884850689,467.9291085232855,442.3618479544874,576.951766797783],"type":2}],"originaltext":"线性表的这两种结构","page":108,"textblocks":[{"first":[134.10000610351562,431.9902038574219,10.289993286132812,8.61981201171875],"last":[216.41995239257812,431.9902038574219,10.289993286132812,8.61981201171875],"length":9,"rects":[[134.10000610351562,431.9902038574219,92.60993957519531,8.61981201171875]],"start":504,"text":"线性表的这两种结构"}],"type":5}],"page":108,"rect":[0,157.07000732421875,1,158.07000732421875],"title":"3.15 总结回顾","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":43,"linecolor":"ff59c6ff","page":109,"rect":[0,31.07000732421875,1,32.07000732421875],"title":"3.16 结尾语","type":8}],"page":65,"rect":[0,61.07000732421875,1,62.07000732421875],"title":"第3章 线性表","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":44,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-28 17:46:08","docid":0,"id":45,"linecolor":"ff59c6ff","page":112,"rect":[0,48.07000732421875,1,49.07000732421875],"title":"4.1 开场白","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":46,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-06 13:54:06","docid":0,"fillcolor":"ffffed99","id":345,"markups":[{"date":"2022-03-06 13:54:31","docid":0,"fillcolor":"ff60bb46","id":346,"originaltext":"枝(stack )是限定仅在襄尾进行捕入和删除撮伟的雄性袋。","page":113,"textblocks":[{"first":[123.22000122070312,539.9901733398438,8.873306274414062,8.61981201171875],"last":[390.92999267578125,539.9901733398438,4.056396484375,8.61981201171875],"length":30,"rects":[[123.22000122070312,539.9901733398438,271.7663879394531,8.61981201171875]],"start":498,"text":"枝(stack )是限定仅在襄尾进行捕入和删除撮伟的雄性袋。"}],"type":5},{"date":"2022-03-06 13:52:27","docid":0,"fillcolor":"ffffed99","id":342,"originaltext":"栈的插入操作，叫作进栈，也称压栈、入栈。","page":114,"textblocks":[{"first":[86.70999908447266,159.2061309814453,10.75469970703125,9.633895874023438],"last":[292.05999755859375,159.2061309814453,3.04229736328125,9.633895874023438],"length":20,"rects":[[86.70999908447266,159.2061309814453,208.39229583740234,9.633895874023438]],"start":158,"text":"榜的插入操作，叫作进钱，也称压枝、人擒。"}],"type":5},{"date":"2022-03-06 13:52:31","docid":0,"fillcolor":"ffffed99","id":343,"originaltext":"栈的删除操作，叫作出栈，也有的叫作弹栈","page":114,"textblocks":[{"first":[86.70999908447266,198.75320434570312,10.301002502441406,9.126800537109375],"last":[272.1279602050781,198.75320434570312,10.300994873046875,9.126800537109375],"length":19,"rects":[[86.70999908447266,198.75320434570312,195.71895599365234,9.126800537109375]],"start":199,"text":"校的删除操作，叫作出枝，也有的叫作弹棋"}],"type":5}],"originaltext":"4.2.1栈的定义","page":113,"textblocks":[{"first":[66.93000030517578,168.83908081054688,6.5915985107421875,10.140899658203125],"last":[140.07789611816406,168.83908081054688,12.549301147460938,10.140899658203125],"length":9,"rects":[[66.93000030517578,168.83908081054688,85.69719696044922,10.140899658203125]],"start":38,"text":"4.2.1梭的定义"}],"type":5},{"date":"2022-03-06 13:57:56","docid":0,"fillcolor":"ffffed99","id":347,"markups":[{"date":"2022-03-06 14:04:50","docid":0,"fillcolor":"ff60bb46","id":348,"originaltext":"现在我要问问大家，这个最先进钱的元素，是不是就只能是最后出战呢?答案是不一定","page":114,"textblocks":[{"first":[86.70999908447266,408.1601867675781,10.125,8.61981201171875],"last":[139.27349853515625,429.9673156738281,10.5126953125,8.112701416015625],"length":39,"rects":[[86.70999908447266,408.1601867675781,323.99999237060547,8.61981201171875],[86.70999908447266,429.9673156738281,63.076194763183594,8.112701416015625]],"start":289,"text":"现在我要问问大家，这个最先进钱的元素，是不是就只能是最后出战呢?\n答案是不一定"}],"type":5}],"originaltext":"4.2.2进栈出栈变化形式","page":114,"textblocks":[{"first":[67.94999694824219,379.2650146484375,7.098602294921875,11.154998779296875],"last":[202.71746826171875,379.2650146484375,12.777496337890625,11.154998779296875],"length":13,"rects":[[67.94999694824219,379.2650146484375,147.5449676513672,11.154998779296875]],"start":275,"text":"4.2.2进拔出校变化形式"}],"type":5}],"page":113,"rect":[0,106.07000732421875,1,107.07000732421875],"title":"4.2 栈的定义","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":47,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-06 14:05:46","docid":0,"fillcolor":"ffffed99","id":349,"originaltext":"对于栈来讲，理论上线性表的操作特性官都具备，可由于它的特殊性，所以针对它在操作上会有些变化。特别是插入和删除操作","page":115,"textblocks":[{"first":[92.79000091552734,285.460205078125,10.57550048828125,8.61981201171875],"last":[280.9744567871094,302.7001953125,10.348297119140625,8.61981201171875],"length":57,"rects":[[92.79000091552734,285.460205078125,370.14249420166016,8.61981201171875],[74.54000091552734,302.7001953125,216.78275299072266,8.61981201171875]],"start":296,"text":"对于校来讲，理论上线性表的操作特性官都具备，可由于宫的特殊性，所以针对\n它在操作上会有些变化。特别是插入和删除操作"}],"type":5}],"page":115,"rect":[0,222.07000732421875,1,223.07000732421875],"title":"4.3 栈的抽象数据类型","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":48,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-06 14:08:37","docid":0,"fillcolor":"ffffed99","id":350,"markups":[{"date":"2022-03-06 14:08:53","docid":0,"fillcolor":"ffffed99","id":351,"originaltext":"下标为0的一端作为栈底比较好","page":116,"textblocks":[{"first":[130.5030059814453,193.68019104003906,10.5845947265625,8.619796752929688],"last":[276.3453063964844,193.68019104003906,10.64788818359375,8.619796752929688],"length":14,"rects":[[130.5030059814453,193.68019104003906,156.4901885986328,8.619796752929688]],"start":134,"text":"下标为0的一端作为核底比较好"}],"type":5},{"date":"2022-03-06 14:14:15","docid":0,"fillcolor":"ffffed99","id":353,"originaltext":"我们定义一个top变量来指示栈顶元素在数组中的位置","page":116,"textblocks":[{"first":[78.08999633789062,232.72320556640625,10.2677001953125,9.126800537109375],"last":[319.69085693359375,232.72320556640625,10.3944091796875,9.126800537109375],"length":25,"rects":[[78.08999633789062,232.72320556640625,251.99526977539062,9.126800537109375]],"start":175,"text":"我们定义一个top变盘来指示技顶元素在数组中的位置"}],"type":5},{"date":"2022-03-06 14:15:49","docid":0,"fillcolor":"ff60bb46","id":354,"originaltext":"当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1","page":116,"textblocks":[{"first":[211.44000244140625,283.9432067871094,9.633895874023438,9.126800537109375],"last":[190.14999389648438,302.190185546875,3.04229736328125,8.61981201171875],"length":39,"rects":[[211.44000244140625,283.9432067871094,235.78012084960938,9.126800537109375],[60.34000015258789,302.190185546875,132.85229110717773,8.61981201171875]],"start":314,"text":"当枝存在一个元素时>top等于0，因此通常把空榜\n的判定条件定为ωp等于-10"}],"type":5}],"originaltext":"4.4.1栈的顺序存储结构","page":116,"textblocks":[{"first":[58.310001373291016,110.02613830566406,7.098598480224609,9.633895874023438],"last":[183.04440307617188,110.02613830566406,12.676101684570312,9.633895874023438],"length":13,"rects":[[58.310001373291016,110.02613830566406,137.41050338745117,9.633895874023438]],"start":15,"text":"4.4.1梭的顺序存储结构"}],"type":5},{"date":"2022-03-06 14:17:00","docid":0,"fillcolor":"ffffed99","id":355,"originaltext":"4.4.2栈的顺序存储结构一一进栈操作","page":117,"textblocks":[{"first":[71.5,232.2220916748047,6.5915985107421875,10.647903442382812],"last":[276.7629699707031,232.2220916748047,12.768310546875,10.647903442382812],"length":19,"rects":[[71.5,232.2220916748047,218.03128051757812,10.647903442382812]],"start":73,"text":"4.4.2梭的顺序存储结构一一进技操作"}],"type":5},{"date":"2022-03-06 14:18:08","docid":0,"fillcolor":"ffffed99","id":356,"originaltext":"4.4.3栈的顺序存储结构一一出栈操作","page":118,"textblocks":[{"first":[62.369998931884766,66.41500854492188,5.746501922607422,11.154998779296875],"last":[264.08294677734375,66.41500854492188,12.768310546875,11.154998779296875],"length":19,"rects":[[62.369998931884766,66.41500854492188,214.48125839233398,11.154998779296875]],"start":3,"text":"4.4.3梭的顺序存储结构一一出校操作"}],"type":5}],"page":116,"rect":[0,18.07000732421875,1,19.07000732421875],"title":"4.4 栈的顺序存储结构及实现","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":49,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-06 15:05:55","docid":0,"fillcolor":"ffffed99","id":357,"originaltext":"从这里也就可以分析出来，栈1为空时，就是topl等于一1时;而当top2等于n时，即是栈2为空时","page":119,"textblocks":[{"first":[89.23999786376953,280.3872985839844,10.140899658203125,8.112701416015625],"last":[162.5998077392578,297.1202087402344,10.309906005859375,8.61981201171875],"length":49,"rects":[[89.23999786376953,280.3872985839844,368.1188278198242,8.112701416015625],[70.4800033569336,297.1202087402344,102.4297103881836,8.61981201171875]],"start":203,"text":"从这里也就可以分析出来，枝1为空时，就是topl等于一1时;而当top2等于\nn时，即是钱2为空时"}],"title":"栈空","type":5},{"date":"2022-03-06 15:06:32","docid":0,"fillcolor":"ffffed99","id":358,"originaltext":"两个栈见面之时，也就是两个指针之间相差1时，即回top1+ 1 == top2为栈满。","page":119,"textblocks":[{"first":[101.38660430908203,353.9101867675781,10.302200317382812,8.61981201171875],"last":[77.83220672607422,371.6601867675781,7.352203369140625,8.61981201171875],"length":42,"rects":[[101.38660430908203,353.9101867675781,356.4822006225586,8.61981201171875],[70.4800033569336,371.6601867675781,14.70440673828125,8.61981201171875]],"start":342,"text":"两个桔见面之时，也就是两个指针之间相差1时，即回pl+ 1 == top2为核\n满。"}],"title":"栈满","type":5},{"date":"2022-03-06 15:12:15","docid":0,"fillcolor":"ff60bb46","id":360,"originaltext":"事实上，使用这样的数据结构，通常都是当两个梢的空间需求有相反关系时，也就是一个枝增长时另一个枝在缩短的情况","page":120,"textblocks":[{"first":[83.66889953613281,524.7872314453125,10.539299011230469,9.12677001953125],"last":[243.33921813964844,541.5172119140625,10.463607788085938,9.12677001953125],"length":54,"rects":[[83.66889953613281,524.7872314453125,369.63047790527344,9.12677001953125],[65.40889739990234,541.5172119140625,188.39392852783203,9.12677001953125]],"start":629,"text":"事实上，使用这样的数据结构，通常都是当两个梢的空间需求有相反关系时，也\n就是一个枝增长时另一个枝在缩短的情况"}],"type":5}],"page":118,"rect":[0,265.07000732421875,1,266.07000732421875],"title":"4.5 两栈共享空间","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":50,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-06 15:13:14","docid":0,"fillcolor":"ffffed99","id":361,"markups":[{"date":"2022-03-06 15:13:28","docid":0,"fillcolor":"ffff0000","id":362,"originaltext":"简称为链钱","page":121,"textblocks":[{"first":[375.1439208984375,197.7401885986328,10.35821533203125,8.619796752929688],"last":[416.5767822265625,197.7401885986328,10.35821533203125,8.619796752929688],"length":5,"rects":[[375.1439208984375,197.7401885986328,51.79107666015625,8.619796752929688]],"start":114,"text":"简称为链钱"}],"type":5},{"date":"2022-03-06 15:18:03","docid":0,"fillcolor":"ffffed99","id":363,"markups":[{"date":"2022-03-06 15:19:53","docid":0,"id":365,"imgfile":"a8ae4cdf0ce8f112bc941a780336aea4.png","linecolor":"ffa0ec6f","linewidth":2,"page":121,"rect":[176.55881826754896,294.7470982553891,360.8360548200181,508.9332056619239],"type":2}],"originaltext":"所以比较好的办法是把栈顶放在单链表的头部","page":121,"textblocks":[{"first":[413.5011901855469,237.2902069091797,10.457794189453125,8.619796752929688],"last":[221.554443359375,254.5301971435547,10.2742919921875,8.619796752929688],"length":21,"rects":[[413.5011901855469,237.2902069091797,41.8311767578125,8.619796752929688],[67.44000244140625,254.5301971435547,164.38873291015625,8.619796752929688]],"start":190,"text":"所以比较\n好的办法是把楼顶放在单链表的头部"}],"title":"栈顶","type":5},{"date":"2022-03-06 15:22:14","docid":0,"fillcolor":"ffffed99","id":366,"originaltext":"但对于空栈来说，链表原定义是头指针指向空，那么链梭的空栈实就是top==null","page":121,"textblocks":[{"first":[87.72000122070312,571.9432373046875,10.318397521972656,9.12677001953125],"last":[452.2900085449219,571.9432373046875,5.07049560546875,9.12677001953125],"length":37,"rects":[[87.72000122070312,571.9432373046875,369.6405029296875,9.12677001953125]],"start":382,"text":"但对于空棋来说，链表原定义是头指针指向空，那么链梭的空其实就是ωp=肌几L"}],"title":"空栈","type":5}],"originaltext":"4.6.1栈的链式存储结构","page":121,"textblocks":[{"first":[67.44000244140625,169.84909057617188,6.5915985107421875,10.140899658203125],"last":[191.66270446777344,169.84909057617188,12.676101684570312,10.140899658203125],"length":13,"rects":[[67.44000244140625,169.84909057617188,136.8988037109375,10.140899658203125]],"start":72,"text":"4.6.1梭的链式存储结构"}],"type":5},{"date":"2022-03-06 15:23:38","docid":0,"fillcolor":"fffeeb73","id":367,"markups":[{"date":"2022-03-08 10:51:59","docid":0,"fillcolor":"ff60bb46","id":376,"originaltext":"top为栈顶指针","page":122,"textblocks":[{"first":[362.5400085449219,302.190185546875,6.8450927734375,8.61981201171875],"last":[422.73284912109375,302.190185546875,10.35821533203125,8.61981201171875],"length":7,"rects":[[362.5400085449219,302.190185546875,70.55105590820312,8.61981201171875]],"start":253,"text":"ωp为核顶指针"}],"type":5}],"originaltext":"4.6.2栈的链式存储结构一一进栈操作","page":122,"textblocks":[{"first":[65.91999816894531,274.3091125488281,6.5915985107421875,10.140899658203125],"last":[267.1405334472656,274.3091125488281,12.748504638671875,10.140899658203125],"length":19,"rects":[[65.91999816894531,274.3091125488281,213.9690399169922,10.140899658203125]],"start":205,"text":"4.6.2梭的链式存储结构一一进技操作"}],"type":5},{"date":"2022-03-08 10:53:44","docid":0,"fillcolor":"ffffed99","id":377,"markups":[{"date":"2022-03-08 10:56:45","docid":0,"fillcolor":"ffffaaff","id":378,"originaltext":"将校顶指针下移一位，最后释放p即可","page":123,"textblocks":[{"first":[127.9774169921875,190.1402130126953,10.257904052734375,8.619796752929688],"last":[295.4081115722656,190.1402130126953,9.9381103515625,8.619796752929688],"length":17,"rects":[[127.9774169921875,190.1402130126953,177.36880493164062,8.619796752929688]],"start":139,"text":"将校顶指针下移一位，最后释放p即可"}],"type":5}],"originaltext":"4.6.3栈的链式存储结构一一出栈操作","page":123,"textblocks":[{"first":[65.41000366210938,145.0121307373047,7.098602294921875,10.647903442382812],"last":[267.6124572753906,145.0121307373047,12.7847900390625,10.647903442382812],"length":19,"rects":[[65.41000366210938,145.0121307373047,214.98724365234375,10.647903442382812]],"start":76,"text":"4.6.3梭的链式存储结构一一出校操作"}],"type":5},{"date":"2022-03-08 11:05:03","id":380,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-08 11:04:42","docid":0,"fillcolor":"ffffaaff","id":379,"originaltext":"但对于梢的长度无限制。所以它们的区别和线性表中讨论的一样，如果楼的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链擒，反之，如果它的变化在可控范围内，建议使用顺序棋会更好一些。","page":124,"textblocks":[{"first":[119.76100158691406,142.98318481445312,10.26019287109375,9.126800537109375],"last":[341.2229309082031,177.46022033691406,10.15899658203125,8.619796752929688],"length":98,"rects":[[119.76100158691406,142.98318481445312,336.0757293701172,9.126800537109375],[67.94999694824219,160.22323608398438,387.88905334472656,9.126800537109375],[66.93000030517578,177.46022033691406,284.4519271850586,8.619796752929688]],"start":130,"text":"但对于梢的长度无限制。所以它们的区别和线性表中讨论的一样，如果楼\n的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链擒，反\n之，如果它的变化在可控范围内，建议使用顺序棋会更好一些。"}],"type":5}],"page":-1,"title":"总结","type":7}],"page":121,"rect":[0,98.07000732421875,1,99.07000732421875],"title":"4.6 栈的链式存储结构及实现","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":51,"linecolor":"ff59c6ff","page":124,"rect":[0,194.07000732421875,1,195.07000732421875],"title":"4.7 栈的作用","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":52,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-08 11:08:45","docid":0,"fillcolor":"fffeeb73","id":381,"originaltext":"4.8.1斐波那契数列实现","page":125,"textblocks":[{"first":[65.41000366210938,388.89910888671875,7.098602294921875,10.140899658203125],"last":[191.0303192138672,388.89910888671875,12.802902221679688,10.140899658203125],"length":13,"rects":[[65.41000366210938,388.89910888671875,138.4232177734375,10.140899658203125]],"start":76,"text":"4.8.1斐波那契数列实现"}],"type":5},{"date":"2022-03-08 11:11:53","docid":0,"fillcolor":"fffeeb73","id":384,"markups":[{"date":"2022-03-08 11:14:41","docid":0,"fillcolor":"ffffaaff","id":386,"markups":[{"date":"2022-03-08 11:14:19","docid":0,"fillcolor":"ffffaaff","id":385,"originaltext":"递归函数中调用自己的函数看作是在调用自己，而就当它是在调另一个函数。只不过，这个函数和自己长得一样而已。","page":127,"textblocks":[{"first":[435.21990966796875,363.5401916503906,10.309906005859375,8.61981201171875],"last":[188.49951171875,398.0273132324219,8.746505737304688,8.112701416015625],"length":54,"rects":[[435.21990966796875,363.5401916503906,20.61981201171875,8.61981201171875],[69.47000122070312,380.78729248046875,386.8758544921875,8.112701416015625],[68.95999908447266,398.0273132324219,128.28601837158203,8.112701416015625]],"start":340,"text":"递归\n函数中调用自己的函数看作是在调用自己，而就当它是在调另一个函数。只不过，这\n个函数和自己长得一样而已。"}],"type":5}],"originaltext":"我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。","page":127,"textblocks":[{"first":[352.2820129394531,599.8232421875,10.452911376953125,9.12677001953125],"last":[371.1600036621094,617.0661010742188,3.04229736328125,9.6339111328125],"length":41,"rects":[[352.2820129394531,599.8232421875,104.06594848632812,9.12677001953125],[70.98999786376953,617.0661010742188,303.2123031616211,9.6339111328125]],"start":512,"text":"我们把一个直接调用自\n己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。"}],"type":5},{"date":"2022-03-08 11:15:59","docid":0,"fillcolor":"ffffaaff","id":387,"originaltext":"选代和递归的区别是:迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易 让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。选代则不需要反复调用函数和占用额外的内存。","page":128,"textblocks":[{"first":[246.42999267578125,140.45021057128906,10.774688720703125,8.619796752929688],"last":[347.8648681640625,192.1602325439453,10.442413330078125,8.619796752929688],"length":124,"rects":[[246.42999267578125,140.45021057128906,206.36788940429688,8.619796752929688],[65.41000366210938,157.68019104003906,387.3857727050781,8.619796752929688],[65.41000366210938,174.92018127441406,387.3857727050781,8.619796752929688],[65.91999816894531,192.1602325439453,292.3872833251953,8.619796752929688]],"start":136,"text":"选代和递归的区别是:迭代使用的是循环结\n构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易 让人理\n解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量\n的时间和内存。选代则不需要反复调用函数和占用额外的内存。"}],"type":5}],"originaltext":"4.8.2递归定义","page":127,"textblocks":[{"first":[105.47000122070312,573.966064453125,12.676101684570312,9.6339111328125],"last":[143.49830627441406,573.966064453125,12.676101684570312,9.6339111328125],"length":4,"rects":[[105.47000122070312,573.966064453125,50.70440673828125,9.6339111328125]],"start":482,"text":"递归定义"}],"type":5},{"date":"2022-03-08 11:18:41","id":389,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-08 11:17:49","docid":0,"fillcolor":"ffffaaff","id":388,"originaltext":"这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合钱这样的数据结构，","page":128,"textblocks":[{"first":[84.16999816894531,326.5301818847656,10.531997680664062,8.61981201171875],"last":[233.80764770507812,343.2632141113281,10.461105346679688,9.126800537109375],"length":53,"rects":[[84.16999816894531,326.5301818847656,368.6201934814453,8.61981201171875],[66.43000030517578,343.2632141113281,177.83875274658203,9.126800537109375]],"start":410,"text":"这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的\n需求，显然很符合钱这样的数据结构，"}],"type":5}],"page":-1,"title":"总结","type":7}],"page":124,"rect":[0,403.07000732421875,1,404.07000732421875],"title":"4.8 栈的应用——递归","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":53,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-08 11:21:49","docid":0,"fillcolor":"fffeeb73","id":390,"markups":[{"date":"2022-03-08 11:23:08","docid":0,"fillcolor":"ffffaaff","id":392,"originaltext":"对于\"如(3-1)X3+10-:-2\"，如果要用后缀表示法应该是什么样子:\"931-3*+102/+\"，这样的表达式称为后缀表达式","page":129,"textblocks":[{"first":[160.281005859375,580.05322265625,10.292999267578125,9.12677001953125],"last":[337.9034423828125,597.293212890625,10.03948974609375,9.12677001953125],"length":66,"rects":[[160.281005859375,580.05322265625,297.08038330078125,9.12677001953125],[69.47000122070312,597.293212890625,278.4729309082031,9.12677001953125]],"start":1029,"text":"对于\"如(3-1)X3+10-:-2\"，如果要用后缀表示法应该是什么\n样子:\"931-3*+102/+\"，这样的表达式称为后缀表达式"}],"type":5}],"originaltext":"4.9.1后缀(逆波兰)表示法定义","page":128,"textblocks":[{"first":[67.44000244140625,538.4721069335938,6.5915985107421875,10.64788818359375],"last":[242.8771209716797,538.4721069335938,12.676101684570312,10.64788818359375],"length":17,"rects":[[67.44000244140625,538.4721069335938,188.11322021484375,10.64788818359375]],"start":662,"text":"4.9.1后缀(逆波兰)表示法定义"}],"type":5},{"date":"2022-03-08 11:22:12","docid":0,"fillcolor":"fffeeb73","id":391,"markups":[{"date":"2022-03-08 11:23:40","docid":0,"fillcolor":"ffffaaff","id":393,"originaltext":"规则:从左到右遍历表达式的每个数字和符号，遇到是数字就进枝，遇到是符号，就将处于桔顶两个数字出拢，进行运算，运算结果进钱，一直到最终获得结果。","page":130,"textblocks":[{"first":[85.19000244140625,221.06019592285156,10.871597290039062,8.619796752929688],"last":[433.5312805175781,237.793212890625,9.6339111328125,9.126800537109375],"length":72,"rects":[[85.19000244140625,221.06019592285156,369.63458251953125,8.619796752929688],[66.93000030517578,237.793212890625,376.23519134521484,9.126800537109375]],"start":175,"text":"规则:从左到右遍历表达式的每个数字和符号，遇到是数字就进枝，遇到是符\n号，就将处于桔顶两个数字出拢，进行运算，运算结果进钱，一直到最终获得结果。"}],"type":5}],"originaltext":"4.9.2后缀表达式计算结果","page":130,"textblocks":[{"first":[66.93000030517578,131.82913208007812,5.915496826171875,10.140899658203125],"last":[204.94882202148438,131.82913208007812,12.57470703125,10.140899658203125],"length":14,"rects":[[66.93000030517578,131.82913208007812,150.5935287475586,10.140899658203125]],"start":93,"text":"4.9.2后缀表达式计算结果"}],"type":5},{"date":"2022-03-08 11:29:41","docid":0,"fillcolor":"fffeeb73","id":394,"markups":[{"date":"2022-03-08 11:31:55","docid":0,"fillcolor":"ffffaaff","id":395,"originaltext":"规则:从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分i若是符号，则判断其与楼顶符号的优先级，是右括号或优先级低于槐顶符号(乘除优先加减)则检顶元素依次出钱并输出，并将当前符号进梢，一直到最终输出后缀表达式为止。","page":132,"textblocks":[{"first":[81.63999938964844,389.4031982421875,10.140899658203125,9.126800537109375],"last":[182.0372772216797,442.14019775390625,9.633895874023438,8.61981201171875],"length":125,"rects":[[81.63999938964844,389.4031982421875,369.12379455566406,9.126800537109375],[63.38999938964844,406.6432189941406,387.37498474121094,9.126800537109375],[62.880001068115234,423.8832092285156,387.8867530822754,9.126800537109375],[63.38999938964844,442.14019775390625,128.2811737060547,8.61981201171875]],"start":302,"text":"规则:从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后\n缀表达式的一部分i若是符号，则判断其与楼顶符号的优先级，是右括号或优先级低\n于槐顶符号(乘除优先加减)则检顶元素依次出钱并输出，并将当前符号进梢，一直\n到最终输出后缀表达式为止。"}],"type":5}],"originaltext":"4.9.3中缀表达式转后缀表达式","page":132,"textblocks":[{"first":[62.369998931884766,283.9391174316406,7.098598480224609,10.140899658203125],"last":[225.69003295898438,283.9391174316406,12.6300048828125,10.140899658203125],"length":16,"rects":[[62.369998931884766,283.9391174316406,175.9500389099121,10.140899658203125]],"start":153,"text":"4.9.3中缀表达式转后缀表达式"}],"type":5},{"date":"2022-03-08 11:40:53","id":397,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-08 11:40:09","docid":0,"fillcolor":"fffeeb73","id":396,"originaltext":"最重要的就是两步:\n1.将中缀表达式转化为后缀表达式(桔用来迸出运算的符号)。\n2.将后缀表达式进行运算得出结果(辅用来进出运算的数字)。","page":134,"textblocks":[{"first":[111.95451354980469,581.5701904296875,9.814903259277344,8.61981201171875],"last":[352.8460998535156,623.6532592773438,9.693511962890625,9.12677001953125],"length":74,"rects":[[111.95451354980469,581.5701904296875,88.33407592773438,8.61981201171875],[63.029998779296875,665.3699951171875,15.452392578125,10.5],[78.08999633789062,601.8560791015625,284.4540710449219,9.6339111328125],[78.08999633789062,623.6532592773438,284.4496154785156,9.12677001953125]],"start":464,"text":"最重要的就是两步:\n110 \n1.将中缀表达式转化为后缀表达式(桔用来迸出运算的符号)。\n2.将后缀表达式进行运算得出结果(辅用来进出运算的数字)。"}],"type":5}],"page":-1,"title":"总结","type":7}],"page":128,"rect":[0,399.07000732421875,1,400.07000732421875],"title":"4.9 栈的应用——四则运算表达式求值","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":54,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-14 10:55:00","docid":0,"fillcolor":"fffeeb73","id":398,"originaltext":"先进先出的排队功能，这就是队列。","page":135,"textblocks":[{"first":[405.3324279785156,337.6802062988281,10.507110595703125,8.61981201171875],"last":[168.20098876953125,354.9232177734375,9.7720947265625,9.126800537109375],"length":17,"rects":[[405.3324279785156,337.6802062988281,52.535552978515625,8.61981201171875],[70.4800033569336,354.9232177734375,107.49308013916016,9.126800537109375]],"start":382,"text":"先进先出的\n排队功能，这就是队列。"}],"type":5},{"date":"2022-03-14 10:56:19","docid":0,"fillcolor":"fffeeb73","id":399,"originaltext":"队列(queue )是只允许在-端进行插入操作，而在另-端进行删除操作的线性衰。","page":135,"textblocks":[{"first":[112.05999755859375,379.77020263671875,9.126800537109375,8.61981201171875],"last":[164.7899932861328,394.477294921875,4.056396484375,8.112701416015625],"length":41,"rects":[[112.05999755859375,379.77020263671875,326.0254821777344,8.61981201171875],[111.55000305175781,394.477294921875,57.29638671875,8.112701416015625]],"start":400,"text":"队列(queue )是只允许在-端进行插入操作，而在另-端进行删除操\n作的线性衰。"}],"type":5},{"date":"2022-03-14 10:57:11","docid":0,"fillcolor":"fffeeb73","id":400,"originaltext":"允许插入的一端称为队尾，允许删除的一端称为队头。","page":135,"textblocks":[{"first":[397.0932922363281,419.3201904296875,10.213287353515625,8.61981201171875],"last":[246.99771118164062,436.5601806640625,10.383392333984375,8.61981201171875],"length":25,"rects":[[397.0932922363281,419.3201904296875,61.27972412109375,8.61981201171875],[70.4800033569336,436.5601806640625,186.9011001586914,8.61981201171875]],"start":482,"text":"允许插入的一\n端称为队尾，允许删除的一端称为队头。"}],"type":5},{"date":"2022-03-14 10:57:20","docid":0,"id":401,"imgfile":"7e56e0950c39533d4f33ad9ffb0d0fd1.png","linecolor":"ffa0ec6f","linewidth":2,"page":135,"rect":[57.8881371369013,501.21478737700374,465.03470166644047,595.7654113672759],"type":2}],"page":135,"rect":[0,123.07000732421875,1,124.07000732421875],"title":"4.10 队列的定义","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":55,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-14 10:58:51","docid":0,"fillcolor":"fffeeb73","id":402,"originaltext":"同样是线性衰，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。","page":136,"textblocks":[{"first":[83.66999816894531,168.33322143554688,10.517601013183594,9.126800537109375],"last":[220.05999755859375,185.57020568847656,3.04229736328125,8.619796752929688],"length":52,"rects":[[83.66999816894531,168.33322143554688,368.11607360839844,9.126800537109375],[64.4000015258789,185.57020568847656,158.7022933959961,8.619796752929688]],"start":77,"text":"同样是线性衰，队列也有类似线性表的各种操作，不同的就是插入数据只能在队\n尾进行，删除数据只能在队头进行。"}],"type":5}],"page":136,"rect":[0,76.07000732421875,1,77.07000732421875],"title":"4.11 队列的抽象数据类型","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":56,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-14 11:00:16","docid":0,"fillcolor":"fffeeb73","id":403,"originaltext":"同样，队列作为一种特殊的线性表，也同样存在这两种存储方式","page":136,"textblocks":[{"first":[410.6115417480469,479.1532287597656,10.5465087890625,9.126800537109375],"last":[305.79827880859375,496.39019775390625,10.463592529296875,8.61981201171875],"length":29,"rects":[[410.6115417480469,479.1532287597656,42.18603515625,9.126800537109375],[65.41000366210938,496.39019775390625,250.85186767578125,8.61981201171875]],"start":533,"text":"同样，队\n列作为一种特殊的钱性衰，也同样存在这两种存储方式"}],"type":5},{"date":"2022-03-14 11:01:09","docid":0,"fillcolor":"fffeeb73","id":404,"markups":[{"date":"2022-03-14 11:09:45","docid":0,"fillcolor":"fffeeb73","id":406,"markups":[{"date":"2022-03-14 11:09:50","docid":0,"fillcolor":"fffeeb73","id":407,"originaltext":"也就是说，队头不需要一定在下标为0的位置","page":137,"textblocks":[{"first":[365.0799865722656,440.6101989746094,10.3662109375,8.61981201171875],"last":[175.10379028320312,458.3572998046875,9.971893310546875,8.112701416015625],"length":21,"rects":[[365.0799865722656,440.6101989746094,93.2958984375,8.61981201171875],[69.9800033569336,458.3572998046875,115.0956802368164,8.112701416015625]],"start":374,"text":"也就是说，队头不需\n要一定在下标为0的位置"}],"type":5},{"date":"2022-03-14 11:10:08","docid":0,"fillcolor":"fffeeb73","id":408,"originaltext":"为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置","page":137,"textblocks":[{"first":[89.75,586.6432495117188,10.343704223632812,9.12677001953125],"last":[367.8028564453125,603.8832397460938,10.20428466796875,9.12677001953125],"length":70,"rects":[[89.75,586.6432495117188,369.6361999511719,9.12677001953125],[71.5,603.8832397460938,306.50714111328125,9.12677001953125]],"start":453,"text":"为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指\n针，front指针指向队头元素，rear指针指向队尾元素的下一个位置"}],"type":5},{"date":"2022-03-14 11:15:20","docid":0,"fillcolor":"fffeeb73","id":409,"originaltext":"因数组末尾元素已经占用，再向后力日，就会产生数组越界的错误，可实际上，我们的队列在下标为0和1的地方还是空闲的。我们把这种现象叫做\"假滥出\" ","page":138,"textblocks":[{"first":[85.24819946289062,407.6601867675781,10.169097900390625,8.61981201171875],"last":[411.71929931640625,424.3932189941406,2.03021240234375,9.126800537109375],"length":72,"rects":[[85.24819946289062,407.6601867675781,367.0427551269531,8.61981201171875],[64.91000366210938,424.3932189941406,348.8395080566406,9.126800537109375]],"start":408,"text":"因数组末尾元素已经占用，再向后力日，就会产生数组越界的错误，可实际上，我\n们的队列在下标为0和1的地方还是空闲的。我们把这种现象叫做\"假滥出\" "}],"type":5}],"originaltext":"为什么出队列时一定要全部移动呢","page":137,"textblocks":[{"first":[151.2744903564453,423.3702087402344,10.478897094726562,8.61981201171875],"last":[300.2406921386719,423.3702087402344,10.54229736328125,8.61981201171875],"length":15,"rects":[[151.2744903564453,423.3702087402344,159.5084991455078,8.61981201171875]],"start":316,"text":"为什么出队列时一定要全部移动呢"}],"type":5}],"originaltext":"4.12.1队列顺序存储的不足","page":136,"textblocks":[{"first":[64.91000366210938,545.569091796875,7.098602294921875,10.14093017578125],"last":[209.97837829589844,545.569091796875,12.619796752929688,10.14093017578125],"length":15,"rects":[[64.91000366210938,545.569091796875,157.68817138671875,10.14093017578125]],"start":580,"text":"4.12.1队列顺序存储的不足"}],"title":"","type":5},{"date":"2022-03-14 11:15:31","docid":0,"fillcolor":"fffeeb73","id":410,"markups":[{"date":"2022-03-14 11:15:54","docid":0,"fillcolor":"fffeeb73","id":420,"originaltext":"解决假溢出的办法就是后面满了，就再从头开始","page":138,"textblocks":[{"first":[105.26300048828125,561.2932739257812,10.546501159667969,9.12677001953125],"last":[315.7351989746094,561.2932739257812,10.11419677734375,9.12677001953125],"length":21,"rects":[[105.26300048828125,561.2932739257812,220.58639526367188,9.12677001953125]],"start":603,"text":"解决假溢出的办法就是后面满了，就再从头开始"}],"type":5},{"date":"2022-03-14 11:15:47","docid":0,"fillcolor":"fffeeb73","id":411,"markups":[{"date":"2022-03-14 11:25:32","docid":0,"fillcolor":"fffeeb73","id":419,"markups":[{"date":"2022-03-14 11:28:23","docid":0,"fillcolor":"fffeeb73","id":417,"originaltext":"办法一是设置一个标志变量flag，","page":139,"textblocks":[{"first":[104.95999908447266,372.1632080078125,10.140899658203125,9.126800537109375],"last":[247.44000244140625,372.1632080078125,2.0281982421875,9.126800537109375],"length":17,"rects":[[104.95999908447266,372.1632080078125,144.5082015991211,9.126800537109375]],"start":280,"text":"办法一是设置一个标志变量flag，"}],"type":5},{"date":"2022-03-14 11:28:20","docid":0,"fillcolor":"fffeeb73","id":416,"markups":[{"date":"2022-03-14 11:28:34","docid":0,"fillcolor":"fffeeb73","id":418,"markups":[{"date":"2022-03-21 12:43:10","docid":0,"fillcolor":"fffeeb73","id":422,"markups":[{"date":"2022-03-21 12:43:16","docid":0,"id":423,"imgfile":"0883ef78f26292b8be56c5c2094ec608.png","linecolor":"ffa0ec6f","linewidth":2,"page":140,"rect":[79.11378742043178,246.02458283183054,269.17983768659104,263.8734251157084],"type":2}],"originaltext":"因此通用的计算队列长度公式为:","page":140,"textblocks":[{"first":[155.1597900390625,227.65419006347656,9.633895874023438,8.619796752929688],"last":[293.39959716796875,227.65419006347656,9.814910888671875,8.619796752929688],"length":15,"rects":[[155.1597900390625,227.65419006347656,148.05471801757812,8.619796752929688]],"start":447,"text":"因此通用的计算队列长度公式为:"}],"type":5}],"originaltext":"由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位.琶时就是满的情况，但也可能是相差整整一圈。","page":139,"textblocks":[{"first":[219.55450439453125,593.2332153320312,10.140899658203125,9.12677001953125],"last":[382.82000732421875,609.966064453125,3.549285888671875,9.6339111328125],"length":62,"rects":[[219.55450439453125,593.2332153320312,235.77313232421875,9.12677001953125],[67.44000244140625,609.966064453125,318.9292907714844,9.6339111328125]],"start":569,"text":"由于rear可能比front大，也可能比front小，所以\n尽管它们只相差一个位.琶时就是满的情况，但也可能是相差整整一圈。"}],"type":5},{"date":"2022-03-21 12:33:54","docid":0,"id":421,"imgfile":"c190c4d2a592ec095a7a508ac743056c.png","linecolor":"ffa0ec6f","linewidth":2,"page":139,"rect":[58.85293942251632,474.68272452259066,480.4715382362808,558.1381222282901],"type":2}],"originaltext":"办法二是当队列空时，条件就是from= re缸，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。","page":139,"textblocks":[{"first":[105.47000122070312,411.210205078125,10.140899658203125,8.61981201171875],"last":[444.1700134277344,427.9432067871094,3.04229736328125,9.126800537109375],"length":70,"rects":[[105.47000122070312,411.210205078125,347.8285217285156,8.61981201171875],[105.47000122070312,427.9432067871094,341.7423095703125,9.126800537109375]],"start":353,"text":"办法二是当队列空时，条件就是from= re缸，当队列满时，我们修改其条\n件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。"}],"type":5}],"originaltext":"空队列时，fronr等于此缸，现在当队列满时，也是fro町等于rear，那么如何判断此时的队列究竟是空还是满呢?","page":139,"textblocks":[{"first":[256.19244384765625,333.1202087402344,10.115509033203125,8.61981201171875],"last":[411.38787841796875,350.3572998046875,9.971893310546875,8.112701416015625],"length":57,"rects":[[256.19244384765625,333.1202087402344,197.11016845703125,8.61981201171875],[104.95999908447266,350.3572998046875,316.39977264404297,8.112701416015625]],"start":220,"text":"空队列时，fronr等于此缸，现在当队列满\n时，也是fro町等于rear，那么如何判断此时的队列究竟是空还是满呢?"}],"type":5}],"originaltext":"我们把队列的这种头尾相接的顺序存储结构称为循环队列。","page":138,"textblocks":[{"first":[65.91999816894531,578.5332641601562,10.204299926757812,9.12677001953125],"last":[324.510009765625,578.5332641601562,4.563385009765625,9.12677001953125],"length":26,"rects":[[65.91999816894531,578.5332641601562,263.1533966064453,9.12677001953125]],"start":637,"text":"我们把队列的这种头尾相接的顺序存储结构称为循环队列。"}],"type":5}],"originaltext":"4.12.2循环队列定义","page":138,"textblocks":[{"first":[65.41000366210938,534.4190673828125,6.084602355957031,10.14093017578125],"last":[171.38050842285156,534.4190673828125,12.676101684570312,10.14093017578125],"length":12,"rects":[[65.41000366210938,534.4190673828125,118.6466064453125,10.14093017578125]],"start":588,"text":"4.12.2循环队列定义"}],"type":5}],"page":136,"rect":[0,417.07000732421875,1,418.07000732421875],"title":"4.12 循环队列","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":57,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-21 12:44:37","docid":0,"fillcolor":"fffeeb73","id":424,"markups":[{"date":"2022-03-21 15:14:52","docid":0,"fillcolor":"fffeeb73","id":427,"originaltext":"人队操作时，其实就是在链衰尾部插入结点","page":142,"textblocks":[{"first":[89.23999786376953,580.05322265625,10.32769775390625,9.12677001953125],"last":[275.1385803222656,580.05322265625,10.32769775390625,9.12677001953125],"length":19,"rects":[[89.23999786376953,580.05322265625,196.22628021240234,9.12677001953125]],"start":351,"text":"人队操作时，其实就是在链衰尾部插入结点"}],"type":5}],"originaltext":"4.13.1队列的链式存储结构一一入队操作","page":142,"textblocks":[{"first":[70.4800033569336,552.6749877929688,5.5774993896484375,11.155029296875],"last":[292.0285949707031,552.6749877929688,12.70989990234375,11.155029296875],"length":21,"rects":[[70.4800033569336,552.6749877929688,234.25849151611328,11.155029296875]],"start":329,"text":"4.13.1队列的链式存储结构一一入队操作"}],"type":5},{"date":"2022-03-21 13:00:09","docid":0,"fillcolor":"fffeeb73","id":425,"markups":[{"date":"2022-03-21 15:14:38","docid":0,"fillcolor":"fffeeb73","id":426,"originaltext":"出队操作时，就是头结点的后继结点出队，将头结点的后继改为宫后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点","page":143,"textblocks":[{"first":[88.73999786376953,445.1802062988281,10.343696594238281,8.61981201171875],"last":[330.34716796875,461.91021728515625,10.20428466796875,8.61981201171875],"length":64,"rects":[[88.73999786376953,445.1802062988281,362.0293502807617,8.61981201171875],[68.95999908447266,461.91021728515625,271.5914535522461,8.61981201171875]],"start":357,"text":"出队操作时，就是头结点的后继结点出队，将头结点的后继改为宫后面的结点，\n若链表除头结点外只剩一个元素时，则需将rear指向头结点"}],"type":5}],"originaltext":"4.13.2队列的链式存储结构一一出队操作","page":143,"textblocks":[{"first":[68.95999908447266,417.2890930175781,7.098602294921875,10.140899658203125],"last":[290.50860595703125,417.2890930175781,12.70989990234375,10.140899658203125],"length":21,"rects":[[68.95999908447266,417.2890930175781,234.25850677490234,10.140899658203125]],"start":335,"text":"4.13.2队列的链式存储结构一一出队操作"}],"type":5}],"page":141,"rect":[0,392.07000732421875,1,393.07000732421875],"title":"4.13 队列的链式存储结构及实现","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":58,"linecolor":"ff59c6ff","page":144,"rect":[0,409.07000732421875,1,410.07000732421875],"title":"4.14 总结回顾","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":59,"linecolor":"ff59c6ff","page":145,"rect":[0,310.07000732421875,1,311.07000732421875],"title":"4.15 结尾语","type":8}],"page":111,"rect":[0,95.07000732421875,1,96.07000732421875],"title":"第4章 栈与队列","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":60,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-22 18:52:04","docid":0,"fillcolor":"ffff0000","id":429,"originaltext":"串是由零个或多字符组成的有限数列，又各叫字符串.","page":147,"textblocks":[{"first":[171.88999938964844,225.6273193359375,3.5493011474609375,8.112701416015625],"last":[419.3299865722656,225.6273193359375,3.04229736328125,8.112701416015625],"length":15,"rects":[[171.88999938964844,225.6273193359375,250.48228454589844,8.112701416015625]],"start":5,"text":"〉是由零个或多，又各叫字符串."}],"type":5},{"date":"2022-02-28 17:46:08","docid":0,"id":61,"linecolor":"ff59c6ff","page":148,"rect":[0,38.07000732421875,1,39.07000732421875],"title":"5.1 开场白","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":62,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-22 18:56:12","docid":0,"fillcolor":"ffff0000","id":432,"originaltext":"串是由零个或多字符组成的有限数列，又各叫字符串.","page":149,"textblocks":[{"first":[114.08999633789062,309.28729248046875,8.619796752929688,8.112701416015625],"last":[114.08999633789062,325.52020263671875,8.619796752929688,8.61981201171875],"length":34,"rects":[[114.08999633789062,309.28729248046875,303.7135925292969,8.112701416015625],[114.08999633789062,325.52020263671875,8.619796752929688,8.61981201171875]],"start":159,"text":"事(string )是由军个或多个字符组成的有限序列，又名叫字符\n事"}],"type":5},{"date":"2022-03-22 18:57:12","docid":0,"fillcolor":"fffeeb73","id":433,"originaltext":"零个字符的审称为空串(oullstring) ","page":149,"textblocks":[{"first":[377.239990234375,401.5701904296875,10.3944091796875,8.61981201171875],"last":[160.0731964111328,418.3031921386719,2.600006103515625,9.126800537109375],"length":24,"rects":[[377.239990234375,401.5701904296875,82.64846801757812,8.61981201171875],[73.0199966430664,418.3031921386719,89.65320587158203,9.126800537109375]],"start":349,"text":"零个字符的审称为\n空串(oullstring) "}],"type":5},{"date":"2022-03-22 18:57:36","docid":0,"fillcolor":"fffeeb73","id":434,"originaltext":"子串与主串，E郭中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。","page":149,"textblocks":[{"first":[91.77999877929688,518.7032470703125,9.380302429199219,9.12677001953125],"last":[171.25099182128906,537.460205078125,9.7720947265625,8.61981201171875],"length":48,"rects":[[91.77999877929688,518.7032470703125,363.04119873046875,9.12677001953125],[73.52999877929688,537.460205078125,107.49308776855469,8.61981201171875]],"start":502,"text":"子串与主串，E郭中任意个数的连续字符组成的子序列称为该串的子串，相应地，\n包含子串的串称为主串。"}],"type":5}],"page":148,"rect":[0,379.07000732421875,1,380.07000732421875],"title":"5.2 串的定义","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":63,"linecolor":"ff59c6ff","page":150,"rect":[0,49.07000732421875,1,50.07000732421875],"title":"5.3 串的比较","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":64,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-22 19:00:03","docid":0,"fillcolor":"ffff0000","id":435,"originaltext":"串的逻辑结构和线性表很相似，不同之处在于串针对的是字符架","page":151,"textblocks":[{"first":[92.28179931640625,501.45709228515625,10.514495849609375,9.6339111328125],"last":[377.2464599609375,501.45709228515625,10.521209716796875,9.6339111328125],"length":28,"rects":[[92.28179931640625,501.45709228515625,295.4858703613281,9.6339111328125]],"start":205,"text":"串的逻辑结构和线性表很相似，不同之处在于串针对的是字符架"}],"type":5},{"date":"2022-03-22 19:00:24","docid":0,"fillcolor":"ffff0000","id":437,"originaltext":"因此，对于串的基本操作与线性表是有很大差别的","page":151,"textblocks":[{"first":[93.30180358886719,574.9842529296875,10.546501159667969,9.12677001953125],"last":[314.7782897949219,574.9842529296875,10.5465087890625,9.12677001953125],"length":22,"rects":[[93.30180358886719,574.9842529296875,232.0229949951172,9.12677001953125]],"start":330,"text":"因此，对于串的基本操作与线性表是有很大差别的"}],"type":5},{"date":"2022-03-22 19:00:34","docid":0,"fillcolor":"ffff0000","id":438,"originaltext":"线性表更关注的是单个元素的操作，比如查找一个元素，插入或删除一个元素，但串中更多的是查找子串位置、得到指定位置子串、替换子串等操作","page":151,"textblocks":[{"first":[335.8713073730469,574.9842529296875,10.5465087890625,9.12677001953125],"last":[229.0806121826172,610.4742431640625,10.25360107421875,9.12677001953125],"length":67,"rects":[[335.8713073730469,574.9842529296875,126.55810546875,9.12677001953125],[74.54180145263672,591.7171020507812,381.7984085083008,9.6339111328125],[74.03179931640625,610.4742431640625,165.3024139404297,9.12677001953125]],"start":353,"text":"线性表更关注的是单个元素\n的操作，比如查找一个元素，插入或删除一个元素，但串中更多的是查找子串位置、\n得到指定位置子串、替换子串等操作"}],"type":5}],"page":151,"rect":[-2.0281999111175537,396.59100341796875,-1.0281999111175537,397.59100341796875],"title":"5.4 串的抽象数据类型","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":65,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-22 19:01:58","docid":0,"fillcolor":"fffeeb73","id":440,"markups":[{"date":"2022-03-22 19:02:07","docid":0,"fillcolor":"ffffaaff","id":441,"markups":[{"date":"2022-03-22 19:03:32","docid":0,"fillcolor":"ffff0000","id":445,"markups":[{"date":"2022-03-22 19:03:42","docid":0,"fillcolor":"ffff0000","id":447,"originaltext":"一般可以将实际的串长度值保存在数组的0下标位置3有的书中也会定义存储在数组的最后一个下标位置","page":153,"textblocks":[{"first":[331.1000061035156,565.3501586914062,10.64788818359375,8.61981201171875],"last":[416.9142150878906,582.083251953125,10.364013671875,9.12677001953125],"length":47,"rects":[[331.1000061035156,565.3501586914062,127.26986694335938,8.61981201171875],[69.9800033569336,582.083251953125,357.29822540283203,9.12677001953125]],"start":509,"text":"一般可以将实际的串长度值\n保存在数组的0下标位置3有的书中也会定义存储在数组的最后一个下标位置"}],"type":5}],"originaltext":"既然是定长数组，就存在一个预定义的最大串长度","page":153,"textblocks":[{"first":[89.23999786376953,565.3501586914062,10.229103088378906,8.61981201171875],"last":[304.051025390625,565.3501586914062,10.229095458984375,8.61981201171875],"length":22,"rects":[[89.23999786376953,565.3501586914062,225.04012298583984,8.61981201171875]],"start":486,"text":"既然是定长数组，就存在一个预定义的最大串长度"}],"type":5},{"date":"2022-03-22 19:03:47","docid":0,"fillcolor":"ffff0000","id":448,"markups":[{"date":"2022-03-22 19:04:00","docid":0,"fillcolor":"ffff0000","group":[{"date":"2022-03-22 19:04:00","docid":0,"fillcolor":"ffff0000","id":450,"originaltext":"","page":154,"textblocks":[{"first":[64.4000015258789,66.92610168457031,10.445098876953125,9.633895874023438],"last":[72.00860595703125,85.18019104003906,7.098602294921875,8.619796752929688],"length":40,"rects":[[64.4000015258789,66.92610168457031,387.8834762573242,9.633895874023438],[64.91000366210938,85.18019104003906,14.19720458984375,8.619796752929688]],"start":0,"text":"此时的串长度，就需要遍历计算-下才知道了，其实这还是需要占用-个空间，何必\n呢。"}],"type":5}],"id":449,"markups":[{"date":"2022-03-22 19:05:06","docid":0,"id":451,"imgfile":"95cbcc05b8bbac7c5f49c8412a23f86d.png","linecolor":"ffa0ec6f","linewidth":2,"page":154,"rect":[112.49999664723883,88.99999734759339,438.99998691678087,203.9999939203264],"type":2}],"originaltext":"这个时候，你要想知道此时的串长度，就需要遍历计算-下才知道了，其实这还是需要占用-个空间，何必呢。","page":153,"textblocks":[{"first":[354.10650634765625,616.55322265625,10.42608642578125,9.12677001953125],"last":[0,0,0,0],"length":16,"rects":[[354.10650634765625,616.55322265625,104.2608642578125,9.12677001953125],[444.3699951171875,664.3400268554688,17.01654052734375,9.5],[444.3699951171875,664.3400268554688,17.01654052734375,9.5]],"start":625,"text":"这个时候，你要想知道\n129 \n"}],"type":5}],"originaltext":"但也有些编程语言不想这么干，觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如\\0来表示串值的终结","page":153,"textblocks":[{"first":[437.6422424316406,582.083251953125,10.364013671875,9.12677001953125],"last":[333.25433349609375,616.55322265625,10.42608642578125,9.12677001953125],"length":67,"rects":[[437.6422424316406,582.083251953125,20.72802734375,9.12677001953125],[69.9800033569336,599.3232421875,388.3908157348633,9.12677001953125],[69.47000122070312,616.55322265625,274.2104187011719,9.12677001953125]],"start":557,"text":"但也\n有些编程语言不想这么干，觉得存个数字占个空间麻烦。它规定在串值后面加一个不\n计入串长度的结束标记字符，比如气。\"来表示串值的终结"}],"type":5}],"originaltext":"串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的感变量分配一个固定长度的存储区。","page":153,"textblocks":[{"first":[89.23999786376953,509.0632019042969,10.343696594238281,9.126800537109375],"last":[363.6263122558594,526.30322265625,10.527191162109375,9.12677001953125],"length":65,"rects":[[89.23999786376953,509.0632019042969,368.6218795776367,9.126800537109375],[68.95999908447266,526.30322265625,305.1935043334961,9.12677001953125]],"start":407,"text":"串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照\n预定义的大小，为每个定义的感变量分配一个固定长度的存储区。"}],"type":5}],"originaltext":"5.5.1串的顺序存储结构","page":153,"textblocks":[{"first":[69.47000122070312,481.1791076660156,6.5915985107421875,10.140899658203125],"last":[194.20440673828125,481.1791076660156,12.676101684570312,10.140899658203125],"length":13,"rects":[[69.47000122070312,481.1791076660156,137.41050720214844,10.140899658203125]],"start":387,"text":"5.5.1串的顺序存储结构"}],"type":5},{"date":"2022-03-22 19:07:11","docid":0,"fillcolor":"fffeeb73","id":452,"markups":[{"date":"2022-03-22 19:11:26","docid":0,"fillcolor":"ffff0000","id":453,"originaltext":"因此，一个结点可以存放一个字符，也可以考虑存放多个字符","page":155,"textblocks":[{"first":[217.02000427246094,251.99021911621094,10.427505493164062,8.619796752929688],"last":[100.91000366210938,269.2301940917969,10.394401550292969,8.61981201171875],"length":28,"rects":[[217.02000427246094,251.99021911621094,239.8323211669922,8.619796752929688],[69.47000122070312,269.2301940917969,41.83440399169922,8.61981201171875]],"start":289,"text":"因此，一个结点可以存放一个字符，也可以考虑存放\n多个字符"}],"type":5}],"originaltext":"5.5.2串的链式存储结构","page":155,"textblocks":[{"first":[69.9800033569336,189.11911010742188,5.476097106933594,10.140899658203125],"last":[193.82510375976562,189.11911010742188,12.549301147460938,10.140899658203125],"length":13,"rects":[[69.9800033569336,189.11911010742188,136.39440155029297,10.140899658203125]],"start":188,"text":"5.5.2串的链式存储结构"}],"type":5}],"page":153,"rect":[0,354.07000732421875,1,355.07000732421875],"title":"5.5 串的存储结构","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":66,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-22 19:19:12","docid":0,"fillcolor":"fffeeb73","id":459,"originaltext":"分析一下，最好的情况是什么?那就是一开始就区配成功，比如\"googJegood\"中去找飞ooglen，时间复杂度为0(1)","page":158,"textblocks":[{"first":[85.69999694824219,193.68319702148438,10.521202087402344,9.126800537109375],"last":[231.9810028076172,210.41909790039062,4.8170013427734375,10.140899658203125],"length":62,"rects":[[85.69999694824219,193.68319702148438,362.01930236816406,9.126800537109375],[67.44000244140625,210.41909790039062,169.35800170898438,10.140899658203125]],"start":71,"text":"分析一下，最好的情况是什么?那就是一开始就区配成功，比如\"googJegood\"\n中去找飞ooglen，时间复杂度为0(1)"}],"type":5},{"date":"2022-03-22 19:19:23","docid":0,"fillcolor":"fffeeb73","id":460,"originaltext":"稍差一些，如果像刚才例子中第二、三、四位一样，每次都是首字母就不匹配，那么对T串的循环就不必进行了，比如\"abcc险fgoogle\"中去找Ugoog旷。那么时间复杂度为O(n+m)","page":158,"textblocks":[{"first":[246.92999267578125,210.41909790039062,9.9508056640625,10.140899658203125],"last":[337.7750549316406,244.89610290527344,5.493011474609375,9.633895874023438],"length":92,"rects":[[246.92999267578125,210.41909790039062,206.87570190429688,10.140899658203125],[66.93000030517578,228.6732177734375,386.37584686279297,9.126800537109375],[67.94999694824219,244.89610290527344,275.3180694580078,9.633895874023438]],"start":134,"text":"稍差一些，如果像刚才例子中第二、三、四位\n一样，每次都是首字母就不匹配，那么对T串的循环就不必进行了，比如\n\"abcc险fgoogle\"中去找Ugoog旷。那么时间复杂度为O(n+m)"}],"type":5},{"date":"2022-03-22 19:20:02","docid":0,"fillcolor":"fffeeb73","id":461,"markups":[{"date":"2022-03-22 19:20:08","docid":0,"fillcolor":"ffffaaff","id":462,"markups":[{"date":"2022-03-22 19:20:19","docid":0,"fillcolor":"ffff0000","id":463,"originaltext":"因此最坏情况的时间复杂度为O((n-m+ 1)*m)","page":158,"textblocks":[{"first":[270.7699890136719,590.1873168945312,10.530914306640625,8.1126708984375],"last":[100.77568817138672,605.5400390625,3.429901123046875,12.5],"length":27,"rects":[[270.7699890136719,590.1873168945312,183.042724609375,8.1126708984375],[68.16999816894531,605.5400390625,36.03559112548828,12.5]],"start":838,"text":"因此最坏情况的时间复杂度为O((n-m\n+ 1)*m)"}],"type":5}],"originaltext":"举一个很极端的例子。主串为s=\"000000000000000000000000000000000000 00000000000001\"，而要匹配的子串为T=\"0000000001\"","page":158,"textblocks":[{"first":[87.4822006225586,317.5500183105469,10.276100158691406,11.5],"last":[329.0799865722656,336.1601867675781,3.549285888671875,8.61981201171875],"length":92,"rects":[[87.4822006225586,317.5500183105469,368.86930084228516,11.5],[66.93000030517578,336.1601867675781,265.6992721557617,8.61981201171875]],"start":323,"text":"举一个很极端的例子。主串为s=\"000000000000000000000000000000000000 \n00000000000001\"，而要匹配的子串为T=\"0000000001\""}],"type":5}],"originaltext":"那么最坏的情况又是什么?就是每次不成功的匹配都发生在串T的最后一个字符","page":158,"textblocks":[{"first":[85.19000244140625,302.190185546875,10.591598510742188,8.61981201171875],"last":[66.93000030517578,317.5500183105469,10.276100158691406,11.5],"length":36,"rects":[[85.19000244140625,302.190185546875,368.61346435546875,8.61981201171875],[66.93000030517578,317.5500183105469,10.276100158691406,11.5]],"start":286,"text":"那么最坏的情况又是什么?就是每次不成功的匹配都发生在串T的最后一个字\n符"}],"type":5}],"page":155,"rect":[0,339.07000732421875,1,340.07000732421875],"title":"5.6 朴素的模式匹配算法","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":67,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-23 10:58:47","docid":0,"fillcolor":"ffff0000","id":477,"originaltext":"我们的KMP模式匹配算法就是为了让这没必要的回溯不发生。","page":162,"textblocks":[{"first":[281.3123474121094,311.8302001953125,10.5126953125,8.61981201171875],"last":[170.7119140625,329.0601806640625,9.802902221679688,8.61981201171875],"length":29,"rects":[[281.3123474121094,311.8302001953125,167.93453979492188,8.61981201171875],[62.880001068115234,329.0601806640625,117.63481521606445,8.61981201171875]],"start":426,"text":"我们的KMP模式匹配算法就是为了\n让这没必要的回溯不发生。"}],"type":5},{"date":"2022-03-22 19:21:05","docid":0,"fillcolor":"fffeeb73","id":464,"markups":[{"date":"2022-03-22 19:27:27","docid":0,"fillcolor":"ffffaaff","id":466,"markups":[{"date":"2022-03-22 19:27:32","docid":0,"fillcolor":"ffff0000","id":467,"originaltext":"注意这里是理解KMP算法的关键","page":160,"textblocks":[{"first":[83.66889953613281,414.7571716308594,10.358200073242188,9.126800537109375],"last":[225.5465087890625,414.7571716308594,10.279205322265625,9.126800537109375],"length":15,"rects":[[83.66889953613281,414.7571716308594,152.1568145751953,9.126800537109375]],"start":626,"text":"注意这里是理解KMP算法的关键"}],"type":5}],"originaltext":"\"abcdex\"首字母\"a\"与后面的串\"bcdex\"中任意一个字符都不相等。也就是说，既然\"a'不与自己后面的子串中任何一字符相等，那么对于图5平1的①来说，前五位字符分别相等，意味着子串T的首字符飞'不可能与S串的第2位到第5位的字符相等","page":160,"textblocks":[{"first":[151.60890197753906,341.2341613769531,4.75360107421875,8.61981201171875],"last":[158.7668914794922,393.4571838378906,10.25360107421875,9.126800537109375],"length":123,"rects":[[151.60890197753906,341.2341613769531,300.6805877685547,8.61981201171875],[65.40889739990234,358.9771728515625,387.38050079345703,9.126800537109375],[65.91889953613281,376.2171936035156,386.8775177001953,9.126800537109375],[65.40889739990234,393.4571838378906,103.6115951538086,9.126800537109375]],"start":482,"text":"\"abcdex\"首字母\"a\"与后面的串\"bcdex\"中任意一个字符都不相\n等。也就是说，既然\"a'不与自己后面的子串中任何一字符相等，那么对于图5平1\n的①来说，前五位字符分别相等，意味着子串T的首字符飞'不可能与S串的第2\n位到第5位的字符相等"}],"type":5},{"date":"2022-03-22 19:29:04","docid":0,"fillcolor":"fffeeb73","id":468,"markups":[{"date":"2022-03-23 10:55:01","docid":0,"fillcolor":"ffffaaff","id":470,"markups":[{"date":"2022-03-23 10:55:40","docid":0,"fillcolor":"ffff0000","id":471,"markups":[{"CL":[301.9999909996989,343.49998976290254,337.4999899417165,349.99998956918745,347.49998964369325,349.99998956918745],"date":"2022-03-23 10:59:20","docid":0,"id":475,"linecolor":"ffd01a11","linewidth":7,"originaltext":"确保i不回溯","page":161,"rect":[347.49998964369325,342.4999897927048,401.4999880641702,358.99998933076887],"type":9}],"originaltext":"T的首字符飞\"与T的第二位字符f1bll、第三位字符\"c\"均不等，所以不需要做判断，图5-7-4的朴素算法步骤②③都是多余。","page":161,"textblocks":[{"first":[91.2699966430664,325.0072937011719,6.084602355957031,8.112701416015625],"last":[287.5,342.25018310546875,3.04229736328125,8.61981201171875],"length":63,"rects":[[91.2699966430664,325.0072937011719,367.6058883666992,8.112701416015625],[70.4800033569336,342.25018310546875,220.06229400634766,8.61981201171875]],"start":457,"text":"T的首字符飞\"与T的第二位字符f1bll、第三位字符\"c\"均不等，所以不需要\n做判断，图5-7-4的朴素算法步骤②③都是多余。"}],"type":5},{"date":"2022-03-23 10:55:58","docid":0,"fillcolor":"ffff0000","group":[{"date":"2022-03-23 10:55:58","docid":0,"fillcolor":"ffff0000","id":473,"originaltext":"","page":162,"textblocks":[{"first":[63.38999938964844,66.92610168457031,10.343704223632812,9.633895874023438],"last":[290.5400085449219,84.67018127441406,9.6339111328125,8.619796752929688],"length":61,"rects":[[63.38999938964844,66.92610168457031,380.2748565673828,9.633895874023438],[62.880001068115234,84.67018127441406,237.29391860961914,8.619796752929688]],"start":0,"text":"符和第五位字符也不需要比较了，肯定也是相等的一一之前比较过了，还判断什么，\n所以④⑤这两个比较得出字符相等的步骤也可以省略"}],"type":5}],"id":472,"markups":[{"CL":[323.499990358949,88.49999736249455,330.9999901354316,98.49999706447133,340.99998983740835,98.49999706447133],"date":"2022-03-23 10:59:36","docid":0,"id":476,"linecolor":"ffd01a11","linewidth":7,"originaltext":"确保j不回溯","page":162,"rect":[340.99998983740835,90.99999728798866,394.9999882578853,107.49999682605268],"type":9}],"originaltext":"因为T的首位\"a\"与T第四位的\"a\"相等，第二位的\"b\"与第五位的\"b\"相等。而在①时，第四位的\"f与第五位的αb\"已经与主串S中的相应位置比较过了，是相等的，因此可以断定，T的首字符飞\"、第二位的字符\"b\"与3的第四位字符和第五位字符也不需要比较了，肯定也是相等的一一之前比较过了，还判断什么，所以④⑤这两个比较得出字符相等的步骤也可以省略","page":161,"textblocks":[{"first":[92.29000091552734,580.05322265625,9.633903503417969,9.12677001953125],"last":[0,0,0,0],"length":119,"rects":[[92.29000091552734,580.05322265625,368.11389923095703,9.12677001953125],[73.0199966430664,597.793212890625,387.89022064208984,9.12677001953125],[73.52999877929688,614.526123046875,387.37451171875,9.6339111328125],[447.3900146484375,661.8200073242188,16.04071044921875,10.5],[447.3900146484375,661.8200073242188,16.04071044921875,10.5]],"start":992,"text":"因为T的首位\"a\"与T第四位的\"a\"相等，第二位的\"b\"与第五位的\"b\"相\n等。而在①时，第四位的\"f与第五位的αb\"已经与主串S中的相应位置比较过\n了，是相等的，因此可以断定，T的首字符飞\"、第二位的字符\"b\"与3的第四位字\n137 \n"}],"type":5}],"originaltext":"我们来看下面一个例子，假设S =\"abcabcabc\", T= \"abcabx\" ","page":161,"textblocks":[{"first":[89.23999786376953,290.533203125,10.817001342773438,9.126800537109375],"last":[380.7892761230469,290.533203125,2.54132080078125,9.126800537109375],"length":41,"rects":[[89.23999786376953,290.533203125,294.0905990600586,9.126800537109375]],"start":368,"text":"我们来看下面一个例子，假设S =\"abcabcabc\", T= \"abcabx\" "}],"type":5}],"originaltext":"有人就会问，如果T串后面也含有首字符\"a\"的字符怎么办呢?","page":161,"textblocks":[{"first":[89.23999786376953,268.7301940917969,9.633903503417969,8.61981201171875],"last":[369.7034606933594,268.7301940917969,9.57049560546875,8.61981201171875],"length":29,"rects":[[89.23999786376953,268.7301940917969,290.0339584350586,8.61981201171875]],"start":338,"text":"有人就会问，如果T串后面也含有首字符\"a\"的字符怎么办呢?"}],"type":5}],"originaltext":"5.7.1 KMP模式匹配算法原理","page":159,"textblocks":[{"first":[70.31999969482422,501.9649963378906,7.283599853515625,11.154998779296875],"last":[225.57650756835938,501.9649963378906,12.739501953125,11.154998779296875],"length":17,"rects":[[70.31999969482422,501.9649963378906,167.99600982666016,11.154998779296875]],"start":474,"text":"5.7.1 KMP模式匹配算法原理"}],"type":5},{"date":"2022-03-23 11:00:16","docid":0,"fillcolor":"fffeeb73","id":478,"markups":[{"date":"2022-03-23 11:11:26","docid":0,"fillcolor":"ffff0000","id":482,"markups":[{"date":"2022-03-23 11:11:40","docid":0,"fillcolor":"ffff0000","id":483,"originaltext":"由于T=、bcdex\"，当中没有任何重复的字符，所以j就由6变成了1。而图5-7 -4中，由于T=\"ilhcs.bx\"，前缀的\"ab\"与最后\"xn之前串的后缀\"ab\"是捆等的。因此j就由6变成了30因此，我们可以得出规律，j值的多少取决于当前字符之前的串的前后缀的相似度。","page":162,"textblocks":[{"first":[165.81179809570312,424.39019775390625,10.140899658203125,8.61981201171875],"last":[232.8800048828125,476.1101989746094,10,8.61981201171875],"length":139,"rects":[[165.81179809570312,424.39019775390625,284.95318603515625,8.61981201171875],[63.38999938964844,441.1260986328125,387.3808135986328,9.6339111328125],[63.88999938964844,458.8702087402344,386.8794403076172,8.61981201171875],[62.880001068115234,476.1101989746094,180.00000381469727,8.61981201171875]],"start":598,"text":"由于T=、bcdex\"，当中没有任何重复的字符，所以j就由6变\n成了1。而图5-7 -4中，由于T=\"ilhcs.bx\"，前缀的\"ab\"与最后\"xn之前串的后缀\n\"ab\"是捆等的。因此j就由6变成了30因此，我们可以得出规律，j值的多少取决\n于当前字符之前的串的前后缀的相似度。"}],"type":5}],"originaltext":"发现如果有相等字符，j值的变化就会不相同。也就是说，这个j值的变化与主串其实没什么关系，关键就取决于T串的结构中是否有重复的问题。","page":162,"textblocks":[{"first":[366.6000061035156,368.1101989746094,9.6339111328125,8.61981201171875],"last":[244.68556213378906,402.5902099609375,9.8511962890625,8.61981201171875],"length":67,"rects":[[366.6000061035156,368.1101989746094,84.16366577148438,8.61981201171875],[62.880001068115234,385.3501892089844,387.88498306274414,8.61981201171875],[62.880001068115234,402.5902099609375,191.65675735473633,8.61981201171875]],"start":522,"text":"发现如果有相等字\n符，j值的变化就会不相同。也就是说，这个j值的变化与主串其实没什么关系，关键\n就取决于T串的结构中是否有重复的问题。"}],"type":5}],"originaltext":"5.7.2 next数组值推导","page":163,"textblocks":[{"first":[74.33999633789062,66.92210388183594,6.8000030517578125,10.647903442382812],"last":[187.61441040039062,66.92210388183594,12.676101684570312,10.647903442382812],"length":15,"rects":[[74.33999633789062,66.92210388183594,125.95051574707031,10.647903442382812]],"start":5,"text":"5.7.2 next数组值推导"}],"title":"前后缀相似度","type":5},{"date":"2022-03-23 11:08:51","docid":0,"fillcolor":"fffeeb73","id":480,"markups":[{"date":"2022-03-28 17:33:17","docid":0,"fillcolor":"ffff0000","id":485,"originaltext":"这里也需要强调，KMP算法仅当模式与主串之间存在许多\"部分匹配m的情况下才体现出它的优势，否则两者差异并不明显。","page":166,"textblocks":[{"first":[77.07563781738281,392.44830322265625,9.633895874023438,8.61981201171875],"last":[249.57054138183594,409.6802062988281,10.039505004882812,8.61981201171875],"length":57,"rects":[[77.07563781738281,392.44830322265625,368.6207733154297,8.61981201171875],[58.81999969482422,409.6802062988281,200.79004669189453,8.61981201171875]],"start":375,"text":"这里也需要强调，KMP算法仅当模式与主串之间存在许多\"部分匹配m的情况下\n才体现出它的优势，否则两者差异并不明显。"}],"type":5}],"originaltext":"5.7.3 KMP模式匹配算法实现","page":165,"textblocks":[{"first":[76.41000366210938,136.38912963867188,6.894401550292969,10.140899658203125],"last":[231.15650939941406,136.38912963867188,12.739501953125,10.140899658203125],"length":17,"rects":[[76.41000366210938,136.38912963867188,167.4860076904297,10.140899658203125]],"start":78,"text":"5.7.3 KMP模式匹配算法实现"}],"type":5},{"date":"2022-03-28 17:41:27","docid":0,"fillcolor":"fffeeb73","id":486,"originaltext":"5.7.4 KMP模式匹配算法改进","page":166,"textblocks":[{"first":[59.16999816894531,441.1191101074219,6.894401550292969,10.140899658203125],"last":[213.9727020263672,441.1191101074219,12.676101684570312,10.140899658203125],"length":17,"rects":[[59.16999816894531,441.1191101074219,167.4788055419922,10.140899658203125]],"start":433,"text":"5.7.4 KMP模式匹配算法改进"}],"type":5},{"date":"2022-03-28 17:42:06","docid":0,"fillcolor":"fffeeb73","id":487,"originaltext":"5.7.5 nextval数组值推导","page":168,"textblocks":[{"first":[61.70000076293945,215.4921112060547,7.228000640869141,10.647903442382812],"last":[191.41259765625,215.4921112060547,12.422607421875,10.647903442382812],"length":18,"rects":[[61.70000076293945,215.4921112060547,142.13520431518555,10.647903442382812]],"start":143,"text":"5.7.5 nextval数组值推导"}],"type":5}],"page":159,"rect":[0,309.07000732421875,1,310.07000732421875],"title":"5.7 KMP模式匹配算法","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":68,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-28 17:42:40","docid":0,"fillcolor":"ffff0000","id":488,"originaltext":"串(string)是由零个或多个字符组成的有限序列，又名叫字特串。本质上，它是一种线性袤的扩展，但相对于线性表关注一个个元素来说，我们对串这种结掏更多的是关注宫子串的应用问题，如查找、替换等操作。","page":170,"textblocks":[{"first":[303.4996337890625,186.59022521972656,10.3662109375,8.619796752929688],"last":[119.0360107421875,238.81019592285156,10.521194458007812,8.619796752929688],"length":101,"rects":[[303.4996337890625,186.59022521972656,150.8138427734375,8.619796752929688],[66.93000030517578,203.82321166992188,387.89525604248047,9.126800537109375],[66.93000030517578,221.57020568847656,380.29207611083984,8.619796752929688],[66.43000030517578,238.81019592285156,63.12720489501953,8.619796752929688]],"start":151,"text":"串(string)是由零个或多个字符\n组成的有限序列，又名叫字特串。本质上，它是一种线性袤的扩展，但相对于线性表\n关注一个个元素来说，我们对串这种结掏更多的是关注宫子串的应用问题，如查找、\n替换等操作。"}],"type":5}],"page":170,"rect":[0,107.07000732421875,1,108.07000732421875],"title":"5.8 总结回顾","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":69,"linecolor":"ff59c6ff","page":170,"rect":[0,107.07000732421875,1,108.07000732421875],"title":"5.9 结尾语","type":8}],"page":147,"rect":[0,59.07000732421875,1,60.07000732421875],"title":"第5章 串","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":70,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-28 17:46:08","docid":0,"id":71,"linecolor":"ff59c6ff","page":174,"rect":[-2.0281999111175537,52.59100341796875,-1.0281999111175537,53.59100341796875],"title":"6.1 开场白","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":72,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-28 18:07:53","id":501,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-28 17:47:12","docid":0,"fillcolor":"ffff0000","id":489,"originaltext":"所以我们需要研究这种一对多的数据结构一u树气","page":174,"textblocks":[{"first":[111.62499237060547,615.0411987304688,10.285797119140625,8.61981201171875],"last":[339.34649658203125,615.0411987304688,10.774688720703125,8.61981201171875],"length":22,"rects":[[111.62499237060547,615.0411987304688,238.4961929321289,8.61981201171875]],"start":321,"text":"所以我们需要研究这种一对多的数据结构一u树气"}],"type":5},{"date":"2022-03-28 17:47:27","docid":0,"fillcolor":"ffff0000","id":490,"markups":[{"date":"2022-03-28 17:48:17","docid":0,"id":491,"imgfile":"a6a68afb04ce2dbbdf6f6b30ad2d6116.png","linecolor":"ffa0ec6f","linewidth":2,"markups":[{"date":"2022-03-28 18:15:50","docid":0,"fillcolor":"fffeeb73","id":511,"markups":[{"date":"2022-03-28 18:15:58","docid":0,"id":512,"imgfile":"1c843079580d38d510deef71fd6b6d3f.png","linecolor":"ffa0ec6f","linewidth":2,"page":175,"rect":[153.88596455559596,377.23769367547345,372.41368224739836,511.827612518769],"type":2}],"originaltext":"当然，D、G、H、l组成的树又是B为结点的子树)E、j组成的树是C为结点的子树。","page":175,"textblocks":[{"first":[138.78640747070312,347.8302001953125,9.344100952148438,8.61981201171875],"last":[132.12460327148438,366.0773010253906,9.344100952148438,8.112701416015625],"length":41,"rects":[[138.78640747070312,347.8302001953125,316.0390930175781,8.61981201171875],[66.93000030517578,366.0773010253906,74.53870391845703,8.112701416015625]],"start":276,"text":"当然，D、G、H、l组成的树又是B为结点的子树)E、j组成的树是\nC为结点的子树。"}],"type":5}],"page":175,"rect":[182.83003312404662,172.21720798228137,367.1072696765157,305.84232453996185],"type":2}],"originaltext":"树(Tree' )是n(n~O)个结点的有限集。n=O时称为空树。在任意-棵非空树中:( 1 )有且仅有-个特定的称为根(Root )的结点:(2)当n>1时，其余结点可分为m(m>O)个互不相变的有限集T1、T2、……、Tm•奠中每一个集合本身又是一槐树，并且称为棍的子树(SubTree ).如圈6-2-1所示。","page":175,"textblocks":[{"first":[107.5,87.20321655273438,8.619796752929688,9.126800537109375],"last":[320.9599914550781,150.58322143554688,4.056396484375,9.126800537109375],"length":162,"rects":[[107.5,87.20321655273438,304.2218017578125,9.126800537109375],[108,102.92318725585938,304.2274169921875,9.126800537109375],[108,118.64613342285156,303.7264404296875,9.633895874023438],[108,134.86318969726562,304.2293395996094,9.126800537109375],[107.5,150.58322143554688,217.51638793945312,9.126800537109375]],"start":17,"text":"树(Tree' )是n(n~O)个结点的有限集。n=O时称为空树。在任\n意-棵非空树中:( 1 )有且仅有-个特定的称为根(Root )的结\n点:(2)当n>1时，其余结点可分为m(m>O)个互不相变的\n有限集T1、T2、……、Tm•奠中每一个集合本身又是一槐树，并\n且称为棍的子树(SubTree ).如圈6-2-1所示。"}],"type":5},{"date":"2022-03-28 17:50:54","docid":0,"fillcolor":"ffffaaff","id":494,"markups":[{"date":"2022-03-28 17:50:41","docid":0,"fillcolor":"ffff0000","id":492,"originaltext":"1. 0.>0时根结点是唯一的，不可能存在多个根结点","page":175,"textblocks":[{"first":[86.36000061035156,540.5001831054688,6.025703430175781,8.61981201171875],"last":[318.3911437988281,540.5001831054688,10.53338623046875,8.61981201171875],"length":26,"rects":[[86.36000061035156,540.5001831054688,242.5645294189453,8.61981201171875]],"start":348,"text":"1. 0.>0时根结点是唯一的，不可能存在多个根结点"}],"type":5},{"date":"2022-03-28 17:50:43","docid":0,"fillcolor":"ffff0000","id":493,"originaltext":"2 . m>O时，子树的个数没有限制，但它们一定是互不相交的。","page":175,"textblocks":[{"first":[86.62000274658203,595.7732543945312,5.3376007080078125,9.12677001953125],"last":[363.02734375,595.7732543945312,10.31640625,9.12677001953125],"length":31,"rects":[[86.62000274658203,595.7732543945312,286.72374725341797,9.12677001953125]],"start":426,"text":"2 . m>O时，子树的个数没有限制，但它们一定是互不相交的。"}],"type":5}],"originaltext":"对于树的定义还需要强调两点:","page":175,"textblocks":[{"first":[85.69999694824219,518.7001953125,9.8511962890625,8.61981201171875],"last":[213.7655487060547,518.7001953125,9.8511962890625,8.61981201171875],"length":14,"rects":[[85.69999694824219,518.7001953125,137.916748046875,8.61981201171875]],"start":333,"text":"对于树的定义还需要强调两点:"}],"type":5}],"page":-1,"title":"定义","type":7},{"date":"2022-03-28 17:51:35","docid":0,"fillcolor":"fffeeb73","id":495,"markups":[{"date":"2022-03-28 17:58:32","docid":0,"fillcolor":"ffff0000","id":496,"originaltext":"结点拥有的子树数称为结点的度(Degree)","page":176,"textblocks":[{"first":[337.19000244140625,231.71022033691406,10.694000244140625,8.619796752929688],"last":[138.6790008544922,248.95021057128906,4.8170013427734375,8.619796752929688],"length":23,"rects":[[337.19000244140625,231.71022033691406,117.63400268554688,8.619796752929688],[67.44000244140625,248.95021057128906,76.05599975585938,8.619796752929688]],"start":47,"text":"结点拥有的子树数称为结\n点的度(Degree)"}],"type":5},{"date":"2022-03-28 18:05:49","docid":0,"fillcolor":"ffff0000","id":497,"originaltext":"度为0的结点称为叶结点(Leaf)或终端结点","page":176,"textblocks":[{"first":[155.6708984375,248.95021057128906,10.140899658203125,8.619796752929688],"last":[356.0604248046875,248.95021057128906,10.422607421875,8.619796752929688],"length":22,"rects":[[155.6708984375,248.95021057128906,210.8121337890625,8.619796752929688]],"start":71,"text":"度为0的结点称为叶结点(Leaf)或终端结点"}],"type":5},{"date":"2022-03-28 18:06:02","docid":0,"fillcolor":"ffff0000","id":498,"originaltext":"树的度是树内各结点的度的最大值","page":176,"textblocks":[{"first":[402.85369873046875,265.6831970214844,10.3944091796875,9.126800537109375],"last":[162.4658966064453,283.42730712890625,10.445098876953125,8.112701416015625],"length":16,"rects":[[402.85369873046875,265.6831970214844,51.9720458984375,9.126800537109375],[68.45999908447266,283.42730712890625,104.45099639892578,8.112701416015625]],"start":134,"text":"树的度是树\n内各结点的度的最大值"}],"type":5},{"date":"2022-03-28 18:06:08","docid":0,"fillcolor":"ffffaaff","id":499,"markups":[{"date":"2022-03-28 18:06:27","docid":0,"id":500,"imgfile":"11ba8fd6dd1d735a236ad4c055036105.png","linecolor":"ffa0ec6f","linewidth":2,"page":176,"rect":[134.10751770048802,371.44887996178335,419.6889942425344,509.898007947539],"type":2}],"originaltext":"如图6-2-4所示，因为这棵树结点的度的最大值是结点D的度，为3，所以树的度也为3。","page":176,"textblocks":[{"first":[183.722900390625,283.42730712890625,9.802902221679688,8.112701416015625],"last":[198.77000427246094,300.6701965332031,3.04229736328125,8.61981201171875],"length":43,"rects":[[183.722900390625,283.42730712890625,270.59100341796875,8.112701416015625],[67.44000244140625,300.6701965332031,134.37229919433594,8.61981201171875]],"start":151,"text":"如图6-2-4所示，因为这棵树结点的度的最大值是结点D的\n度，为3，所以树的度也为3。"}],"type":5}],"originaltext":"6.2.1结点分类","page":176,"textblocks":[{"first":[67.44000244140625,203.31912231445312,5.070503234863281,10.140899658203125],"last":[140.9622039794922,203.31912231445312,12.676101684570312,10.140899658203125],"length":9,"rects":[[67.44000244140625,203.31912231445312,86.19830322265625,10.140899658203125]],"start":13,"text":"6.2.1结点分类"}],"type":5},{"date":"2022-03-28 18:08:44","docid":0,"fillcolor":"fffeeb73","id":502,"markups":[{"date":"2022-03-28 18:10:05","docid":0,"id":503,"imgfile":"b542791b63af0d2388ceff925ee3b8cd.png","linecolor":"ffa0ec6f","linewidth":2,"page":177,"rect":[150.99155769875088,85.86740341973693,390.26252453127626,243.61257711779297],"type":2}],"originaltext":"6.2.2结点间关系","page":176,"textblocks":[{"first":[68.95999908447266,519.2020874023438,6.5915985107421875,10.64788818359375],"last":[154.8531951904297,519.2020874023438,12.473297119140625,10.64788818359375],"length":10,"rects":[[68.95999908447266,519.2020874023438,98.36649322509766,10.64788818359375]],"start":313,"text":"6.2.2结点间关系"}],"type":5},{"date":"2022-03-28 18:10:17","docid":0,"fillcolor":"fffeeb73","id":504,"markups":[{"date":"2022-03-28 18:10:26","docid":0,"fillcolor":"ffffaaff","id":505,"markups":[{"date":"2022-03-28 18:10:44","docid":0,"fillcolor":"ffff0000","id":506,"originaltext":"树中结点的最大层次称为树的深度(Dep也)或高度","page":177,"textblocks":[{"first":[328.05999755859375,313.3473205566406,10.56341552734375,8.112701416015625],"last":[168.2391815185547,330.0802001953125,10.242294311523438,8.61981201171875],"length":25,"rects":[[328.05999755859375,313.3473205566406,126.760986328125,8.112701416015625],[67.94999694824219,330.0802001953125,110.53147888183594,8.61981201171875]],"start":204,"text":"树中结点的最大层次称为树\n的深度(Dep也)或高度"}],"type":5},{"date":"2022-03-28 18:11:03","docid":0,"id":507,"imgfile":"cad17d303bf7a24c2b0809b63c7d2d3b.png","linecolor":"ffa0ec6f","linewidth":2,"page":177,"rect":[137.00192455733307,348.77602624983035,396.53373938777384,493.9787702348911],"type":2}],"originaltext":"结点的层次(LeveI)","page":177,"textblocks":[{"first":[86.19999694824219,278.36322021484375,10.242301940917969,9.126800537109375],"last":[173.91929626464844,278.36322021484375,3.5493011474609375,9.126800537109375],"length":12,"rects":[[86.19999694824219,278.36322021484375,91.26860046386719,9.126800537109375]],"start":97,"text":"结点的层次(LeveI)"}],"type":5},{"date":"2022-03-28 18:11:46","docid":0,"fillcolor":"ffff0000","id":508,"originaltext":"如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。","page":177,"textblocks":[{"first":[86.70999908447266,525.8002319335938,10.546501159667969,8.61981201171875],"last":[172.91000366210938,543.0332641601562,3.5493011474609375,9.12677001953125],"length":47,"rects":[[86.70999908447266,525.8002319335938,369.1275863647461,8.61981201171875],[68.95999908447266,543.0332641601562,107.49930572509766,9.12677001953125]],"start":280,"text":"如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有\n序树，否则称为无序树。"}],"type":5}],"originaltext":"6.2.3树的其他相关概念","page":177,"textblocks":[{"first":[67.44000244140625,250.97909545898438,6.5915985107421875,10.140899658203125],"last":[191.66270446777344,250.97909545898438,12.676101684570312,10.140899658203125],"length":13,"rects":[[67.44000244140625,250.97909545898438,136.8988037109375,10.140899658203125]],"start":83,"text":"6.2.3树的其他相关概念"}],"type":5},{"date":"2022-03-28 18:21:35","docid":0,"fillcolor":"fffeeb73","id":514,"markups":[{"date":"2022-03-28 18:20:56","docid":0,"id":513,"imgfile":"25c80da964f5295e109f2e77f261a058.png","linecolor":"ffa0ec6f","linewidth":2,"page":178,"rect":[107.0930537032674,56.92333485128628,410.04097138638423,165.94599312578373],"type":2}],"originaltext":"对比线性表与树的结构，它们有很大的不同","page":177,"textblocks":[{"first":[87.72000122070312,620.6101684570312,10.279197692871094,8.61981201171875],"last":[272.74566650390625,620.6101684570312,10.279205322265625,8.61981201171875],"length":19,"rects":[[87.72000122070312,620.6101684570312,195.30487060546875,8.61981201171875]],"start":419,"text":"对比线性表与树的结构，它们有很大的不同"}],"type":5}],"page":174,"rect":[-2.0281999111175537,393.59100341796875,-1.0281999111175537,394.59100341796875],"title":"6.2 树的定义","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":73,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-28 18:24:10","docid":0,"fillcolor":"fffeeb73","id":515,"markups":[{"date":"2022-03-28 18:24:22","docid":0,"id":517,"imgfile":"19b98a224afbca122c3d61d83430ad09.png","linecolor":"ffa0ec6f","linewidth":2,"page":178,"rect":[69.94816570708907,254.70780340236573,455.86907995309775,586.5997896539332],"type":2}],"originaltext":"相对于线性结构，树的操作就完全不同了，这里我们给出一些基本和常用操作。","page":178,"textblocks":[{"first":[86.70999908447266,234.24319458007812,10.242301940917969,9.126800537109375],"last":[431.55010986328125,234.24319458007812,9.5775146484375,9.126800537109375],"length":35,"rects":[[86.70999908447266,234.24319458007812,354.4176254272461,9.126800537109375]],"start":111,"text":"相对于线性结构，树的操作就完全不同了，这里我们给出一些基本和常用操作。"}],"type":5}],"page":178,"rect":[0,152.07000732421875,1,153.07000732421875],"title":"6.3 树的抽象数据类型","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":74,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-28 18:26:40","docid":0,"fillcolor":"fffeeb73","id":520,"markups":[{"date":"2022-03-28 18:28:40","docid":0,"fillcolor":"ffffaaff","id":522,"markups":[{"date":"2022-03-28 18:28:46","docid":0,"id":523,"imgfile":"da30c8f05e13883a2d3f52cb155f6ce1.png","linecolor":"ffa0ec6f","linewidth":2,"markups":[{"date":"2022-03-28 18:29:20","docid":0,"fillcolor":"ffff0000","id":524,"originaltext":"其中也ta是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。","page":179,"textblocks":[{"first":[92.79000091552734,492.3332214355469,9.887397766113281,9.126800537109375],"last":[152.0615997314453,511.0902099609375,9.690200805664062,8.61981201171875],"length":49,"rects":[[92.79000091552734,492.3332214355469,370.1429214477539,9.126800537109375],[74.54000091552734,511.0902099609375,87.21179962158203,8.61981201171875]],"start":548,"text":"其中也ta是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双\n亲在数组中的下标。"}],"type":5}],"page":179,"rect":[210.3268982640747,449.5978650966001,333.8215908227975,488.6723576640085],"type":2}],"originaltext":"每个结点除了知道自己是谁以外，还知道它的双亲在哪里。","page":179,"textblocks":[{"first":[273.80340576171875,415.7660827636719,10.478912353515625,9.6339111328125],"last":[146.12510681152344,434.02020263671875,10.299301147460938,8.61981201171875],"length":27,"rects":[[273.80340576171875,415.7660827636719,188.62042236328125,9.6339111328125],[74.02999877929688,434.02020263671875,82.3944091796875,8.61981201171875]],"start":481,"text":"每个结点除了知道自己是谁以外，还知道\n它的双亲在哪里。"}],"type":5},{"date":"2022-03-28 18:49:24","docid":0,"fillcolor":"ffff0000","id":525,"originaltext":"这样的存储结构，我们可以根据结点的parent指针很容易找到色的双亲结点，所用的时间复杂度为0(1)，直到p町ent为一1时，表示找到了树结点的根","page":180,"textblocks":[{"first":[79.61000061035156,566.3632202148438,10.349700927734375,9.12677001953125],"last":[378.1440734863281,583.6032104492188,10.23040771484375,9.12677001953125],"length":74,"rects":[[79.61000061035156,566.3632202148438,371.1525421142578,9.12677001953125],[61.36000061035156,583.6032104492188,327.0144805908203,9.12677001953125]],"start":376,"text":"这样的存储结构，我们可以根据结点的parent指针很容易找到色的双亲结点，所\n用的时间复杂度为0(1)，直到p町ent为一1时，表示找到了树结点的根"}],"type":5},{"date":"2022-03-28 18:49:26","docid":0,"fillcolor":"ffff0000","id":526,"markups":[{"date":"2022-03-28 18:57:47","docid":0,"fillcolor":"ffff0000","id":530,"originaltext":"这真是麻烦，能不能改进一下呢?当然可以。我们增加一个结点最左边孩子的域，不妨叫包长子域，这样就可以很容易得到结点的孩子","page":181,"textblocks":[{"first":[90.7699966430664,67.43319702148438,9.938102722167969,9.126800537109375],"last":[157.1343994140625,106.47323608398438,10.704299926757812,9.126800537109375],"length":61,"rects":[[90.7699966430664,67.43319702148438,149.07144927978516,9.126800537109375],[91.2699966430664,89.74319458007812,369.13191986083984,9.126800537109375],[71.5,106.47323608398438,96.33869934082031,9.126800537109375]],"start":7,"text":"这真是麻烦，能不能改进一下呢?\n当然可以。我们增加一个结点最左边孩子的域，不妨叫包长子域，这样就可以很\n容易得到结点的孩子"}],"type":5},{"date":"2022-03-28 18:58:04","docid":0,"fillcolor":"ffff0000","id":532,"originaltext":"另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，那我们怎么办?嗯，可以增加一个右兄弟域来体现兄弟关系","page":181,"textblocks":[{"first":[91.77999877929688,330.5902099609375,10.140899658203125,8.61981201171875],"last":[367.36572265625,347.8302001953125,10.48779296875,8.61981201171875],"length":65,"rects":[[91.77999877929688,330.5902099609375,369.132568359375,8.61981201171875],[73.0199966430664,347.8302001953125,304.8335189819336,8.61981201171875]],"start":290,"text":"另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的\n关系，那我们怎么办?嗯，可以增加一个右兄弟域来体现兄弟关系"}],"type":5}],"originaltext":"可如果我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。","page":180,"textblocks":[{"first":[398.6048889160156,583.6032104492188,10.23040771484375,9.12677001953125],"last":[314.3949890136719,601.3502197265625,10.12139892578125,8.61981201171875],"length":32,"rects":[[398.6048889160156,583.6032104492188,51.15203857421875,9.12677001953125],[61.36000061035156,601.3502197265625,263.15638732910156,8.61981201171875]],"start":451,"text":"可如果我们\n要知道结点的孩子是什么，对不起，请遍历整个结构才行。"}],"type":5}],"originaltext":"6.4.1双亲表示法","page":179,"textblocks":[{"first":[73.0199966430664,315.8791198730469,6.5915985107421875,10.140899658203125],"last":[159.72439575195312,315.8791198730469,12.676101684570312,10.140899658203125],"length":10,"rects":[[73.0199966430664,315.8791198730469,99.38050079345703,10.140899658203125]],"start":309,"text":"6.4.1双亲表示法"}],"type":5},{"date":"2022-03-28 18:58:53","docid":0,"fillcolor":"fffeeb73","id":533,"markups":[{"date":"2022-03-28 19:06:13","docid":0,"fillcolor":"ffff0000","id":537,"originaltext":"即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。","page":182,"textblocks":[{"first":[100.8092041015625,159.71322631835938,10.242301940917969,9.126800537109375],"last":[185.52798461914062,176.95321655273438,10.516494750976562,9.126800537109375],"length":47,"rects":[[100.8092041015625,159.71322631835938,347.4205322265625,9.126800537109375],[59.33000183105469,176.95321655273438,136.7144775390625,9.126800537109375]],"start":109,"text":"即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这\n种方法叫做多重链表表示法。"}],"type":5},{"date":"2022-03-28 19:06:05","docid":0,"fillcolor":"fffeeb73","id":536,"markups":[{"date":"2022-03-28 19:06:40","docid":0,"fillcolor":"fffeeb73","id":538,"markups":[{"date":"2022-03-28 19:06:45","docid":0,"id":539,"imgfile":"ea0d635bca87ea94d0815f9b87f5af34.png","linecolor":"ffa0ec6f","linewidth":2,"page":182,"rect":[99.37463541834724,271.1094422578211,419.6889942425344,309.70153368242194],"type":2},{"date":"2022-03-28 19:05:52","docid":0,"fillcolor":"ffff0000","id":535,"originaltext":"这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。","page":182,"textblocks":[{"first":[79.61000061035156,562.30322265625,10.531997680664062,9.12677001953125],"last":[313.907470703125,596.7832641601562,10.101898193359375,9.12677001953125],"length":100,"rects":[[79.61000061035156,562.30322265625,368.6201934814453,9.12677001953125],[61.36000061035156,579.5432739257812,386.87596130371094,9.12677001953125],[61.36000061035156,596.7832641601562,262.6493682861328,9.12677001953125]],"start":403,"text":"这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的\n结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的\n空间被充分利用了，这时存储结构的缺点反而变成了优点。"}],"type":5}],"originaltext":"一种是指针域的个敏就等于树的度","page":182,"textblocks":[{"first":[78.08999633789062,238.30319213867188,10.647903442382812,9.126800537109375],"last":[229.98973083496094,238.30319213867188,10.826904296875,9.126800537109375],"length":15,"rects":[[78.08999633789062,238.30319213867188,162.7266387939453,9.126800537109375]],"start":202,"text":"一种是指针域的个敏就等于树的度"}],"type":5}],"originaltext":"方案一","page":182,"textblocks":[{"first":[78.08999633789062,215.99319458007812,10.140899658203125,9.126800537109375],"last":[98.87999725341797,215.99319458007812,10.140899658203125,9.126800537109375],"length":3,"rects":[[78.08999633789062,215.99319458007812,30.93090057373047,9.126800537109375]],"start":198,"text":"方案一"}],"type":5},{"date":"2022-03-28 19:07:33","docid":0,"fillcolor":"fffeeb73","id":540,"markups":[{"date":"2022-03-28 19:07:45","docid":0,"fillcolor":"ffff0000","id":541,"originaltext":"既然很多指针域都可能为空，为什么不按需分配空间呢","page":182,"textblocks":[{"first":[80.62000274658203,618.083251953125,10.774696350097656,9.12677001953125],"last":[328.4380798339844,618.083251953125,10.774688720703125,9.12677001953125],"length":24,"rects":[[80.62000274658203,618.083251953125,258.59276580810547,9.12677001953125]],"start":504,"text":"既然很多指针域都可能为空，为什么不按需分配空间呢"}],"type":5},{"date":"2022-03-28 19:07:49","docid":0,"fillcolor":"fffeeb73","id":542,"markups":[{"date":"2022-03-28 19:16:02","docid":0,"id":544,"imgfile":"d3b9908327e3a98329f5bd8b410660d5.png","linecolor":"ffa0ec6f","linewidth":2,"page":183,"rect":[105.16344913203736,148.09715084190583,434.16102852675976,183.31243426685413],"type":2}],"originaltext":"第二种方案每个结点指针域的个数等于该结点的度","page":183,"textblocks":[{"first":[91.2699966430664,109.51612854003906,10.140899658203125,9.633895874023438],"last":[312.3759460449219,109.51612854003906,10.5369873046875,9.633895874023438],"length":22,"rects":[[91.2699966430664,109.51612854003906,231.64293670654297,9.633895874023438]],"start":14,"text":"第二种方案每个结点指针域的个数等于该结点的度"}],"type":5},{"date":"2022-03-28 19:15:49","docid":0,"fillcolor":"ffff0000","id":543,"originaltext":"这种方法克服了搜费空间的缺点，对空|司利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。","page":183,"textblocks":[{"first":[91.77999877929688,453.8002014160156,10.797103881835938,8.61981201171875],"last":[95.33000183105469,488.7873229980469,3.04229736328125,8.112701416015625],"length":76,"rects":[[91.77999877929688,453.8002014160156,368.1139221191406,8.61981201171875],[74.02999877929688,470.533203125,385.86309814453125,9.126800537109375],[73.52999877929688,488.7873229980469,24.842300415039062,8.112701416015625]],"start":226,"text":"这种方法克服了搜费空间的缺点，对空|司利用率是很高了，但是由于各个结点\n的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的\n损耗。"}],"type":5}],"originaltext":"方案二","page":183,"textblocks":[{"first":[91.2699966430664,87.71022033691406,10.309898376464844,8.619796752929688],"last":[111.8897933959961,87.71022033691406,10.309898376464844,8.619796752929688],"length":3,"rects":[[91.2699966430664,87.71022033691406,30.92969512939453,8.619796752929688]],"start":10,"text":"方案二"}],"type":5},{"date":"2022-03-28 19:17:42","docid":0,"fillcolor":"fffeeb73","id":545,"markups":[{"date":"2022-03-28 19:18:12","docid":0,"fillcolor":"ffff0000","id":546,"originaltext":"仔细观察，我们为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系。","page":183,"textblocks":[{"first":[92.29000091552734,531.3732299804688,10.140899658203125,9.12677001953125],"last":[198.77000427246094,566.8701782226562,3.04229736328125,8.61981201171875],"length":87,"rects":[[92.29000091552734,531.3732299804688,368.61673736572266,9.12677001953125],[73.52999877929688,548.6132202148438,387.3824157714844,9.12677001953125],[74.02999877929688,566.8701782226562,127.78230285644531,8.61981201171875]],"start":334,"text":"仔细观察，我们为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中\n是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立\n一个单链表体现它们的关系。"}],"type":5},{"date":"2022-03-28 19:18:51","docid":0,"fillcolor":"fffeeb73","group":[{"date":"2022-03-28 19:18:51","docid":0,"fillcolor":"fffeeb73","id":549,"originaltext":"","page":184,"textblocks":[{"first":[61.36000061035156,64.89321899414062,10.394401550292969,9.126800537109375],"last":[0,0,0,0],"length":50,"rects":[[61.36000061035156,64.89321899414062,386.8719940185547,9.126800537109375],[61.86000061035156,83.14730834960938,95.33241271972656,8.112701416015625],[61.86000061035156,83.14730834960938,95.33241271972656,8.112701416015625]],"start":0,"text":"空。然后n个头指针又组成一个线性衰，采用顺序存储结构，存放进一个一维数组\n中，如图6-4-4所示。\n"}],"type":5}],"id":548,"markups":[{"date":"2022-03-28 19:25:15","docid":0,"id":550,"imgfile":"bd1c2d740393553a3e6e388e06dc0904.png","linecolor":"ffa0ec6f","linewidth":2,"markups":[{"date":"2022-03-28 19:39:18","docid":0,"fillcolor":"ffff0000","id":622,"originaltext":"为此，设计两种结点结构，一个是孩子链表的孩子结点","page":184,"textblocks":[{"first":[81.63999938964844,319.4302062988281,9.760597229003906,8.61981201171875],"last":[319.08209228515625,319.4302062988281,10.35821533203125,8.61981201171875],"length":24,"rects":[[81.63999938964844,319.4302062988281,247.80030822753906,8.61981201171875]],"start":86,"text":"为此，设计两种结点结构，一个是孩子链表的孩子结点"}],"type":5},{"date":"2022-03-28 19:39:39","docid":0,"fillcolor":"ffff0000","id":624,"originaltext":"另一个是表头数组的表头结点","page":184,"textblocks":[{"first":[82.1500015258789,415.26019287109375,9.633903503417969,8.61981201171875],"last":[205.78797912597656,415.26019287109375,10.285797119140625,8.61981201171875],"length":13,"rects":[[82.1500015258789,415.26019287109375,133.92377471923828,8.61981201171875]],"start":206,"text":"另一个是表头数组的表头结点"}],"type":5}],"page":184,"rect":[127.35390170118286,103.23384456080731,416.79458738568934,308.73673139680693],"type":2}],"originaltext":"这就是我们要讲的孩子表示法。具体办法是，把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为币59\n空。然后n个头指针又组成一个线性衰，采用顺序存储结构，存放进一个一维数组中，如图6-4-4所示。","page":183,"textblocks":[{"first":[92.79000091552734,587.6532592773438,10.491897583007812,9.12677001953125],"last":[0,0,0,0],"length":77,"rects":[[92.79000091552734,587.6532592773438,362.5429153442383,9.12677001953125],[75.05000305175781,604.3861083984375,386.3636016845703,9.6339111328125],[448.2300109863281,664.2153930664062,13.686767578125,6.0845947265625],[448.2300109863281,664.2153930664062,13.686767578125,6.0845947265625]],"start":422,"text":"这就是我们要讲的孩子表示法。具体办法是，把每个结点的孩子结点排列起来，\n以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为\n币59\n"}],"type":5},{"date":"2022-03-28 19:44:48","docid":0,"fillcolor":"ffff0000","id":625,"originaltext":"这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。","page":185,"textblocks":[{"first":[88.2300033569336,241.3461151123047,10.531997680664062,9.633895874023438],"last":[111.55000305175781,275.8302001953125,3.5493011474609375,8.61981201171875],"length":79,"rects":[[88.2300033569336,241.3461151123047,368.6202163696289,9.633895874023438],[69.9800033569336,259.09320068359375,386.87601470947266,9.126800537109375],[69.47000122070312,275.8302001953125,45.629302978515625,8.61981201171875]],"start":192,"text":"这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需\n要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组\n循环即可。"}],"type":5}],"originaltext":"能否有更好的方法，既可以峨少空指针的浪费又能使结点结构相同。","page":183,"textblocks":[{"first":[91.2699966430664,510.0802001953125,10.358200073242188,8.61981201171875],"last":[385.59014892578125,510.0802001953125,9.904296875,8.61981201171875],"length":30,"rects":[[91.2699966430664,510.0802001953125,304.22444915771484,8.61981201171875]],"start":303,"text":"能否有更好的方法，既可以峨少空指针的浪费又能使结点结构相同。"}],"type":5}],"originaltext":"6.4 .2孩子表示法","page":182,"textblocks":[{"first":[60.34000015258789,114.58908081054688,6.591602325439453,10.140899658203125],"last":[146.54440307617188,114.58908081054688,12.676101684570312,10.140899658203125],"length":11,"rects":[[60.34000015258789,114.58908081054688,98.8805046081543,10.140899658203125]],"start":57,"text":"6.4 .2孩子表示法"}],"type":5},{"date":"2022-03-28 19:45:47","docid":0,"fillcolor":"fffeeb73","id":628,"markups":[{"date":"2022-03-28 19:45:03","docid":0,"fillcolor":"ffff0000","id":626,"originaltext":"但是，这也存在着问题，我如何知道某个结点的双亲是谁呢?比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗?当然是可以。","page":185,"textblocks":[{"first":[88.2300033569336,298.1332092285156,10.531997680664062,9.126800537109375],"last":[447.2200012207031,314.86322021484375,4.056396484375,9.126800537109375],"length":73,"rects":[[88.2300033569336,298.1332092285156,368.6202163696289,9.126800537109375],[69.47000122070312,314.86322021484375,381.806396484375,9.126800537109375]],"start":272,"text":"但是，这也存在着问题，我如何知道某个结点的双亲是谁呢?比较麻烦，需要整\n棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗?当然是可以。"}],"type":5},{"date":"2022-03-28 19:45:41","docid":0,"id":627,"imgfile":"d5bd00dcf32eea64885e099ce7b35c7a.png","linecolor":"ffa0ec6f","linewidth":2,"page":185,"rect":[114.03875040077249,347.6914789996885,420.1694403655128,571.7142686758727],"type":2}],"originaltext":"双亲孩子表示法","page":185,"textblocks":[{"first":[183.27902221679688,580.05322265625,10.561004638671875,9.12677001953125],"last":[246.64505004882812,580.05322265625,10.561004638671875,9.12677001953125],"length":7,"rects":[[183.27902221679688,580.05322265625,73.92703247070312,9.12677001953125]],"start":410,"text":"双亲孩子表示法"}],"type":5},{"date":"2022-04-09 19:02:34","docid":0,"fillcolor":"fffeeb73","id":629,"markups":[{"date":"2022-04-10 10:53:55","docid":0,"fillcolor":"ffffaaff","id":637,"markups":[{"date":"2022-04-10 10:54:01","docid":0,"id":638,"imgfile":"35d17da1ec2eaf0a32b7b02e9d094268.png","linecolor":"ffa0ec6f","linewidth":2,"markups":[{"date":"2022-04-10 10:54:46","docid":0,"fillcolor":"ffff0000","id":639,"originaltext":"这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过fistchii:l找到此结点的长子，然后再通过长子结点的rightsib找到它的二弟，接着一直下去，直到找到具体的孩子。","page":187,"textblocks":[{"first":[85.69999694824219,66.41609191894531,10.455596923828125,9.633895874023438],"last":[140.410400390625,101.40322875976562,10.4971923828125,9.126800537109375],"length":92,"rects":[[85.69999694824219,66.41609191894531,369.1188201904297,9.633895874023438],[66.93000030517578,84.16023254394531,387.89644622802734,8.619796752929688],[66.93000030517578,101.40322875976562,83.97759246826172,9.126800537109375]],"start":5,"text":"这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过fistchii:l找到\n此结点的长子，然后再通过长子结点的rightsib找到它的二弟，接着一直下去，直到\n找到具体的孩子。"}],"type":5,"uuid":"b08e7394602f5036be09780ea9e809a4"}],"page":186,"rect":[80.58738361654588,179.92780618788547,349.71883456236895,233.65272859891607],"type":2,"uuid":"991320009b64b0425fff7f0f390098b5"}],"originaltext":"任意一棵树，宫的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。","page":186,"textblocks":[{"first":[199.27000427246094,126.75611877441406,10.647903442382812,9.633895874023438],"last":[199.27000427246094,161.23023986816406,3.04229736328125,8.619796752929688],"length":77,"rects":[[199.27000427246094,126.75611877441406,252.00498962402344,9.633895874023438],[64.4000015258789,143.99319458007812,386.3652572631836,9.126800537109375],[63.88999938964844,161.23023986816406,138.42230224609375,8.619796752929688]],"start":104,"text":"任意一棵树，宫的结点的第一个孩子如果存在就是唯一\n的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的\n第一个孩子和此结点的右兄弟。"}],"type":5,"uuid":"1f04d85c14e1c517694080dc15fb9f6d"},{"date":"2022-04-10 10:55:18","docid":0,"fillcolor":"ffffaaff","id":641,"markups":[{"date":"2022-04-10 10:55:13","docid":0,"fillcolor":"ffff0000","id":640,"originaltext":"呵呵，对，如果真的有必要，完全可以再增加一个p盯ent指针域来解决快速查找双亲的问题","page":187,"textblocks":[{"first":[86.19999694824219,140.45021057128906,10.302200317382812,8.619796752929688],"last":[108.40921020507812,157.18019104003906,10.242301940917969,8.619796752929688],"length":43,"rects":[[86.19999694824219,140.45021057128906,369.63526916503906,8.619796752929688],[67.44000244140625,157.18019104003906,51.211509704589844,8.619796752929688]],"start":132,"text":"呵呵，对，如果真的有必要，完全可以再增加一个p盯ent指针域来解决快速查找\n双亲的问题"}],"type":5,"uuid":"74c0a0e6173a1116083bc3f4ad78af71"}],"originaltext":"当然，如果想找某个结点的双亲，这个表示法也是有做陷的，那怎么办呢?","page":187,"textblocks":[{"first":[150.9075927734375,101.40322875976562,10.4971923828125,9.126800537109375],"last":[93.54989624023438,118.64730834960938,8.873298645019531,8.112701416015625],"length":34,"rects":[[150.9075927734375,101.40322875976562,304.4185791015625,9.126800537109375],[66.93000030517578,118.64730834960938,35.493194580078125,8.112701416015625]],"start":97,"text":"当然，如果想找某个结点的双亲，这个表示法也是有做陷的，那怎\n么办呢?"}],"type":5,"uuid":"b3c066df6760df1cc6739c34be6b794c"},{"date":"2022-04-10 10:57:38","docid":0,"fillcolor":"ffff0000","id":642,"originaltext":"其实这个表示法的最大好处是官把一棵复杂的树变成了一棵二叉树","page":187,"textblocks":[{"first":[85.19000244140625,178.98318481445312,10.884597778320312,9.126800537109375],"last":[390.93798828125,178.98318481445312,10.64788818359375,9.126800537109375],"length":29,"rects":[[85.19000244140625,178.98318481445312,316.3958740234375,9.126800537109375]],"start":186,"text":"其实这个表示法的最大好处是官把一棵复杂的树变成了一棵二叉树"}],"type":5,"uuid":"225f2320738655108bc323fed785dc94"}],"originaltext":"6.4.3孩子兄弟表示法","page":186,"textblocks":[{"first":[63.88999938964844,64.39207458496094,6.5915985107421875,10.647903442382812],"last":[175.4466094970703,64.39207458496094,12.676101684570312,10.647903442382812],"length":12,"rects":[[63.88999938964844,64.39207458496094,124.23271179199219,10.647903442382812]],"start":4,"text":"6.4.3孩子兄弟表示法"}],"type":5,"uuid":"8a29bd10224d921a0c2e872216bdfa95"}],"page":179,"rect":[0,52.07000732421875,1,53.07000732421875],"title":"6.4 树的存储结构","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":75,"linecolor":"ff59c6ff","markups":[{"date":"2022-04-10 11:01:28","docid":0,"fillcolor":"fffeeb73","id":644,"markups":[{"date":"2022-04-10 11:06:58","docid":0,"fillcolor":"fffeeb73","id":645,"markups":[{"date":"2022-04-10 11:08:54","docid":0,"fillcolor":"fffeeb73","id":648,"originaltext":"每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点","page":189,"textblocks":[{"first":[105.9800033569336,294.0802001953125,10.43060302734375,8.61981201171875],"last":[393.4700012207031,294.0802001953125,10.309906005859375,8.61981201171875],"length":28,"rects":[[105.9800033569336,294.0802001953125,297.7999038696289,8.61981201171875]],"start":36,"text":"每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点"}],"type":5,"uuid":"bbf87dfa9558cc7b9685600597c70b69"},{"date":"2022-04-10 11:08:59","docid":0,"fillcolor":"ffff0000","id":649,"originaltext":"左子树和右子树是有顺序的","page":189,"textblocks":[{"first":[106.4800033569336,333.1202087402344,10.478897094726562,8.61981201171875],"last":[222.87554931640625,333.1202087402344,10.555694580078125,8.61981201171875],"length":12,"rects":[[106.4800033569336,333.1202087402344,126.95124053955078,8.61981201171875]],"start":103,"text":"左子树和右子树是有顺序的"}],"type":5,"uuid":"a44a032e0b9d450ae7e8d4ca3a6e66a1"},{"date":"2022-04-10 11:09:41","docid":0,"fillcolor":"ffff0000","id":651,"originaltext":"即使树中某结点只有一棵子树，也要区分它是左子树还是右子树.","page":189,"textblocks":[{"first":[107.5,389.9101867675781,10.535301208496094,8.61981201171875],"last":[400.8777770996094,389.9101867675781,10.338104248046875,8.61981201171875],"length":29,"rects":[[107.5,389.9101867675781,303.71588134765625,8.61981201171875]],"start":182,"text":"即使树中某结点只有一棵子树，也要区分它是左子树还是右子树."}],"type":5,"uuid":"a49754a8ef7df2df59bd10b39bce4e6e"},{"date":"2022-04-10 11:09:06","docid":0,"fillcolor":"fffeeb73","id":650,"originaltext":"二叉树具有五种基本形态:","page":189,"textblocks":[{"first":[87.22000122070312,559.25732421875,10.140899658203125,8.1126708984375],"last":[194.6590118408203,559.25732421875,9.679901123046875,8.1126708984375],"length":12,"rects":[[87.22000122070312,559.25732421875,117.11891174316406,8.1126708984375]],"start":301,"text":"二叉树具有五种基本形态:"}],"type":5,"uuid":"7389a53b57b470597337361dd8eac602"}],"originaltext":"6.5.1二叉树特点","page":189,"textblocks":[{"first":[66.93000030517578,243.87911987304688,7.098602294921875,10.140899658203125],"last":[153.6343994140625,243.87911987304688,12.676101684570312,10.140899658203125],"length":10,"rects":[[66.93000030517578,243.87911987304688,99.38050079345703,10.140899658203125]],"start":14,"text":"6.5.1二叉树特点"}],"type":5,"uuid":"6aa4e7198105067ad9f7ea042d25e698"},{"date":"2022-04-10 11:07:34","docid":0,"fillcolor":"fffeeb73","id":646,"markups":[{"date":"2022-04-10 11:07:55","docid":0,"fillcolor":"fffeeb73","id":647,"originaltext":"1.斜树","page":190,"textblocks":[{"first":[85.69999694824219,431.4873046875,3.8029022216796875,8.112701416015625],"last":[110.79740142822266,431.4873046875,9.887397766113281,8.112701416015625],"length":4,"rects":[[85.69999694824219,431.4873046875,34.98480224609375,8.112701416015625]],"start":307,"text":"1.斜树"}],"type":5,"uuid":"e64b7f82c4146e9fefa9e5cecac1e48c"}],"originaltext":"6.5.2特殊二叉树","page":190,"textblocks":[{"first":[66.43000030517578,363.5390930175781,5.746498107910156,10.140899658203125],"last":[153.0299835205078,363.5390930175781,12.777496337890625,10.140899658203125],"length":10,"rects":[[66.43000030517578,363.5390930175781,99.37747955322266,10.140899658203125]],"start":240,"text":"6.5.2特殊二叉树"}],"type":5,"uuid":"befdfebc3950c2ae57e44231b99b3954"}],"originaltext":"6.5二叉树的定义","page":187,"textblocks":[{"first":[186.08999633789062,520.7316284179688,8.788803100585938,15.7183837890625],"last":[320.95849609375,520.7316284179688,19.2677001953125,15.7183837890625],"length":9,"rects":[[186.08999633789062,520.7316284179688,154.13619995117188,15.7183837890625]],"start":311,"text":"6.5二叉树的定义"}],"type":5,"uuid":"387b63c2f3282bae089522352a288226"}],"page":187,"rect":[0,383.07000732421875,1,384.07000732421875],"title":"6.5 二叉树的定义","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":76,"linecolor":"ff59c6ff","page":193,"rect":[0,23.07000732421875,1,24.07000732421875],"title":"6.6 二叉树的性质","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":77,"linecolor":"ff59c6ff","page":196,"rect":[0,40.07000732421875,1,41.07000732421875],"title":"6.7 二叉树的存储结构","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":78,"linecolor":"ff59c6ff","page":198,"rect":[0,392.07000732421875,1,393.07000732421875],"title":"6.8 遍历二叉树","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":79,"linecolor":"ff59c6ff","page":211,"rect":[0,44.07000732421875,1,45.07000732421875],"title":"6.9 二叉树的建立","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":80,"linecolor":"ff59c6ff","page":212,"rect":[0,260.07000732421875,1,261.07000732421875],"title":"6.10 线索二叉树","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":81,"linecolor":"ff59c6ff","page":219,"rect":[0,36.07000732421875,1,37.07000732421875],"title":"6.11 树、森林与二叉树的转换","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":82,"linecolor":"ff59c6ff","page":224,"rect":[0,169.07000732421875,1,170.07000732421875],"title":"6.12 赫夫曼树及其应用","type":8}],"page":173,"rect":[0,97.07000732421875,1,98.07000732421875],"title":"第6章 树","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":83,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-28 17:46:08","docid":0,"id":84,"linecolor":"ff59c6ff","page":237,"rect":[0,111.07000732421875,1,112.07000732421875],"title":"7.2 图的定义","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":85,"linecolor":"ff59c6ff","page":246,"rect":[0,403.07000732421875,1,404.07000732421875],"title":"7.3 图的抽象数据类型","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":86,"linecolor":"ff59c6ff","page":247,"rect":[0,382.07000732421875,1,383.07000732421875],"title":"7.4 图的存储结构","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":87,"linecolor":"ff59c6ff","page":261,"rect":[0,278.07000732421875,1,279.07000732421875],"title":"7.5 图的遍历","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":88,"linecolor":"ff59c6ff","page":269,"rect":[0,223.07000732421875,1,224.07000732421875],"title":"7.6 最小生成树","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":89,"linecolor":"ff59c6ff","page":281,"rect":[0,225.07000732421875,1,226.07000732421875],"title":"7.7 最短路径","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":90,"linecolor":"ff59c6ff","page":294,"rect":[0,358.07000732421875,1,359.07000732421875],"title":"7.8 拓扑排序","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":91,"linecolor":"ff59c6ff","page":301,"rect":[0,275.07000732421875,1,276.07000732421875],"title":"7.9 关键路径","type":8}],"page":235,"rect":[0,74.07000732421875,1,75.07000732421875],"title":"第7章 图","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":92,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-28 17:46:08","docid":0,"id":93,"linecolor":"ff59c6ff","page":317,"rect":[0,249.07000732421875,1,250.07000732421875],"title":"8.2 查找概论","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":94,"linecolor":"ff59c6ff","page":319,"rect":[0,343.07000732421875,1,344.07000732421875],"title":"8.3 顺序表查找","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":95,"linecolor":"ff59c6ff","page":322,"rect":[0,124.07000732421875,1,125.07000732421875],"title":"8.4 有序表查找","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":96,"linecolor":"ff59c6ff","page":330,"rect":[0,321.07000732421875,1,322.07000732421875],"title":"8.5 线性索引查找","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":97,"linecolor":"ff59c6ff","page":337,"rect":[0,302.07000732421875,1,303.07000732421875],"title":"8.6 二叉排序树","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":98,"linecolor":"ff59c6ff","page":352,"rect":[0,307.07000732421875,1,308.07000732421875],"title":"8.7 平衡二叉树（AVL树）","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":99,"linecolor":"ff59c6ff","page":365,"rect":[0,273.07000732421875,1,274.07000732421875],"title":"8.8 多路查找树（B树）","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":100,"linecolor":"ff59c6ff","page":377,"rect":[0,392.07000732421875,1,393.07000732421875],"title":"8.9 散列表查找（哈希表）概述","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":101,"linecolor":"ff59c6ff","page":380,"rect":[0,368.07000732421875,1,369.07000732421875],"title":"8.10 散列函数的构造方法","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":102,"linecolor":"ff59c6ff","page":384,"rect":[0,395.07000732421875,1,396.07000732421875],"title":"8.11 处理散列冲突的方法","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":103,"linecolor":"ff59c6ff","page":389,"rect":[0,361.07000732421875,1,362.07000732421875],"title":"8.12 散列表查找实现","type":8}],"page":315,"rect":[0,87.07000732421875,1,88.07000732421875],"title":"第8章 查找","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":104,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-28 17:46:08","docid":0,"id":105,"linecolor":"ff59c6ff","page":399,"rect":[0,11.07000732421875,1,12.07000732421875],"title":"9.2 排序的基本概念与分类","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":106,"linecolor":"ff59c6ff","page":402,"rect":[0,261.07000732421875,1,262.07000732421875],"title":"9.3 冒泡排序","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":107,"linecolor":"ff59c6ff","page":408,"rect":[0,7.07000732421875,1,8.07000732421875],"title":"9.4 简单选择排序","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":108,"linecolor":"ff59c6ff","page":410,"rect":[0,98.07000732421875,1,99.07000732421875],"title":"9.5 直接插入排序","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":109,"linecolor":"ff59c6ff","page":413,"rect":[0,258.07000732421875,1,259.07000732421875],"title":"9.6 希尔排序","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":110,"linecolor":"ff59c6ff","page":420,"rect":[0,123.07000732421875,1,124.07000732421875],"title":"9.7 堆排序","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":111,"linecolor":"ff59c6ff","page":430,"rect":[0,253.07000732421875,1,254.07000732421875],"title":"9.8 归并排序","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":112,"linecolor":"ff59c6ff","page":441,"rect":[0,17.07000732421875,1,18.07000732421875],"title":"9.9 快速排序","type":8}],"page":397,"rect":[0,59.07000732421875,1,60.07000732421875],"title":"第9章 排序","type":8},{"date":"2022-02-28 17:46:08","docid":0,"id":113,"linecolor":"ff59c6ff","page":459,"rect":[0,29.07000732421875,1,30.07000732421875],"title":"关键词索引","type":8}],"maxid":651,"notelinks":[],"scalingratio":100,"title":"大话数据结构","unimportant":[{"date":"2022-02-28 18:08:08","docid":0,"hwdata":"4d7fef7b6f6596a4ca313b6540a46add.png","id":145,"linecolor":"ff5ac6ff","linewidth":1,"page":32,"rect":[184.91268920898438,326.4775085449219,189.13119506835938,334.4419250488281],"type":10},{"date":"2022-03-14 11:27:02","docid":0,"id":414,"linecolor":"ffd01a11","linewidth":7,"originaltext":"rear指向下一个元素位置，所以指向0","page":139,"parid":56,"paridx":136,"rect":[182.83003312404662,44.86330628109852,366.66006624809324,66.12415427901396],"type":11},{"date":"2022-03-28 19:32:19","docid":0,"hwdata":"76ee33098023a2e2580855252aeb9e23.point","id":554,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[272.5334167480469,389.393310546875,304.3031311035156,422.7232971191406],"type":10},{"date":"2022-03-28 19:32:26","docid":0,"hwdata":"b804973a8e8201523975dc6307334c6f.point","id":555,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[126.39826965332031,89.60335540771484,241.29501342773438,317.2767639160156],"type":10},{"date":"2022-03-28 19:32:28","docid":0,"hwdata":"849939bb0a8994aca4984183257d67cf.point","id":556,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[256.0173034667969,257.6142272949219,261.7782287597656,262.89923095703125],"type":10},{"date":"2022-03-28 19:32:28","docid":0,"hwdata":"dcfc193e6d211ecff789bb124b2eb9ec.point","id":557,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[255.71371459960938,264.013427734375,269.732666015625,279.54229736328125],"type":10},{"date":"2022-03-28 19:32:28","docid":0,"hwdata":"88f0ee77d6d1e232003475c022a45fbe.point","id":558,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[260.38922119140625,260.930419921875,265.8345031738281,265.97967529296875],"type":10},{"date":"2022-03-28 19:32:29","docid":0,"hwdata":"ce3d886c61dc44131f5d32d61f147294.point","id":559,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[258.3449401855469,264.8035888671875,267.9110412597656,276.65362548828125],"type":10},{"date":"2022-03-28 19:32:29","docid":0,"hwdata":"34921f31f6bc6641e7c5fbb7b2121be0.point","id":560,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[258.972412109375,268.46954345703125,271.4126281738281,274.23126220703125],"type":10},{"date":"2022-03-28 19:32:29","docid":0,"hwdata":"1c23076c174e2c2a518006bd133f919e.point","id":561,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[267.59478759765625,256.6038513183594,273.962890625,267.84503173828125],"type":10},{"date":"2022-03-28 19:32:30","docid":0,"hwdata":"e92fafe0f095ef08dee7b9f44edf5830.point","id":562,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[268.01983642578125,256.24114990234375,279.0837097167969,268.3243103027344],"type":10},{"date":"2022-03-28 19:32:30","docid":0,"hwdata":"afe12fcd9c3b362f3e973d2f0790fee0.point","id":563,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[270.6308288574219,260.21795654296875,284.2652282714844,275.24163818359375],"type":10},{"date":"2022-03-28 19:32:58","docid":0,"hwdata":"6ce32ee05f8cb4ad55bdd3ade561ca67.point","id":579,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[159.2078399658203,70.84624481201172,357.0494384765625,142.4780731201172],"type":10},{"date":"2022-03-28 19:32:59","docid":0,"hwdata":"e80386c6257d8bc6d357289fea1293d6.point","id":580,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[369.5655212402344,104.75930786132812,375.5895690917969,110.35518646240234],"type":10},{"date":"2022-03-28 19:33:00","docid":0,"hwdata":"5cf2f17b8d7d69e011a8b581c6713681.point","id":581,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[367.5212707519531,111.74141693115234,383.8476257324219,125.40495300292969],"type":10},{"date":"2022-03-28 19:33:00","docid":0,"hwdata":"a1f128391f7d6deb7b06acda6d5647f4.point","id":582,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[373.8564758300781,110.3294448852539,378.8684997558594,115.3294448852539],"type":10},{"date":"2022-03-28 19:33:00","docid":0,"hwdata":"14dfe8b73ddfb1195c534999583007a4.point","id":583,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[373.18853759765625,110.30354309082031,385.7502136230469,123.11212921142578],"type":10},{"date":"2022-03-28 19:33:00","docid":0,"hwdata":"2be6a2c0ef786770bba4edf0742e3ca2.point","id":584,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[384.4017028808594,106.19718170166016,390.3042907714844,117.80107116699219],"type":10},{"date":"2022-03-28 19:33:01","docid":0,"hwdata":"517a3aa5b130c61ea9c584d02597723f.point","id":585,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[384.260009765625,105.86038208007812,395.242919921875,117.82697296142578],"type":10},{"date":"2022-03-28 19:33:01","docid":0,"hwdata":"1a330d98e1524c789460b3c88d1097dc.point","id":586,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[384.2195129394531,110.16104888916016,398.197998046875,124.64067840576172],"type":10},{"date":"2022-03-28 19:33:03","docid":0,"hwdata":"736b92a9ea89dda2784544ad02a00a35.point","id":587,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[401.3630676269531,98.51557922363281,408.2776794433594,105.65039825439453],"type":10},{"date":"2022-03-28 19:33:03","docid":0,"hwdata":"ee0db22a7edb4f34661c6ebeb9a96c83.point","id":588,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[401.3226013183594,100.49750518798828,415.5926818847656,117.1015625],"type":10},{"date":"2022-03-28 19:33:04","docid":0,"hwdata":"d7763e14e9e468adc9f8664299821c46.point","id":589,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[402.3346252441406,105.64016723632812,415.3820495605469,117.65857696533203],"type":10},{"date":"2022-03-28 19:33:04","docid":0,"hwdata":"cdf61a38467c135eec8e3de5ff283b54.point","id":590,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[404.2776794433594,110.0185546875,414.3700256347656,122.27013397216797],"type":10},{"date":"2022-03-28 19:33:04","docid":0,"hwdata":"1f3af12f3042ee8b4731d9f0eb56d883.point","id":591,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[405.8159484863281,108.39933013916016,411.759033203125,125.97492218017578],"type":10},{"date":"2022-03-28 19:33:07","docid":0,"hwdata":"c8ff750fbeb40d4813c2c45d61762086.point","id":592,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[417.697021484375,99.25394439697266,426.9190368652344,121.62244415283203],"type":10},{"date":"2022-03-28 19:33:09","docid":0,"hwdata":"3d7049dba401ac05eb45debbe5afd027.point","id":593,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[425.6514587402344,98.87828063964844,430.6514587402344,104.13735961914062],"type":10},{"date":"2022-03-28 19:33:09","docid":0,"hwdata":"ba123c37190669ec4444427e7c6b3908.point","id":594,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[426.6230163574219,105.60131072998047,440.3383483886719,121.5965347290039],"type":10},{"date":"2022-03-28 19:33:12","docid":0,"hwdata":"83e76aa49a19159013ff849e525825b5.point","id":595,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[430.3876953125,100.60113525390625,439.1846618652344,119.52392578125],"type":10},{"date":"2022-03-28 19:33:13","docid":0,"hwdata":"d52e6596a6c9743b1116feecec6988dc.point","id":596,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[441.23651123046875,102.27217864990234,453.19097900390625,108.03645324707031],"type":10},{"date":"2022-03-28 19:33:13","docid":0,"hwdata":"9e88600818bc55e50239a128e679a676.point","id":597,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[446.0942077636719,97.97151947021484,451.7621154785156,113.51335906982422],"type":10},{"date":"2022-03-28 19:33:14","docid":0,"hwdata":"ad778c6f3abc65a6c317aa0228116fbc.point","id":598,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[439.3946533203125,106.67647552490234,456.2877502441406,122.6976089477539],"type":10},{"date":"2022-03-28 19:33:14","docid":0,"hwdata":"82256ed24fb8914edd0053a34b85688c.point","id":599,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[450.87091064453125,112.14298248291016,457.0650939941406,117.80107116699219],"type":10},{"date":"2022-03-28 19:35:40","docid":0,"hwdata":"5839c8721756c72d1d5bbe8e15fbd23d.point","id":600,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[283.30126953125,259.0184326171875,288.30126953125,270.6871032714844],"type":10},{"date":"2022-03-28 19:35:41","docid":0,"hwdata":"20fe2ebf5fb44b53a7fb13e966a6bdd0.point","id":601,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[284.981201171875,261.9071350097656,289.981201171875,269.8321533203125],"type":10},{"date":"2022-03-28 19:35:41","docid":0,"hwdata":"33a8ac81540cc7d815cd0e1d2dcd51a4.point","id":602,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[286.47900390625,259.3034362792969,291.53973388671875,274.586181640625],"type":10},{"date":"2022-03-28 19:35:41","docid":0,"hwdata":"ac2c03ee40183b9f72a50eb0b9b797c7.point","id":603,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[287.7743835449219,257.8655700683594,296.9356689453125,271.42547607421875],"type":10},{"date":"2022-03-28 19:35:42","docid":0,"hwdata":"47cc4c8da7a9a6e0d4343bc5ecfd8504.point","id":604,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[289.49481201171875,262.5030212402344,298.08935546875,271.21820068359375],"type":10},{"date":"2022-03-28 19:35:42","docid":0,"hwdata":"3321cba03caa0af2ce431b7f0abc737c.point","id":605,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[289.9805908203125,264.13519287109375,300.37652587890625,274.9230041503906],"type":10},{"date":"2022-03-28 19:35:43","docid":0,"hwdata":"994eccfb42fbc6263f41b871879a4b1e.point","id":606,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[299.02801513671875,252.74880981445312,305.1127624511719,258.7825622558594],"type":10},{"date":"2022-03-28 19:35:43","docid":0,"hwdata":"e3db76458bb19754ffb462e46b57b4c3.point","id":607,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[296.5181884765625,257.1012878417969,306.347412109375,274.1069030761719],"type":10},{"date":"2022-03-28 19:35:43","docid":0,"hwdata":"dab32cac004826fe5c7889c99c2726e8.point","id":608,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[300.6269836425781,261.2853698730469,308.3714599609375,276.6458435058594],"type":10},{"date":"2022-03-28 19:35:46","docid":0,"hwdata":"2a00cdfea76022999747cf32ddd4d4af.point","id":609,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[309.8970642089844,256.95880126953125,318.7142639160156,273.03173828125],"type":10},{"date":"2022-03-28 19:35:47","docid":0,"hwdata":"4e04eee4d121c78fd0ae04df5004c7a6.point","id":610,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[316.2120361328125,259.2257080078125,323.7945861816406,272.31927490234375],"type":10},{"date":"2022-03-28 19:35:47","docid":0,"hwdata":"4e6cfa160e652de1586b5e86d15976a3.point","id":611,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[315.058349609375,258.0857849121094,325.1101989746094,276.4256286621094],"type":10},{"date":"2022-03-28 19:35:47","docid":0,"hwdata":"de1c504ef205091a3518f5033d85e4b3.point","id":612,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[319.4707336425781,256.31109619140625,325.9602966308594,262.7723388671875],"type":10},{"date":"2022-03-28 19:35:47","docid":0,"hwdata":"bf738874b535aaf1f05d2303ba1e851f.point","id":613,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[326.9394226074219,258.7075500488281,333.2752685546875,273.7053527832031],"type":10},{"date":"2022-03-28 19:35:48","docid":0,"hwdata":"b96c352f528093da697ca7d0c97d85a1.point","id":614,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[324.20697021484375,261.311279296875,329.8749084472656,268.9901428222656],"type":10},{"date":"2022-03-28 19:35:48","docid":0,"hwdata":"e5071eff27ab142e7c31ed67caacce80.point","id":615,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[328.7003173828125,257.2696838378906,336.8091125488281,269.6119384765625],"type":10},{"date":"2022-03-28 19:35:49","docid":0,"hwdata":"e395c96a6752fcbf497caeae4a920662.point","id":616,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[329.4087219238281,263.3191223144531,338.1044921875,273.91259765625],"type":10},{"date":"2022-03-28 19:35:50","docid":0,"hwdata":"338fea80f4d453cba6e105fe792f9f14.point","id":617,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[339.12408447265625,256.3370056152344,352.272705078125,262.127197265625],"type":10},{"date":"2022-03-28 19:35:50","docid":0,"hwdata":"5e093fa09978ed78a01242e8bfebef0e.point","id":618,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[344.30560302734375,253.59080505371094,349.42706298828125,267.03411865234375],"type":10},{"date":"2022-03-28 19:35:50","docid":0,"hwdata":"c75d76e457761f56926d52dc0cedee71.point","id":619,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[341.4719543457031,260.5210876464844,350.63323974609375,268.25177001953125],"type":10},{"date":"2022-03-28 19:35:51","docid":0,"hwdata":"984cb921c86bf87ba5b16cccc7079ffa.point","id":620,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[340.50042724609375,262.6195983886719,354.5193786621094,275.0914001464844],"type":10},{"date":"2022-03-28 19:35:51","docid":0,"hwdata":"1f7ab1ad451214b83aa176a0a266a4cb.point","id":621,"linecolor":"ff5ac6ff","linewidth":2,"page":184,"rect":[354.7698669433594,270.806396484375,359.7698669433594,276.1173095703125],"type":10},{"date":"2022-04-10 10:49:53","docid":0,"hwdata":"155300fb15939fca8bdaf73deb8d4698.point","id":630,"linecolor":"ff5ac6ff","linewidth":1,"page":185,"rect":[279.6856384277344,528.2496337890625,288.59698486328125,532.8828125],"type":10,"uuid":"cab51de5b39766490e498e4e7a81eb2e"}]}