{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":1,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":2,"linecolor":"ff59c6ff","page":0,"rect":[90,142.9000244140625,91,143.9000244140625],"title":"1.1 c++简介","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":3,"linecolor":"ff59c6ff","page":1,"rect":[90,288.9000244140625,91,289.9000244140625],"title":"1.2 c++起源","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":4,"linecolor":"ff59c6ff","page":2,"rect":[90,271.9000244140625,91,272.9000244140625],"title":"1.3 可移植性和标准","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":5,"linecolor":"ff59c6ff","page":3,"rect":[90,396.9000244140625,91,397.9000244140625],"title":"1.4 为什么C++会成功","type":8}],"page":0,"rect":[90,88.9000244140625,91,89.9000244140625],"title":"1. C++概述","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":6,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":7,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":8,"linecolor":"ff59c6ff","page":4,"rect":[90,437.9000244140625,91,438.9000244140625],"title":"2.1.1 c++ hello world","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":9,"linecolor":"ff59c6ff","page":6,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"2.1.3 面向过程","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":10,"linecolor":"ff59c6ff","page":6,"rect":[90,315.9000244140625,91,316.9000244140625],"title":"2.1.4 面向对象","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":11,"linecolor":"ff59c6ff","page":7,"rect":[90,178.9000244140625,91,179.9000244140625],"title":"2.1.5 面向对象三大特性","type":8}],"page":4,"rect":[90,393.9000244140625,91,394.9000244140625],"title":"2.1 简单的c++程序","type":8}],"page":4,"rect":[90,339.9000244140625,91,340.9000244140625],"title":"2. C++初识","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":12,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":13,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:05:35","docid":0,"fillcolor":"ffffed99","group":[{"date":"2022-02-10 11:05:35","docid":0,"fillcolor":"ffffed99","id":150,"originaltext":"它将屏蔽全局变量。","page":8,"textblocks":[{"first":[146.63999938964844,806.989990234375,9.949996948242188,12.5],"last":[341.990966796875,81.3499984741211,10.45001220703125,13.5],"length":60,"rects":[[146.63999938964844,806.989990234375,302.22679138183594,12.5],[90,81.3499984741211,262.44097900390625,13.5]],"start":0,"text":"北京市昌平区建材城西路金燕龙办公楼一层电话：400-618-9090\n量在其作用域内具有较高的优先权，它将屏蔽全局变量。"}],"type":5}],"id":149,"originaltext":"通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变","page":7,"textblocks":[{"first":[111,737.1500244140625,10.449996948242188,13.5],"last":[0,0,0,0],"length":39,"rects":[[111,737.1500244140625,394.3284912109375,13.5],[111,737.1500244140625,394.3284912109375,13.5]],"start":395,"text":"通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变\n"}],"type":5},{"date":"2022-02-10 11:06:12","docid":0,"fillcolor":"ffffed99","id":151,"originaltext":"作用域运算符可以用来解决局部变量与全局变量的重名问题","page":8,"textblocks":[{"first":[90,316.3089904785156,10.449996948242188,13.5],"last":[352.4308166503906,316.3089904785156,10.45001220703125,13.5],"length":26,"rects":[[90,316.3089904785156,272.8808288574219,13.5]],"start":228,"text":"作用域运算符可以用来解决局部变量与全局变量的重名问题"}],"type":5}],"page":7,"rect":[90,683.9000244140625,91,684.9000244140625],"title":"3.1 ::作用域运算符","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":14,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":15,"linecolor":"ff59c6ff","page":9,"rect":[90,100.9000244140625,91,101.9000244140625],"title":"3.2.1 C++命名空间(namespace)","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":16,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:07:29","docid":0,"fillcolor":"ffffed99","id":154,"originaltext":"命名空间只能全局范围内定义","page":9,"textblocks":[{"first":[132,585.6690063476562,10.449996948242188,13.5],"last":[257.9955139160156,585.6690063476562,10.45001220703125,13.5],"length":13,"rects":[[132,585.6690063476562,136.44552612304688,13.5]],"start":417,"text":"命名空间只能全局范围内定义"}],"type":5},{"date":"2022-02-10 11:07:38","docid":0,"fillcolor":"ffffed99","id":158,"originaltext":"无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了 static，使得其可以作为内部连接","page":11,"textblocks":[{"first":[111,160.3090057373047,10.449996948242188,13.5],"last":[287.0361022949219,190.50900268554688,10.45001220703125,13.5],"length":61,"rects":[[111,160.3090057373047,394.2059631347656,13.5],[111,190.50900268554688,186.48611450195312,13.5]],"start":118,"text":"无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符\n加上了 static，使得其可以作为内部连接"}],"type":5},{"date":"2022-02-10 11:07:34","docid":0,"fillcolor":"ffffed99","id":156,"originaltext":"命名空间是开放的，即可以随时把新的成员加入已有的命名空间中","page":10,"textblocks":[{"first":[132,316.3089904785156,10.449996948242188,13.5],"last":[425.9894104003906,316.3089904785156,10.45001220703125,13.5],"length":29,"rects":[[132,316.3089904785156,304.4394226074219,13.5]],"start":194,"text":"命名空间是开放的，即可以随时把新的成员加入已有的命名空间中"}],"type":5},{"date":"2022-02-10 11:07:31","docid":0,"fillcolor":"ffffed99","id":155,"originaltext":"命名空间可嵌套命名空间","page":10,"textblocks":[{"first":[132,95.94999694824219,10.449996948242188,13.5],"last":[236.9962615966797,95.94999694824219,10.449996948242188,13.5],"length":11,"rects":[[132,95.94999694824219,115.44625854492188,13.5]],"start":36,"text":"命名空间可嵌套命名空间"}],"type":5},{"date":"2022-02-10 11:07:35","docid":0,"fillcolor":"ffffed99","id":157,"originaltext":"声明和实现可分离","page":10,"textblocks":[{"first":[132,581.468994140625,10.449996948242188,13.5],"last":[205.43760681152344,581.468994140625,10.449996948242188,13.5],"length":8,"rects":[[132,581.468994140625,83.88760375976562,13.5]],"start":379,"text":"声明和实现可分离"}],"type":5}],"page":9,"rect":[90,313.9000244140625,91,314.9000244140625],"title":"3.2.2命名空间使用语法 ","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":17,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:08:27","docid":0,"fillcolor":"ffffed99","id":160,"originaltext":"using 声明可使得指定的标识符可用","page":11,"textblocks":[{"first":[111,717.6690063476562,6.437202453613281,13.5],"last":[266.87548828125,717.6690063476562,10.45001220703125,13.5],"length":19,"rects":[[111,717.6690063476562,166.32550048828125,13.5]],"start":564,"text":"using 声明可使得指定的标识符可用"}],"type":5}],"page":11,"rect":[90,664.9000244140625,91,665.9000244140625],"title":"3.2.3 using声明","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":18,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:08:38","docid":0,"fillcolor":"ffffed99","id":161,"originaltext":"using 编译指令使整个命名空间标识符可用.","page":12,"textblocks":[{"first":[111,701.1090087890625,6.437202453613281,13.5],"last":[308.8800048828125,701.1090087890625,2.50799560546875,13.5],"length":23,"rects":[[111,701.1090087890625,200.38800048828125,13.5]],"start":605,"text":"using 编译指令使整个命名空间标识符可用."}],"type":5}],"page":12,"rect":[90,648.9000244140625,91,649.9000244140625],"title":"3.2.4 using编译指令","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":19,"linecolor":"ff59c6ff","page":13,"rect":[90,663.9000244140625,91,664.9000244140625],"title":"3.2.5 命名空间使用","type":8}],"page":8,"rect":[90,601.9000244140625,91,602.9000244140625],"title":"3.2 名字控制","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":20,"linecolor":"ff59c6ff","page":14,"rect":[90,240.9000244140625,91,241.9000244140625],"title":"3.3 全局变量检测增强","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":21,"linecolor":"ff59c6ff","page":14,"rect":[90,470.9000244140625,91,471.9000244140625],"title":"3.4 C++中所有的变量和函数都必须有类型","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":22,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:10:47","docid":0,"fillcolor":"ffffed99","id":187,"originaltext":"在 C++，不同类型的变量一般是不能直接赋值的，需要相应的强转。","page":15,"textblocks":[{"first":[90,685.5089721679688,10.449996948242188,13.5],"last":[398.63018798828125,685.5089721679688,10.45001220703125,13.5],"length":32,"rects":[[90,685.5089721679688,319.0802001953125,13.5]],"start":418,"text":"在 C++，不同类型的变量一般是不能直接赋值的，需要相应的强转。"}],"type":5}],"page":15,"rect":[90,632.9000244140625,91,633.9000244140625],"title":"3.5 更严格的类型转换","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":23,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:11:01","docid":0,"fillcolor":"ffffed99","id":188,"originaltext":"c 中定义结构体变量需要加上 struct 关键字，c++不需要。","page":16,"textblocks":[{"first":[111,342.3500061035156,5.235450744628906,13.5],"last":[372.8390808105469,342.3500061035156,10.45001220703125,13.5],"length":33,"rects":[[111,342.3500061035156,272.2890930175781,13.5]],"start":212,"text":"c 中定义结构体变量需要加上 struct 关键字，c++不需要。"}],"type":5}],"page":16,"rect":[90,288.9000244140625,91,289.9000244140625],"title":"3.6 struct类型加强","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":24,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:11:15","docid":0,"fillcolor":"ffffed99","id":189,"originaltext":"bool 类型占 1 个字节大小","page":17,"textblocks":[{"first":[111,277.8699951171875,6.6670989990234375,13.5],"last":[221.39849853515625,277.8699951171875,10.449996948242188,13.5],"length":16,"rects":[[111,277.8699951171875,120.84849548339844,13.5]],"start":161,"text":"bool 类型占 1 个字节大小"}],"type":5},{"date":"2022-02-10 11:11:19","docid":0,"fillcolor":"ffffed99","id":190,"originaltext":"给 bool 类型赋值时，非 0 值会自动转换为 true(1),0 值会自动转换 false(0)","page":17,"textblocks":[{"first":[111,309.0690002441406,10.449996948242188,13.5],"last":[453.71759033203125,309.0690002441406,3.4798583984375,13.5],"length":50,"rects":[[111,309.0690002441406,346.19744873046875,13.5]],"start":179,"text":"给 bool 类型赋值时，非 0 值会自动转换为 true(1),0 值会自动转换 false(0)"}],"type":5}],"page":17,"rect":[90,131.9000244140625,91,132.9000244140625],"title":"3.7 “新增”bool类型关键字","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":25,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:11:29","docid":0,"fillcolor":"ffffed99","id":191,"originaltext":"c++语言三目运算表达式返回值为变量本身(引用)，为左值，可以赋值。","page":18,"textblocks":[{"first":[111,128.10899353027344,5.235450744628906,13.5],"last":[432.8367919921875,128.10899353027344,10.45001220703125,13.5],"length":34,"rects":[[111,128.10899353027344,332.28680419921875,13.5]],"start":70,"text":"c++语言三目运算表达式返回值为变量本身(引用)，为左值，可以赋值。"}],"type":5}],"page":17,"rect":[90,611.9000244140625,91,612.9000244140625],"title":"3.8 三目运算符功能增强","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":26,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":27,"linecolor":"ff59c6ff","page":18,"rect":[90,599.9000244140625,91,600.9000244140625],"title":"3.9.1 const概述","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":28,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":29,"linecolor":"ff59c6ff","page":19,"rect":[90,193.9000244140625,91,194.9000244140625],"title":"3.9.2.1 C中的const ","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":30,"linecolor":"ff59c6ff","page":19,"rect":[90,503.9000244140625,91,504.9000244140625],"title":"3.8.2.1 C++中的const ","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":31,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-21 19:46:09","docid":0,"fillcolor":"fffeeb73","id":204,"markups":[{"CL":[303.77995810592927,287.8086942140939,367.8735516588581,300.52051649535065,387.8735516588581,300.52051649535065],"date":"2022-03-21 19:45:08","docid":0,"id":202,"linecolor":"ffd01a11","linewidth":7,"originaltext":".rodata区是在全局区的一部分，不仅软件不可修改而且物理不可修改","page":20,"rect":[387.8735516588581,285.85302924774675,577.2692767503036,316.1880037429545],"type":9}],"originaltext":"c 语言全局 const 会被存储到只读数据段","page":20,"textblocks":[{"first":[132,217.88999938964844,5.235443115234375,14.5],"last":[309.954833984375,217.88999938964844,10.45001220703125,14.5],"length":23,"rects":[[132,217.88999938964844,188.40484619140625,14.5]],"start":139,"text":"c 语言全局 const 会被存储到只读数据段"}],"type":5},{"date":"2022-03-21 19:46:14","docid":0,"fillcolor":"fffeeb73","id":205,"markups":[{"CL":[303.77995810592927,287.8086942140939,367.8735516588581,300.52051649535065,387.8735516588581,300.52051649535065],"date":"2022-03-21 19:45:08","docid":0,"id":214,"linecolor":"ffd01a11","linewidth":7,"originaltext":".rodata区是在全局区的一部分，不仅软件不可修改而且物理不可修改","page":20,"rect":[387.8735516588581,285.85302924774675,577.2692767503036,316.1880037429545],"type":9}],"originaltext":"c++中全局 const 当声明 extern 或者对变量取地址时，编译器会分配存储地址，变量存储在只读数据段。两个都受到了只读数据段的保护，不可修改。","page":20,"textblocks":[{"first":[331.0799865722656,217.88999938964844,5.235443115234375,14.5],"last":[268.43536376953125,280.3900146484375,10.45001220703125,13.5],"length":78,"rects":[[331.0799865722656,217.88999938964844,174.72940063476562,14.5],[132,250.19000244140625,373.327880859375,13.5],[132,280.3900146484375,146.8853759765625,13.5]],"start":163,"text":"c++中全局 const 当声明 extern 或者\n对变量取地址时，编译器会分配存储地址，变量存储在只读数据段。两个都受到了\n只读数据段的保护，不可修改。"}],"type":5},{"date":"2022-03-21 19:45:43","docid":0,"fillcolor":"fffeeb73","id":203,"markups":[{"CL":[341.2635366275836,457.95154628629894,389.82921662520533,445.56566816610007,396.34809984636263,445.56566816610007],"date":"2022-03-21 19:46:58","docid":0,"id":206,"linecolor":"ffd01a11","linewidth":7,"originaltext":"软件不可修改，物理可修改因为在栈区。","page":20,"rect":[396.67404400742043,438.3948966228271,494.1535156805482,466.12231782957195],"type":9}],"originaltext":"c 语言中局部 const 存储在堆栈区，只是不能通过变量直接修改 const 只读变量的值，但是可以跳过编译器的检查，通过指针间接修改 const 值。","page":20,"textblocks":[{"first":[132,468.54998779296875,5.235443115234375,13.5],"last":[416.27984619140625,499.75,10.45001220703125,13.5],"length":78,"rects":[[132,468.54998779296875,373.5684814453125,13.5],[132,499.75,294.7298583984375,13.5]],"start":373,"text":"c 语言中局部 const 存储在堆栈区，只是不能通过变量直接修改 const 只读变量的\n值，但是可以跳过编译器的检查，通过指针间接修改 const 值。"}],"type":5},{"date":"2022-03-21 19:47:09","docid":0,"fillcolor":"fffeeb73","id":207,"markups":[{"date":"2022-03-21 19:47:23","docid":0,"fillcolor":"fffeeb73","group":[{"date":"2022-03-21 19:47:23","docid":0,"fillcolor":"fffeeb73","id":210,"originaltext":"北京市昌平区建材城西路金燕龙办公楼一层电话：400-618-9090号表中，不分配内存，当对其取地址时，会分配内存。","page":21,"textblocks":[{"first":[146.63999938964844,806.989990234375,9.949996948242188,12.5],"last":[415.6715087890625,81.3499984741211,10.45001220703125,13.5],"length":59,"rects":[[146.63999938964844,806.989990234375,302.22679138183594,12.5],[174.24000549316406,81.3499984741211,251.8815155029297,13.5]],"start":0,"text":"北京市昌平区建材城西路金燕龙办公楼一层电话：400-618-9090\n号表中，不分配内存，当对其取地址时，会分配内存。"}],"type":5}],"id":209,"originaltext":"1.对于基础数据类型，也就是 const int a = 10 这种，编译器会把它放到符\n北京市昌平区建材城西路金燕龙办公楼一层电话：400-618-9090号表中，不分配内存，当对其取地址时，会分配内存。","page":20,"textblocks":[{"first":[153,734.8300170898438,6.1237030029296875,13.5],"last":[0,0,0,0],"length":45,"rects":[[153,734.8300170898438,352.6864929199219,13.5],[153,734.8300170898438,352.6864929199219,13.5]],"start":622,"text":"1.对于基础数据类型，也就是 const int a = 10 这种，编译器会把它放到符\n"}],"type":5},{"date":"2022-03-21 19:47:55","docid":0,"fillcolor":"fffeeb73","id":211,"originaltext":"constA 分配了内存，所以我们可以修改 constA 内存中的值。","page":21,"textblocks":[{"first":[153,534.6690063476562,5.235443115234375,13.5],"last":[431.997314453125,534.6690063476562,10.45001220703125,13.5],"length":35,"rects":[[153,534.6690063476562,289.44732666015625,13.5]],"start":478,"text":"constA 分配了内存，所以我们可以修改 constA 内存中的值。"}],"type":5},{"CL":[341.2635366275836,457.95154628629894,389.82921662520533,445.56566816610007,396.34809984636263,445.56566816610007],"date":"2022-03-21 19:46:58","docid":0,"id":215,"linecolor":"ffd01a11","linewidth":7,"originaltext":"软件不可修改，物理可修改因为在栈区。","page":20,"rect":[396.67404400742043,438.3948966228271,494.1535156805482,466.12231782957195],"type":9}],"originaltext":"c++中对于局部的 const 变量要区别对待：","page":20,"textblocks":[{"first":[132,704.3300170898438,5.235443115234375,13.5],"last":[321.7175598144531,704.3300170898438,10.45001220703125,13.5],"length":24,"rects":[[132,704.3300170898438,200.16757202148438,13.5]],"start":597,"text":"c++中对于局部的 const 变量要区别对待："}],"type":5},{"date":"2022-03-21 19:48:01","docid":0,"fillcolor":"fffeeb73","id":212,"originaltext":"3.对于自定数据类型，比如类对象，那么也会分配内存。","page":21,"textblocks":[{"first":[153,565.8699951171875,6.1237030029296875,13.5],"last":[415.4315185546875,565.8699951171875,10.45001220703125,13.5],"length":26,"rects":[[153,565.8699951171875,272.88153076171875,13.5]],"start":514,"text":"3.对于自定数据类型，比如类对象，那么也会分配内存。"}],"type":5}],"page":20,"rect":[90,163.9000244140625,91,164.9000244140625],"title":"3.8.2.3 C/C++中const异同总结","type":8}],"page":19,"rect":[90,147.9000244140625,91,148.9000244140625],"title":"3.9.2 C/C++中const的区别","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":32,"linecolor":"ff59c6ff","page":23,"rect":[90,194.9000244140625,91,195.9000244140625],"title":"3.9.3 尽量以const替换#define","type":8}],"page":18,"rect":[90,555.9000244140625,91,556.9000244140625],"title":"3.9 C/C++中的const","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":33,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":34,"linecolor":"ff59c6ff","page":25,"rect":[90,115.9000244140625,91,116.9000244140625],"title":"3.10.1 引用基本用法","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":35,"linecolor":"ff59c6ff","page":27,"rect":[90,321.9000244140625,91,322.9000244140625],"title":"3.10.2 函数中的引用","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":36,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:14:15","docid":0,"fillcolor":"ffffed99","id":192,"originaltext":"引用的本质在 c++内部实现是一个指针常量.","page":29,"textblocks":[{"first":[111,278.95001220703125,10.449996948242188,13.5],"last":[313.44000244140625,278.95001220703125,2.978240966796875,13.5],"length":22,"rects":[[111,278.95001220703125,205.41824340820312,13.5]],"start":114,"text":"引用的本质在 c++内部实现是一个指针常量."}],"type":5}],"page":29,"rect":[90,225.9000244140625,91,226.9000244140625],"title":"3.10.3 引用的本质","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":37,"linecolor":"ff59c6ff","page":29,"rect":[90,628.9000244140625,91,629.9000244140625],"title":"3.10.4 指针引用","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":38,"linecolor":"ff59c6ff","page":30,"rect":[90,570.9000244140625,91,571.9000244140625],"title":"3.10.5 常量引用","type":8}],"page":25,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"3.10 引用(reference)","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":39,"linecolor":"ff59c6ff","page":32,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"3.11 练习作业","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":40,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 19:30:19","docid":0,"id":199,"linecolor":"ffd01a11","linewidth":7,"originaltext":"在使用内联函数的每一个地方都插入该代码，因此内存会占用很多，时间会变快","page":32,"rect":[357.1793206622176,252.1975608729847,524.7021120520353,280.95135943795435],"type":11},{"date":"2022-02-10 11:03:33","docid":0,"id":41,"linecolor":"ff59c6ff","page":32,"rect":[90,284.9000244140625,91,285.9000244140625],"title":"3.12.1 内联函数的引出","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":42,"linecolor":"ff59c6ff","page":33,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"3.12.2 预处理宏的缺陷","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":43,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":44,"linecolor":"ff59c6ff","page":34,"rect":[90,116.9000244140625,91,117.9000244140625],"title":"3.12.3.1 内联函数基本概念","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":45,"linecolor":"ff59c6ff","page":34,"rect":[90,521.9000244140625,91,522.9000244140625],"title":"3.12.3.2 类内部的内联函数","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":46,"linecolor":"ff59c6ff","page":35,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"3.12.3.3 内联函数和编译器","type":8}],"page":34,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"3.12.3 内联函数","type":8}],"page":32,"rect":[90,240.9000244140625,91,241.9000244140625],"title":"3.12 内联函数(inline function)","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":47,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:16:09","docid":0,"fillcolor":"ffffed99","id":193,"originaltext":"函数的默认参数从左向右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。","page":36,"textblocks":[{"first":[132,548.1500244140625,10.449996948242188,13.5],"last":[236.9962615966797,579.3499755859375,10.449996948242188,13.5],"length":48,"rects":[[132,548.1500244140625,373.2068176269531,13.5],[132,579.3499755859375,115.44625854492188,13.5]],"start":577,"text":"函数的默认参数从左向右，如果一个参数设置了默认参数，那么这个参数之后的参\n数都必须设置默认参数。"}],"type":5}],"page":36,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"3.13 函数的默认参数","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":48,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:17:04","docid":0,"fillcolor":"ffffed99","id":194,"originaltext":"c++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明。","page":36,"textblocks":[{"first":[111,714.0689697265625,5.235450744628906,13.5],"last":[100.43984985351562,746.2689819335938,10.449996948242188,13.5],"length":42,"rects":[[111,714.0689697265625,394.4477233886719,13.5],[90,746.2689819335938,20.889846801757812,13.5]],"start":676,"text":"c++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声\n明。"}],"type":5},{"date":"2022-02-10 11:17:14","docid":0,"fillcolor":"ffffed99","id":195,"originaltext":"什么时候用，在后面我们要讲的操作符重载的后置++要用到这个.","page":37,"textblocks":[{"first":[90,440.1090087890625,10.449996948242188,13.5],"last":[389.0400085449219,440.1090087890625,2.50799560546875,13.5],"length":30,"rects":[[90,440.1090087890625,301.5480041503906,13.5]],"start":399,"text":"什么时候用，在后面我们要讲的操作符重载的后置++要用到这个."}],"type":5}],"page":36,"rect":[90,661.9000244140625,91,662.9000244140625],"title":"3.14 函数的占位参数","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":49,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":50,"linecolor":"ff59c6ff","page":37,"rect":[90,535.9000244140625,91,536.9000244140625],"title":"3.15.1 函数重载概述","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":51,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":52,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:18:04","docid":0,"fillcolor":"ffffed99","id":196,"originaltext":"同一个作用域参数个数不同参数类型不同参数顺序不同","page":38,"textblocks":[{"first":[153,496.75,10.449996948242188,13.5],"last":[205.4383544921875,591.3499755859375,10.449996948242188,13.5],"length":30,"rects":[[153,496.75,62.88835144042969,13.5],[132,527.8500366210938,83.88835144042969,14.5],[132,560.1500244140625,83.88835144042969,13.5],[132,591.3499755859375,83.88835144042969,13.5]],"start":320,"text":"同一个作用域\n参数个数不同\n参数类型不同\n参数顺序不同"}],"type":5},{"date":"2022-02-10 11:18:31","docid":0,"fillcolor":"ffffed99","id":197,"originaltext":"函数返回值不作为重载条件","page":39,"textblocks":[{"first":[152.8791046142578,425.95001220703125,10.449996948242188,13.5],"last":[268.43475341796875,425.95001220703125,10.45001220703125,13.5],"length":12,"rects":[[152.8791046142578,425.95001220703125,126.00566101074219,13.5]],"start":397,"text":"函数返回值不作为重载条件"}],"type":5}],"page":38,"rect":[90,410.9000244140625,91,411.9000244140625],"title":"3.15.2.1 函数重载基本语法","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":53,"linecolor":"ff59c6ff","markups":[{"date":"2022-07-22 13:10:43","docid":0,"fillcolor":"fffeeb73","id":217,"originaltext":"编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如 void func(); 编译器可能会将函数名修饰成_func，当编译器碰到 void func(int x),编译器可能将函数名修饰为_func_int","page":39,"textblocks":[{"first":[111,657.7899780273438,10.449996948242188,13.5],"last":[370.0776062011719,719.2899780273438,3.88739013671875,15.5],"length":132,"rects":[[111,657.7899780273438,394.2059631347656,13.5],[90,688.0899658203125,415.6892395019531,15.5],[90,719.2899780273438,283.9649963378906,15.5]],"start":616,"text":"编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数\n类型来修饰不同的函数名，比如 void func(); 编译器可能会将函数名修饰成_func，当编译\n器碰到 void func(int x),编译器可能将函数名修饰为_func_int"}],"type":5,"uuid":"b0a223efc09ade96362dabc5312e96f3"}],"page":39,"rect":[90,603.9000244140625,91,604.9000244140625],"title":"3.15.2.2 函数重载实现原理","type":8}],"page":38,"rect":[90,365.9000244140625,91,366.9000244140625],"title":"3.15.2 函数重载","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":54,"linecolor":"ff59c6ff","markups":[{"date":"2022-07-22 13:10:20","docid":0,"fillcolor":"fffeeb73","id":216,"originaltext":"如果我想在 c++调用 c 的函数怎么办？extern \"C\"的主要作用就是为了实现 c++代码能够调用其他 c 语言代码。加上 extern\"C\"后，这部分代码编译器按 c 语言的方式进行编译和链接，而不是按 c++的方式","page":40,"textblocks":[{"first":[131.99925231933594,608.468994140625,10.449996948242188,13.5],"last":[455.1582336425781,670.8699951171875,10.45001220703125,13.5],"length":114,"rects":[[131.99925231933594,608.468994140625,180.8484649658203,13.5],[111,640.3690185546875,394.6358337402344,13.5],[90,670.8699951171875,375.6082458496094,13.5]],"start":611,"text":"如果我想在 c++调用 c 的函数怎么办？\nextern \"C\"的主要作用就是为了实现 c++代码能够调用其他 c 语言代码。加上 extern\n\"C\"后，这部分代码编译器按 c 语言的方式进行编译和链接，而不是按 c++的方式"}],"type":5,"uuid":"abf5e025673fcf4a53c1c82893955fb5"}],"page":40,"rect":[90,289.9000244140625,91,290.9000244140625],"title":"3.15.3 extern “C”浅析","type":8}],"page":37,"rect":[90,491.9000244140625,91,492.9000244140625],"title":"3.15 函数重载(overload)","type":8}],"page":7,"rect":[90,629.9000244140625,91,630.9000244140625],"title":"3. C++对C的扩展","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":55,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":56,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":57,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:19:07","docid":0,"fillcolor":"ffffed99","id":198,"originaltext":"c 语言 struct 只有变量\nc++语言 struct 既有变量，也有函数","page":42,"textblocks":[{"first":[132,506.28656005859375,5.235443115234375,13.70428466796875],"last":[294.1169738769531,536.8500366210938,10.45001220703125,14.5],"length":40,"rects":[[132,506.28656005859375,104.40910339355469,13.70428466796875],[111,536.8500366210938,193.56698608398438,14.5]],"start":239,"text":"c 语言 struct 只有变量\nc++语言 struct 既有变量，也有函数"}],"type":5}],"page":42,"rect":[90,452.9000244140625,91,453.9000244140625],"title":"4.1.1 C和C++中struct区别","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":58,"linecolor":"ff59c6ff","page":42,"rect":[90,572.9000244140625,91,573.9000244140625],"title":"4.1.2 类的封装","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":59,"linecolor":"ff59c6ff","page":46,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.1.3 将成员变量设置为private","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":60,"linecolor":"ff59c6ff","page":46,"rect":[90,628.9000244140625,91,629.9000244140625],"title":"4.1.3课堂练习","type":8}],"page":42,"rect":[90,408.9000244140625,91,409.9000244140625],"title":"4.1 类和对象的基本概念","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":61,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":62,"linecolor":"ff59c6ff","page":47,"rect":[90,115.9000244140625,91,116.9000244140625],"title":"4.2.1 设计立方体类","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":63,"linecolor":"ff59c6ff","page":48,"rect":[90,631.9000244140625,91,632.9000244140625],"title":"4.2.2 点和圆的关系","type":8}],"page":47,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.2 面向对象程序设计案例","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":64,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":65,"linecolor":"ff59c6ff","page":50,"rect":[90,410.9000244140625,91,411.9000244140625],"title":"4.3.1 初始化和清理","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":66,"linecolor":"ff59c6ff","page":51,"rect":[90,334.9000244140625,91,335.9000244140625],"title":"4.3.1 构造函数和析构函数","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":67,"linecolor":"ff59c6ff","page":52,"rect":[90,491.9000244140625,91,492.9000244140625],"title":"4.3.1 构造函数的分类及调用","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":68,"linecolor":"ff59c6ff","page":54,"rect":[90,664.9000244140625,91,665.9000244140625],"title":"4.3.2 拷贝构造函数的调用时机","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":69,"linecolor":"ff59c6ff","page":57,"rect":[90,147.9000244140625,91,148.9000244140625],"title":"4.3.3 构造函数调用规则","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":70,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":71,"linecolor":"ff59c6ff","page":57,"rect":[90,468.9000244140625,91,469.9000244140625],"title":"4.3.4.1 浅拷贝","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":72,"linecolor":"ff59c6ff","page":58,"rect":[90,303.9000244140625,91,304.9000244140625],"title":"4.3.4.2 深拷贝","type":8}],"page":57,"rect":[90,423.9000244140625,91,424.9000244140625],"title":"4.3.4 深拷贝和浅拷贝","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":73,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":74,"linecolor":"ff59c6ff","page":59,"rect":[90,629.9000244140625,91,630.9000244140625],"title":"4.3.4.1 初始化列表","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":75,"linecolor":"ff59c6ff","page":60,"rect":[90,493.9000244140625,91,494.9000244140625],"title":"4.3.4.2 类对象作为成员","type":8}],"page":59,"rect":[90,584.9000244140625,91,585.9000244140625],"title":"4.3.4 多个对象构造和析构","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":76,"linecolor":"ff59c6ff","page":63,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.3.5 explicit关键字","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":77,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":78,"linecolor":"ff59c6ff","page":64,"rect":[90,379.9000244140625,91,380.9000244140625],"title":"4.3.6.1 对象创建","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":79,"linecolor":"ff59c6ff","page":64,"rect":[90,595.9000244140625,91,596.9000244140625],"title":"4.3.6.2 C动态分配内存方法","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":80,"linecolor":"ff59c6ff","page":66,"rect":[90,289.9000244140625,91,290.9000244140625],"title":"4.3.6.3 new operator ","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":81,"linecolor":"ff59c6ff","page":67,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.3.6.4 delete operator","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":82,"linecolor":"ff59c6ff","page":68,"rect":[90,351.9000244140625,91,352.9000244140625],"title":"4.3.6.5 用于数组的new和delete","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":83,"linecolor":"ff59c6ff","page":69,"rect":[90,476.9000244140625,91,477.9000244140625],"title":"4.3.6.6 delete void*可能会出错","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":84,"linecolor":"ff59c6ff","page":70,"rect":[90,399.9000244140625,91,400.9000244140625],"title":"4.3.6.7 使用new和delete采用相同形式","type":8}],"page":64,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.3.6 动态对象创建","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":85,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":86,"linecolor":"ff59c6ff","page":72,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.3.7.1 静态成员变量","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":87,"linecolor":"ff59c6ff","page":73,"rect":[90,226.9000244140625,91,227.9000244140625],"title":"4.3.7.2 静态成员函数","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":88,"linecolor":"ff59c6ff","page":74,"rect":[90,538.9000244140625,91,539.9000244140625],"title":"4.3.7.3 const静态成员属性","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":89,"linecolor":"ff59c6ff","page":75,"rect":[90,164.9000244140625,91,165.9000244140625],"title":"4.3.7.4 静态成员实现单例模式","type":8}],"page":71,"rect":[90,506.9000244140625,91,507.9000244140625],"title":"4.3.7 静态成员","type":8}],"page":50,"rect":[90,366.9000244140625,91,367.9000244140625],"title":"4.3 对象的构造和析构","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":90,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":91,"linecolor":"ff59c6ff","page":76,"rect":[90,488.9000244140625,91,489.9000244140625],"title":"4.4.1 成员变量和函数的存储 ","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":92,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":93,"linecolor":"ff59c6ff","page":78,"rect":[90,365.9000244140625,91,366.9000244140625],"title":"4.4.2.1 this指针工作原理","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":94,"linecolor":"ff59c6ff","page":80,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.4.2.2 this指针的使用","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":95,"linecolor":"ff59c6ff","page":81,"rect":[90,367.9000244140625,91,368.9000244140625],"title":"4.4.2.3 const修饰成员函数","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":96,"linecolor":"ff59c6ff","page":82,"rect":[90,336.9000244140625,91,337.9000244140625],"title":"4.4.2.4 const修饰对象(常对象)","type":8}],"page":78,"rect":[90,320.9000244140625,91,321.9000244140625],"title":"4.4.2 this指针","type":8}],"page":76,"rect":[90,444.9000244140625,91,445.9000244140625],"title":"4.4 C++面向对象模型初探","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":97,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":98,"linecolor":"ff59c6ff","page":83,"rect":[90,611.9000244140625,91,612.9000244140625],"title":"4.5.1 友元语法","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":99,"linecolor":"ff59c6ff","page":86,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.5.2 课堂练习","type":8}],"page":83,"rect":[90,304.9000244140625,91,305.9000244140625],"title":"4.5 友元","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":100,"linecolor":"ff59c6ff","page":89,"rect":[90,319.9000244140625,91,320.9000244140625],"title":"4.5 强化训练(数组类封装)","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":101,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":102,"linecolor":"ff59c6ff","page":91,"rect":[90,567.9000244140625,91,568.9000244140625],"title":"4.6.1 运算符重载基本概念","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":103,"linecolor":"ff59c6ff","page":93,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.6.2 运算符重载碰上友元函数","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":104,"linecolor":"ff59c6ff","page":93,"rect":[90,628.9000244140625,91,629.9000244140625],"title":"4.6.3 可重载的运算符","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":105,"linecolor":"ff59c6ff","page":94,"rect":[90,349.9000244140625,91,350.9000244140625],"title":"4.6.4 自增自减(++/--)运算符重载","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":106,"linecolor":"ff59c6ff","page":96,"rect":[90,679.9000244140625,91,680.9000244140625],"title":"4.6.5 指针运算符(*、->)重载","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":107,"linecolor":"ff59c6ff","page":98,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.6.6 赋值(=)运算符重载","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":108,"linecolor":"ff59c6ff","page":100,"rect":[90,398.9000244140625,91,399.9000244140625],"title":"4.6.7 等于和不等于(==、!=)运算符重载","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":109,"linecolor":"ff59c6ff","page":101,"rect":[90,459.9000244140625,91,460.9000244140625],"title":"4.6.8 函数调用符号()重载","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":110,"linecolor":"ff59c6ff","page":102,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.6.9 不要重载&&、||","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":111,"linecolor":"ff59c6ff","page":103,"rect":[90,272.9000244140625,91,273.9000244140625],"title":"4.6.10 符号重载总结","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":112,"linecolor":"ff59c6ff","page":103,"rect":[90,563.9000244140625,91,564.9000244140625],"title":"4.6.10 强化训练_字符串类封装","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":113,"linecolor":"ff59c6ff","page":108,"rect":[90,491.9000244140625,91,492.9000244140625],"title":"4.6.11 附录：运算符和结合性","type":8}],"page":91,"rect":[90,523.9000244140625,91,524.9000244140625],"title":"4.6 运算符重载","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":114,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":115,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":116,"linecolor":"ff59c6ff","page":110,"rect":[90,355.9000244140625,91,356.9000244140625],"title":"4.7.1.1 为什么需要继承","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":117,"linecolor":"ff59c6ff","page":112,"rect":[90,616.9000244140625,91,617.9000244140625],"title":"4.7.1.2 继承基本概念","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":118,"linecolor":"ff59c6ff","page":113,"rect":[90,459.9000244140625,91,460.9000244140625],"title":"4.7.1.3 派生类定义","type":8}],"page":110,"rect":[90,309.9000244140625,91,310.9000244140625],"title":"4.7.1 继承概述","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":119,"linecolor":"ff59c6ff","page":114,"rect":[90,178.9000244140625,91,179.9000244140625],"title":"4.7.2 派生类访问控制","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":120,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":121,"linecolor":"ff59c6ff","page":117,"rect":[90,317.9000244140625,91,318.9000244140625],"title":"4.7.3.1 继承中的对象模型","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":122,"linecolor":"ff59c6ff","page":118,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.7.3.2 对象构造和析构的调用原则","type":8}],"page":117,"rect":[90,272.9000244140625,91,273.9000244140625],"title":"4.7.3 继承中的构造和析构","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":123,"linecolor":"ff59c6ff","page":120,"rect":[90,335.9000244140625,91,336.9000244140625],"title":"4.7.3 继承中同名成员的处理方法","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":124,"linecolor":"ff59c6ff","page":123,"rect":[90,194.9000244140625,91,195.9000244140625],"title":"4.7.4 非自动继承的函数","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":125,"linecolor":"ff59c6ff","page":123,"rect":[90,470.9000244140625,91,471.9000244140625],"title":"4.7.5 继承中的静态成员特性","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":126,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":127,"linecolor":"ff59c6ff","page":124,"rect":[90,473.9000244140625,91,474.9000244140625],"title":"4.7.6.1 多继承概念","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":128,"linecolor":"ff59c6ff","page":125,"rect":[90,554.9000244140625,91,555.9000244140625],"title":"4.7.6.2 菱形继承和虚继承","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":129,"linecolor":"ff59c6ff","page":128,"rect":[90,147.9000244140625,91,148.9000244140625],"title":"4.7.6.3 虚继承实现原理","type":8}],"page":124,"rect":[90,428.9000244140625,91,429.9000244140625],"title":"4.7.6 多继承","type":8}],"page":110,"rect":[90,265.9000244140625,91,266.9000244140625],"title":"4.7 继承和派生","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":130,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":131,"linecolor":"ff59c6ff","page":131,"rect":[90,411.9000244140625,91,412.9000244140625],"title":"4.8.1 多态基本概念","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":132,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":133,"linecolor":"ff59c6ff","page":134,"rect":[90,116.9000244140625,91,117.9000244140625],"title":"4.8.2.1 问题抛出","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":134,"linecolor":"ff59c6ff","page":135,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.8.2.1 问题解决思路","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":135,"linecolor":"ff59c6ff","page":135,"rect":[90,553.9000244140625,91,554.9000244140625],"title":"4.8.2.1 问题解决方案(虚函数,vitual function)","type":8}],"page":134,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.8.2 向上类型转换及问题","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":136,"linecolor":"ff59c6ff","page":137,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.8.3 C++如何实现动态绑定","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":137,"linecolor":"ff59c6ff","page":141,"rect":[90,132.9000244140625,91,133.9000244140625],"title":"4.8.4 抽象基类和纯虚函数(pure virtual function)","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":138,"linecolor":"ff59c6ff","page":144,"rect":[90,179.9000244140625,91,180.9000244140625],"title":"4.8.5 纯虚函数和多继承","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":139,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":140,"linecolor":"ff59c6ff","page":144,"rect":[90,547.9000244140625,91,548.9000244140625],"title":"4.8.6.1 虚析构函数作用","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":141,"linecolor":"ff59c6ff","page":145,"rect":[90,523.9000244140625,91,524.9000244140625],"title":"4.8.6.2 纯虚析构函数","type":8}],"page":144,"rect":[90,502.9000244140625,91,503.9000244140625],"title":"4.8.6 虚析构函数","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":142,"linecolor":"ff59c6ff","page":146,"rect":[90,476.9000244140625,91,477.9000244140625],"title":"4.8.7 重写 重载 重定义","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":143,"linecolor":"ff59c6ff","markups":[{"date":"2022-02-10 11:03:33","docid":0,"id":144,"linecolor":"ff59c6ff","page":147,"rect":[90,551.9000244140625,91,552.9000244140625],"title":"4.8.8.1 指向成员变量的指针","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":145,"linecolor":"ff59c6ff","page":149,"rect":[90,71.9000244140625,91,72.9000244140625],"title":"4.8.8.2 指向成员函数的指针","type":8},{"date":"2022-02-10 11:03:33","docid":0,"id":146,"linecolor":"ff59c6ff","page":150,"rect":[90,148.9000244140625,91,149.9000244140625],"title":"4.8.8.3 指向静态成员的指针","type":8}],"page":147,"rect":[90,506.9000244140625,91,507.9000244140625],"title":"4.8.8 指向类成员的指针","type":8}],"page":131,"rect":[90,367.9000244140625,91,368.9000244140625],"title":"4.8 多态","type":8}],"page":42,"rect":[90,354.9000244140625,91,355.9000244140625],"title":"4. 类和对象","type":8}],"maxid":219,"notelinks":[],"scalingratio":100,"title":"C++Day1讲义（基础的补充）","unimportant":[{"date":"2022-02-10 11:10:27","docid":0,"hwdata":"5d32805dc58909f3464784724cc61ae1.png","id":165,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[197.69610595703125,300.6836242675781,210.88522338867188,304.9447937011719],"type":10},{"date":"2022-02-10 11:10:27","docid":0,"hwdata":"f015a7e17d49f6b2bc9aa8e37b2ad976.png","id":166,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[198.5897979736328,301.86944580078125,207.95294189453125,312.190185546875],"type":10},{"date":"2022-02-10 11:10:28","docid":0,"hwdata":"bd9af7a50f6820d734ceff47bfe2eebc.png","id":167,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[202.37908935546875,306.4317932128906,205.37908935546875,315.12957763671875],"type":10},{"date":"2022-02-10 11:10:28","docid":0,"hwdata":"61e970de9e00a6c35aad3b931c023669.png","id":168,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[206.615234375,304.7736511230469,209.615234375,308.6830139160156],"type":10},{"date":"2022-02-10 11:10:28","docid":0,"hwdata":"aa40cd6b22ca781b74efbbb34fb93a19.png","id":169,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[211.85231018066406,297.58343505859375,216.33680725097656,306.28125],"type":10},{"date":"2022-02-10 11:10:28","docid":0,"hwdata":"0111278b1acc672bb15dd0b594b8cc80.png","id":170,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[217.10726928710938,298.1311340332031,220.10726928710938,303.04541015625],"type":10},{"date":"2022-02-10 11:10:29","docid":0,"hwdata":"8d4d5f8599487940be6360e830ab5367.png","id":171,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[211.19097900390625,307.77838134765625,214.2267303466797,314.6572570800781],"type":10},{"date":"2022-02-10 11:10:29","docid":0,"hwdata":"6e4819163aed65defc71ae2fa432c25d.png","id":172,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[212.71026611328125,305.3766174316406,219.5362548828125,316.5013122558594],"type":10},{"date":"2022-02-10 11:10:29","docid":0,"hwdata":"827da843eb50a56cc7efd8e0b5217ba2.png","id":173,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[213.01412963867188,306.0448913574219,221.6453857421875,313.245361328125],"type":10},{"date":"2022-02-10 11:10:30","docid":0,"hwdata":"b2de39d268313114bd69bcf0177200b9.png","id":174,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[219.77049255371094,298.5833435058594,226.29261779785156,314.0894775390625],"type":10},{"date":"2022-02-10 11:10:31","docid":0,"hwdata":"996465edc4fc995cc68bc75493ef1f7a.png","id":175,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[227.956787109375,295.5987243652344,239.32276916503906,314.8984680175781],"type":10},{"date":"2022-02-10 11:10:31","docid":0,"hwdata":"c561057aae095704df0d70fb68c00a24.png","id":176,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[231.5137176513672,306.2760009765625,239.7517547607422,316.43597412109375],"type":10},{"date":"2022-02-10 11:10:32","docid":0,"hwdata":"c1e4e80923a4a0bb55dddb100c5035d0.png","id":177,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[242.57772827148438,295.2721252441406,251.208984375,304.71356201171875],"type":10},{"date":"2022-02-10 11:10:32","docid":0,"hwdata":"7480f2ecbb898433d495b40fd74928cf.png","id":178,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[244.09701538085938,301.15594482421875,248.7056884765625,310.2406311035156],"type":10},{"date":"2022-02-10 11:10:32","docid":0,"hwdata":"adfc272f8eabb2101c3683483c52b158.png","id":179,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[244.18638610839844,303.5677490234375,260.1102294921875,315.7124328613281],"type":10},{"date":"2022-02-10 11:10:33","docid":0,"hwdata":"246a6d82f404096bff8f23be6f29cd71.png","id":180,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[259.2720642089844,299.0506286621094,268.60040283203125,304.331787109375],"type":10},{"date":"2022-02-10 11:10:34","docid":0,"hwdata":"203e7d32ba2454ab6c04d7985b728255.png","id":181,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[264.8487548828125,294.0310363769531,268.9390563964844,304.9999694824219],"type":10},{"date":"2022-02-10 11:10:34","docid":0,"hwdata":"fdc38378a72bf8dc4137111b06229ddd.png","id":182,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[262.3642578125,302.8140563964844,271.1385192871094,311.3711853027344],"type":10},{"date":"2022-02-10 11:10:34","docid":0,"hwdata":"e9dffced11a9bb682a3b0112defcd549.png","id":183,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[263.293701171875,305.35650634765625,267.7772521972656,317.7825927734375],"type":10},{"date":"2022-02-10 11:10:35","docid":0,"hwdata":"bab50dae9efc0fc8566a15b3f5903a4e.png","id":184,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[275.7340087890625,301.2765197753906,278.89581298828125,310.1300964355469],"type":10},{"date":"2022-02-10 11:10:35","docid":0,"hwdata":"21b4a26c60b3b879bccb69f7307787f3.png","id":185,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[277.9146423339844,295.8047180175781,296.7341003417969,317.7172546386719],"type":10},{"date":"2022-02-10 11:10:36","docid":0,"hwdata":"8c533935578d3f877dfbefcbe6f0921d.png","id":186,"linecolor":"ff5ac6ff","linewidth":1,"page":14,"rect":[287.0482482910156,303.46221923828125,297.4669189453125,309.8989562988281],"type":10}]}