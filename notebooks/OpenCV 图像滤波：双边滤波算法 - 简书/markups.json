{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-04-21 10:26:19","docid":0,"fillcolor":"fffeeb73","id":1,"originaltext":"OpenCV 图像滤波：双边滤波算法","page":0,"textblocks":[{"first":[54.02418518066406,146.8389129638672,11.791183471679688,20.180923461914062],"last":[272.12286376953125,146.8389129638672,15.640106201171875,20.180923461914062],"length":18,"rects":[[54.02418518066406,146.8389129638672,233.73878479003906,20.180923461914062]],"start":81,"text":"OpenCV 图像滤波：双边滤波算法"}],"type":5,"uuid":"923d9f062da753a00024589c18440fde"},{"date":"2022-04-21 10:26:31","docid":0,"fillcolor":"fffeeb73","id":2,"originaltext":"双边滤波算法本质是基于高斯滤波，目的是解决高斯滤波造成的边缘模糊。那么算法的做法就是想办法去“推断”出当前像素是否是边缘点或者接近边缘的点","page":0,"textblocks":[{"first":[54.02418518066406,318.74755859375,8.34139633178711,11.5],"last":[268.84771728515625,333.8663330078125,8.341400146484375,11.5],"length":70,"rects":[[54.02418518066406,318.74755859375,341.99720764160156,11.5],[54.02418518066406,333.8663330078125,223.16493225097656,11.5]],"start":324,"text":"双边滤波算法本质是基于高斯滤波，目的是解决高斯滤波造成的边缘模糊。那么算法的做法就\n是想办法去“推断”出当前像素是否是边缘点或者接近边缘的点"}],"type":5,"uuid":"171f810d20642952caae200f1520a20e"},{"date":"2022-04-21 10:26:54","docid":0,"fillcolor":"fffeeb73","id":3,"originaltext":"可以看到，它取决于被卷积像素的灰度值和邻域像素的灰度值的差。我们知道，边缘会有较大的灰度变化，而这个公式就会使边缘和边缘另一边的区域生成比较小的权值，与被卷积像素的灰度值类似的区域会生成比较大的权值，就像之前图中的一个“断崖”。","page":2,"textblocks":[{"first":[54.02418518066406,65.8990478515625,8.34139633178711,11.5],"last":[302.2132873535156,96.1365966796875,8.341400146484375,11.5],"length":116,"rects":[[54.02418518066406,65.8990478515625,341.99720764160156,11.5],[54.02418518066406,81.017822265625,341.99720764160156,11.5],[54.02418518066406,96.1365966796875,256.53050231933594,11.5]],"start":85,"text":"可以看到，它取决于被卷积像素的灰度值和邻域像素的灰度值的差。我们知道，边缘会有较大\n的灰度变化，而这个公式就会使边缘和边缘另一边的区域生成比较小的权值，与被卷积像素的\n灰度值类似的区域会生成比较大的权值，就像之前图中的一个“断崖”。"}],"type":5,"uuid":"e0c9e62b28a10ee7a86e651686fa2948"}],"maxid":3,"notelinks":[],"title":"OpenCV 图像滤波：双边滤波算法 - 简书","unimportant":[]}