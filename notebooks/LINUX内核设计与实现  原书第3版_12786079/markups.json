{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":5,"linecolor":"ff59c6ff","page":0,"rect":[0,0.239990234375,1,1.239990234375],"title":"封面页","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":6,"linecolor":"ff59c6ff","page":2,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"书名页","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":7,"linecolor":"ff59c6ff","page":3,"rect":[0,0.239990234375,1,1.239990234375],"title":"版权页","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":8,"linecolor":"ff59c6ff","page":4,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"前言页","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":9,"linecolor":"ff59c6ff","page":11,"rect":[0,0.239990234375,1,1.239990234375],"title":"目录页","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":10,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":11,"linecolor":"ff59c6ff","page":18,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"1.1  Unix的历史","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":12,"linecolor":"ff59c6ff","page":19,"rect":[0,0.239990234375,1,1.239990234375],"title":"1.2追寻Linus足迹：Linux简介","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":13,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-13 15:09:36","docid":0,"fillcolor":"fffeeb73","id":421,"originaltext":"通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序共同组成","page":21,"textblocks":[{"first":[276.83233642578125,169.20004272460938,10.314208984375,8.399993896484375],"last":[255.83006286621094,199.44003295898438,10.343490600585938,8.160003662109375],"length":83,"rects":[[276.83233642578125,169.20004272460938,195.969970703125,8.399993896484375],[49.21000289916992,184.32003784179688,423.6035346984863,8.399993896484375],[48.96000289916992,199.44003295898438,217.21355056762695,8.160003662109375]],"start":276,"text":"通常一个内核由负责响应中断的中断服务程\n序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程\n序和网络、进程间通信等系统服务程序共同组成"}],"type":5,"uuid":"24d99a9ee43a557b92473e311067f9dc"},{"date":"2023-07-14 16:16:37","docid":0,"fillcolor":"fffeeb73","id":424,"originaltext":"当一个应用程序执行一条系统调用，我们说内核正在代其执行。如果进一步解释，在这种情况下，应用程序被称为通过系统调用在内核空间运行，而内核被称为运行千进程上下文中。这种交互关系一—应用程序通过系统调用界面陷入内核一是应用程序完成其工作的基本行为方式。","page":21,"textblocks":[{"first":[412.16375732421875,394.5600280761719,10.226104736328125,8.160003662109375],"last":[375.4910888671875,439.6800231933594,10.1890869140625,8.399993896484375],"length":126,"rects":[[412.16375732421875,394.5600280761719,61.35662841796875,8.160003662109375],[49.69000244140625,409.4300231933594,423.8428955078125,8.399993896484375],[49.44000244140625,424.8000183105469,423.3597412109375,8.160003662109375],[49.44000244140625,439.6800231933594,336.24017333984375,8.399993896484375]],"start":903,"text":"当一个应用程\n序执行一条系统调用，我们说内核正在代其执行。如果进一步解释，在这种情况下，应用程序被\n称为通过系统调用在内核空间运行，而内核被称为运行千进程上下文中。这种交互关系一—应用\n程序通过系统调用界面陷入内核一是应用程序完成其工作的基本行为方式。"}],"type":5,"uuid":"cd83192aa95e8e72e7ea3a8e410a879a"}],"page":20,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"1.3操作系统和内核简介","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":14,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-17 10:27:05","docid":0,"fillcolor":"fffeeb73","id":425,"originaltext":"所谓单内核就是把它从整体上作为一个单独的大过程来实现\n另一方面，微内核并不作为一个单独的大过程来实现","page":23,"textblocks":[{"first":[79.87319946289062,131.51998901367188,10.056602478027344,8.399993896484375],"last":[331.2882385253906,131.51998901367188,10.056610107421875,8.399993896484375],"length":26,"rects":[[79.87319946289062,131.51998901367188,261.4716491699219,8.399993896484375]],"start":107,"text":"所谓单内核就是把它从整体上作为一个单独的大过程来实现"},{"first":[82.07999420166016,206.6300048828125,10.25689697265625,8.399993896484375],"last":[307.73175048828125,206.6300048828125,10.25689697265625,8.399993896484375],"length":23,"rects":[[82.07999420166016,206.6300048828125,235.90865325927734,8.399993896484375]],"start":316,"text":"另一方面，微内核并不作为一个单独的大过程来实现"}],"type":5,"uuid":"63e55d182b02bed3d89af479c1b23dc2"},{"date":"2023-07-17 10:27:37","docid":0,"fillcolor":"fffeeb73","id":426,"originaltext":"Linux是一个单内核，也就是说，Linux内核运行在单独的内核地址空间上。不过，Linux汲取了微内核的精华：其引以为豪的是模块化设计、抢占式内核、支持内核线程以及动态装载内核模块的能力。","page":23,"textblocks":[{"first":[81.1199951171875,401.75,4.800102233886719,8.399993896484375],"last":[137.31442260742188,431.9900207519531,9.634307861328125,8.399993896484375],"length":97,"rects":[[81.1199951171875,401.75,392.1600036621094,8.399993896484375],[60.2400016784668,416.8800048828125,412.55986404418945,8.399993896484375],[60.2400016784668,431.9900207519531,86.7087287902832,8.399993896484375]],"start":869,"text":"Linux是一个单内核，也就是说，Linux内核运行在单独的内核地址空间上。不过，Linux\n汲取了微内核的精华：其引以为豪的是模块化设计、抢占式内核、支持内核线程以及动态装\n载内核模块的能力。"}],"type":5,"uuid":"f65e73617d886477fcf9941fe8c2df2c"},{"date":"2023-07-17 10:28:32","docid":0,"fillcolor":"fffeeb73","id":427,"originaltext":"• Linux支持动态加载内核模块。","page":23,"textblocks":[{"first":[70.39999389648438,558,3.4300003051757812,8.4000244140625],"last":[206.1420135498047,558,10.246200561523438,8.4000244140625],"length":18,"rects":[[70.39999389648438,558,145.98822021484375,8.4000244140625]],"start":1257,"text":"• Linux支持动态加载内核模块。"}],"type":5,"uuid":"dc8514f10dc933080633429bb4aafad7"},{"date":"2023-07-17 10:28:35","docid":0,"fillcolor":"fffeeb73","id":428,"originaltext":"• Linux支持对称多处理(SMP)机制","page":23,"textblocks":[{"first":[70.39999389648438,588.0000610351562,3.4300003051757812,8.15997314453125],"last":[226.6286163330078,588.0000610351562,10.148605346679688,8.15997314453125],"length":21,"rects":[[70.39999389648438,588.0000610351562,166.37722778320312,8.15997314453125]],"start":1317,"text":"• Linux支持对称多处理(SMP)机制"}],"type":5,"uuid":"17a994e0e768d342e27ccded1e0583e2"},{"date":"2023-07-17 10:28:52","docid":0,"fillcolor":"fffeeb73","id":429,"originaltext":" Linux内核可以抢占(preemptive)","page":24,"textblocks":[{"first":[75.00499725341797,76.31999206542969,2.4250030517578125,7.9199981689453125],"last":[221.7611541748047,76.31999206542969,4.5601043701171875,7.9199981689453125],"length":24,"rects":[[75.00499725341797,76.31999206542969,151.3162612915039,7.9199981689453125]],"start":14,"text":" Linux内核可以抢占(preemptive)"}],"type":5,"uuid":"e98ff5d262fc5fa862350e067bdbd1f6"},{"date":"2023-07-17 10:29:07","docid":0,"fillcolor":"fffeeb73","id":430,"originaltext":" Linux对线程支持的实现比较有意思：内核并不区分线程和其他的一般进程。对于内核来说，所有的进程都一样一只不过是其中的一些共享资源而已。","page":24,"textblocks":[{"first":[75.2449951171875,121.1899642944336,2.4250030517578125,8.400001525878906],"last":[343.31695556640625,136.31997680664062,10.204498291015625,8.399993896484375],"length":70,"rects":[[75.2449951171875,121.1899642944336,398.7571716308594,8.400001525878906],[78,136.31997680664062,275.5214538574219,8.399993896484375]],"start":132,"text":" Linux对线程支持的实现比较有意思：内核并不区分线程和其他的一般进程。对于内核来\n说，所有的进程都一样一只不过是其中的一些共享资源而已。"}],"type":5,"uuid":"c15549c77f1f8eee2143a20672349967"},{"date":"2023-07-17 10:29:32","docid":0,"fillcolor":"fffeeb73","id":431,"originaltext":"• Linux提供具有设备类的面向对象的设备模型、热插拔事件，以及用户空间的设备文件系统(sysfs)。","page":24,"textblocks":[{"first":[71.8499984741211,151.19996643066406,3.3949966430664062,8.639999389648438],"last":[124.79999542236328,167.03988647460938,2.4000015258789062,7.440093994140625],"length":53,"rects":[[71.8499984741211,151.19996643066406,401.9113235473633,8.639999389648438],[78,167.03988647460938,49.19999694824219,7.440093994140625]],"start":203,"text":"• Linux提供具有设备类的面向对象的设备模型、热插拔事件，以及用户空间的设备文件系\n统(sysfs)。"}],"type":5,"uuid":"8c7de88ededa0e34527136d08a46289b"}],"page":22,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"1.4  Linux内核和传统Unix内核的比较","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":15,"linecolor":"ff59c6ff","page":24,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"1.5  Linux内核版本","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":16,"linecolor":"ff59c6ff","page":25,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"1.6  Linux内核开发者社区","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":17,"linecolor":"ff59c6ff","page":25,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"1.7小结","type":8}],"page":18,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"第1章  Linux内核简介","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":18,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":19,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":20,"linecolor":"ff59c6ff","page":27,"rect":[0,0.239990234375,1,1.239990234375],"title":"2.1.1使用Git","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":21,"linecolor":"ff59c6ff","page":27,"rect":[0,0.239990234375,1,1.239990234375],"title":"2.1.2安装内核源代码","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":22,"linecolor":"ff59c6ff","page":28,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"2.1.3使用补丁","type":8}],"page":27,"rect":[0,0.239990234375,1,1.239990234375],"title":"2.1获取内核源码","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":23,"linecolor":"ff59c6ff","page":28,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"2.2内核源码树","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":24,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":25,"linecolor":"ff59c6ff","page":29,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"2.3.1配置内核","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":26,"linecolor":"ff59c6ff","page":31,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"2.3.2减少编译的垃圾信息","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":27,"linecolor":"ff59c6ff","page":31,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"2.3.3衍生多个编译作业","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":28,"linecolor":"ff59c6ff","page":31,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"2.3.4安装新内核","type":8}],"page":29,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"2.3编译内核","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":29,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-17 14:19:48","docid":0,"fillcolor":"fffeeb73","id":432,"originaltext":"内核编程时既不能访问C库也不能访问标准的C头文件。","page":32,"textblocks":[{"first":[78.4364013671875,262.3199768066406,9.556396484375,8.160003662109375],"last":[314.8299865722656,262.3199768066406,8.459991455078125,8.160003662109375],"length":25,"rects":[[78.4364013671875,262.3199768066406,244.85357666015625,8.160003662109375]],"start":361,"text":"内核编程时既不能访问C库也不能访问标准的C头文件。"}],"type":5,"uuid":"04513ec959486c9679f266e9726b629d"},{"date":"2023-07-17 14:19:50","docid":0,"fillcolor":"fffeeb73","id":433,"originaltext":"·内核编程时必须使用GNUC。","page":32,"textblocks":[{"first":[68.87999725341797,277.4299621582031,9.503997802734375,7.920013427734375],"last":[199.92999267578125,277.4299621582031,2.399993896484375,7.920013427734375],"length":15,"rects":[[68.87999725341797,277.4299621582031,133.44998931884766,7.920013427734375]],"start":387,"text":"·内核编程时必须使用GNUC。"}],"type":5,"uuid":"3732d0853f5a9ae87fb79206d3488803"},{"date":"2023-07-17 14:19:52","docid":0,"fillcolor":"fffeeb73","id":434,"originaltext":"内核编程时缺乏像用户空间那样的内存保护机制。","page":32,"textblocks":[{"first":[78.47999572753906,292.3199768066406,9.599998474121094,8.160003662109375],"last":[280.080078125,292.3199768066406,9.600006103515625,8.160003662109375],"length":22,"rects":[[78.47999572753906,292.3199768066406,211.20008850097656,8.160003662109375]],"start":404,"text":"内核编程时缺乏像用户空间那样的内存保护机制。"}],"type":5,"uuid":"e5321a37082b1e828e6020257f9bdf8f"},{"date":"2023-07-17 14:19:56","docid":0,"fillcolor":"fffeeb73","id":435,"originaltext":"内核编程时难以执行浮点运算。","page":32,"textblocks":[{"first":[78.2239990234375,307.1999816894531,9.344001770019531,8.399993896484375],"last":[199.6959686279297,307.1999816894531,9.343994140625,8.399993896484375],"length":14,"rects":[[78.2239990234375,307.1999816894531,130.8159637451172,8.399993896484375]],"start":428,"text":"内核编程时难以执行浮点运算。"}],"type":5,"uuid":"2ac5925b6a96ee0e74aef702270f3a74"}],"page":32,"rect":[0,0.239990234375,1,1.239990234375],"title":"2.4内核开发的特点","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":37,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":30,"linecolor":"ff59c6ff","page":32,"rect":[0,0.239990234375,1,1.239990234375],"title":"2.4.1无libc库抑或无标准头文件","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":31,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-17 14:42:20","docid":0,"fillcolor":"fffeeb73","id":437,"originaltext":"l. 内联(inline)函数","page":33,"textblocks":[{"first":[72.38999938964844,468.719970703125,2.85052490234375,7.20001220703125],"last":[155.760009765625,468.719970703125,9.360000610351562,7.20001220703125],"length":15,"rects":[[72.38999938964844,468.719970703125,92.73001098632812,7.20001220703125]],"start":985,"text":"l. 内联(inline)函数"}],"type":5,"uuid":"312fc82beb5dc1cd69d48e6b37290540"},{"date":"2023-07-17 14:42:23","docid":0,"fillcolor":"fffeeb73","id":438,"originaltext":"2. 内联汇编","page":34,"textblocks":[{"first":[68.81999969482422,233.75997924804688,4.826896667480469,7.67999267578125],"last":[108.72000122070312,233.75997924804688,9.360000610351562,7.67999267578125],"length":7,"rects":[[68.81999969482422,233.75997924804688,49.26000213623047,7.67999267578125]],"start":373,"text":"2. 内联汇编"}],"type":5,"uuid":"7c87489ca6ae2ad27648f0818e993b3f"}],"page":33,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"2.4.2  GNUC","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":32,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-17 14:58:47","docid":0,"fillcolor":"fffeeb73","id":439,"originaltext":"如果一个用户程序试图进行一次非法的内存访问，内核就会发现这个错误，发送SIGSEGV信号，并结束整个进程。然而，如果是内核自己非法访问了内存，那后果就很难控制了。","page":35,"textblocks":[{"first":[73.44000244140625,179.99002075195312,10.139999389648438,8.399993896484375],"last":[425.3655090332031,195.11001586914062,9.82330322265625,8.399993896484375],"length":82,"rects":[[73.44000244140625,179.99002075195312,402.960205078125,8.399993896484375],[52.08000564575195,195.11001586914062,383.1088066101074,8.399993896484375]],"start":234,"text":"如果一个用户程序试图进行一次非法的内存访问，内核就会发现这个错误，发送SIGSEGV\n信号，并结束整个进程。然而，如果是内核自己非法访问了内存，那后果就很难控制了。"}],"type":5,"uuid":"b1f23b32954e812fde5f88753965a00b"}],"page":35,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"2.4.3没有内存保护机制","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":33,"linecolor":"ff59c6ff","page":35,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"2.4.4不要轻易在内核中使用浮点数","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":34,"linecolor":"ff59c6ff","page":35,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"2.4.5容积小而固定的栈","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":35,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-17 14:59:09","docid":0,"fillcolor":"fffeeb73","id":440,"originaltext":"内核很容易产生竞争条件。和单线程的用户空间程序不同，内核的许多特性都要求能够并发地访问共享数据，这就要求有同步机制以保证不出现竞争条件","page":35,"textblocks":[{"first":[74.4000015258789,590.8800048828125,9.9490966796875,8.6400146484375],"last":[310.544921875,606.22998046875,9.9224853515625,8.4000244140625],"length":68,"rects":[[74.4000015258789,590.8800048828125,401.77257537841797,8.6400146484375],[52.56000518798828,606.22998046875,267.9074020385742,8.4000244140625]],"start":1056,"text":"内核很容易产生竞争条件。和单线程的用户空间程序不同，内核的许多特性都要求能够并发\n地访问共享数据，这就要求有同步机制以保证不出现竞争条件"}],"type":5,"uuid":"b7518fb72eef1baa56411e345bb64c7a"}],"page":35,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"2.4.6同步和并发","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":36,"linecolor":"ff59c6ff","page":36,"rect":[0,0.239990234375,1,1.239990234375],"title":"2.4.7可移植性的重要性","type":8}],"page":36,"rect":[0,0.239990234375,1,1.239990234375],"title":"2.5小结","type":8}],"page":27,"rect":[0,0.239990234375,1,1.239990234375],"title":"第2章  从内核出发","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":38,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":39,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 19:31:08","docid":0,"fillcolor":"ffffed99","id":417,"markups":[{"date":"2023-07-17 15:12:58","docid":0,"fillcolor":"fffeeb73","id":441,"originaltext":"通常进程还要包含其他资源，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程(threadof execution), 当然还包括用来存放全局变量的数据段等。实际上，进程就是正在执行的程序代码的实时结果","page":37,"textblocks":[{"first":[292.6611022949219,291.5899658203125,10.18109130859375,7.920013427734375],"last":[210.47996520996094,336.7200012207031,9.899993896484375,8.160003662109375],"length":133,"rects":[[292.6611022949219,291.5899658203125,183.2596435546875,7.920013427734375],[52.08000183105469,306.4800109863281,423.84291076660156,8.399993896484375],[51.849998474121094,321.5899658203125,424.3100357055664,7.920013427734375],[52.08000183105469,336.7200012207031,168.29995727539062,8.160003662109375]],"start":243,"text":"通常进程还要包含其他资源，像打开的文\n件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个\n或多个执行线程(threadof execution), 当然还包括用来存放全局变量的数据段等。实际上，进\n程就是正在执行的程序代码的实时结果"}],"type":5,"uuid":"f3eaf947e52fff56656f0bdeb5618cca"}],"originaltext":"进程就是处千执行期的程序（目标码存放在某种存储介质上）","page":37,"textblocks":[{"first":[72.95999908447266,276.7200012207031,10.068000793457031,8.160003662109375],"last":[334.7278747558594,276.7200012207031,10.0679931640625,8.160003662109375],"length":27,"rects":[[72.95999908447266,276.7200012207031,271.8358688354492,8.160003662109375]],"start":170,"text":"进程就是处千执行期的程序（目标码存放在某种存储介质上）"}],"type":5},{"date":"2022-03-03 19:31:27","docid":0,"fillcolor":"ffffed99","id":418,"markups":[{"date":"2022-03-03 19:32:12","docid":0,"fillcolor":"ffffed99","id":419,"originaltext":"每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程","page":37,"textblocks":[{"first":[330.94122314453125,351.5999755859375,10.339202880859375,8.160003662109375],"last":[368.3052978515625,366.7200012207031,10.21630859375,8.160003662109375],"length":47,"rects":[[330.94122314453125,351.5999755859375,144.74884033203125,8.160003662109375],[51.599998474121094,366.7200012207031,326.9216079711914,8.160003662109375]],"start":425,"text":"每个线程都拥有一个独立的程序\n计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程"}],"type":5}],"originaltext":"执行线程，简称线程(thread),是在进程中活动的对象","page":37,"textblocks":[{"first":[73.19999694824219,351.5999755859375,10.213401794433594,8.160003662109375],"last":[310.2628173828125,351.5999755859375,10.339202880859375,8.160003662109375],"length":28,"rects":[[73.19999694824219,351.5999755859375,247.4020233154297,8.160003662109375]],"start":396,"text":"执行线程，简称线程(thread),是在进程中活动的对象"}],"type":5},{"date":"2022-03-03 19:33:27","docid":0,"fillcolor":"ffffed99","id":420,"originaltext":"Linux系统的线程实现非常特别：它对线程和进程并不特别区分。对Linux而言，线程只不过是一种特殊的进程罢了。","page":37,"textblocks":[{"first":[91.91999816894531,396.4800109863281,4.8480987548828125,8.399993896484375],"last":[176.42770385742188,411.6000061035156,9.582901000976562,8.399993896484375],"length":57,"rects":[[91.91999816894531,396.4800109863281,383.7699432373047,8.399993896484375],[51.849998474121094,411.6000061035156,134.16060638427734,8.399993896484375]],"start":531,"text":"Linux系统的线程实现非常特别：它对线程和进程并不特别区分。对Linux而言，线程\n只不过是一种特殊的进程罢了。"}],"type":5}],"page":37,"rect":[0,0.239990234375,1,1.239990234375],"title":"3.1进程","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":40,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":41,"linecolor":"ff59c6ff","page":39,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"3.2.1分配进程描述符","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":42,"linecolor":"ff59c6ff","page":40,"rect":[0,0.239990234375,1,1.239990234375],"title":"3.2.2进程描述符的存放","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":43,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-18 16:32:04","docid":0,"id":462,"imgfile":"cb0022b7bad50c84b30561e9ad1c6d94.png","linecolor":"ffa0ec6f","linewidth":2,"page":41,"rect":[58.21276422257125,293.6626052299353,461.54405919324347,574.3312898744753],"type":2,"uuid":"c9311333f75b8b6371a6cae1da88333d"}],"page":40,"rect":[0,0.239990234375,1,1.239990234375],"title":"3.2.3进程状态","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":44,"linecolor":"ff59c6ff","page":42,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"3.2.4设置当前进程状态","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":45,"linecolor":"ff59c6ff","page":42,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"3.2.5进程上下文","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":46,"linecolor":"ff59c6ff","page":42,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"3.2.6进程家族树","type":8}],"page":38,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"3.2进程描述符及任务结构","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":47,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":48,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-17 16:00:37","docid":0,"fillcolor":"fffeeb73","id":444,"originaltext":"只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享","page":44,"textblocks":[{"first":[66.96000671386719,169.20001220703125,10.061996459960938,8.160003662109375],"last":[357.8498840332031,184.32000732421875,10.079986572265625,8.160003662109375],"length":73,"rects":[[66.96000671386719,169.20001220703125,402.4801788330078,8.160003662109375],[45.37000274658203,184.32000732421875,322.5598678588867,8.160003662109375]],"start":219,"text":"只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资\n源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享"}],"type":5,"uuid":"9303bef003db833df6e590e3f8921d44"}],"page":44,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"3.3.1写时拷贝","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":49,"linecolor":"ff59c6ff","page":44,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"3.3.2  forkO","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":50,"linecolor":"ff59c6ff","page":45,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"3.3.3  vforkO","type":8}],"page":43,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"3.3进程创建","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":51,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":52,"linecolor":"ff59c6ff","page":46,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"3.4.1创建线程","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":53,"linecolor":"ff59c6ff","page":47,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"3.4.2内核线程","type":8}],"page":45,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"3.4线程在Linux中的实现","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":54,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":55,"linecolor":"ff59c6ff","page":49,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"3.5.1删除进程描述符","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":56,"linecolor":"ff59c6ff","page":49,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"3.5.2孤儿进程造成的进退维谷","type":8}],"page":48,"rect":[0,0.239990234375,1,1.239990234375],"title":"3.5进程终结","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":57,"linecolor":"ff59c6ff","page":51,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"3.6小结","type":8}],"page":37,"rect":[0,0.239990234375,1,1.239990234375],"title":"第3章  进程管理","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":58,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":59,"linecolor":"ff59c6ff","page":52,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"4.1多任务","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":60,"linecolor":"ff59c6ff","page":53,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"4.2  Linux的进程调度","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":61,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":62,"linecolor":"ff59c6ff","page":53,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"4.3.1  I/O消耗型和处理器消耗型的进程","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":63,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-17 16:56:15","docid":0,"fillcolor":"fffeeb73","id":445,"originaltext":"第一种是用nice值","page":54,"textblocks":[{"first":[247.37603759765625,447.1199951171875,10.384002685546875,8.160003662109375],"last":[322.80999755859375,447.1199951171875,10.290008544921875,8.160003662109375],"length":10,"rects":[[247.37603759765625,447.1199951171875,85.72396850585938,8.160003662109375]],"start":997,"text":"第一种是用nice值"}],"type":5,"uuid":"0b11b73247f82b1fccfc5685bd3c2930"},{"date":"2023-07-17 16:56:18","docid":0,"fillcolor":"fffeeb73","id":446,"originaltext":"第二种范围是实时优先级","page":54,"textblocks":[{"first":[73.68000030517578,552.719970703125,10.072799682617188,8.4000244140625],"last":[174.4080047607422,552.719970703125,10.072799682617188,8.4000244140625],"length":11,"rects":[[73.68000030517578,552.719970703125,110.8008041381836,8.4000244140625]],"start":1304,"text":"第二种范围是实时优先级"}],"type":5,"uuid":"f7e57eed6b84979434e6c1831c5060dc"}],"page":54,"rect":[-1.9199999570846558,1.67999267578125,-0.9199999570846558,2.67999267578125],"title":"4.3.2进程优先级","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":64,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-17 17:12:46","docid":0,"fillcolor":"fffeeb73","id":447,"originaltext":"1/0消耗型不需要长的时间片，而处理器消耗型的进程则希望越长越好","page":55,"textblocks":[{"first":[393.6100158691406,209.52001953125,4.4801025390625,8.399993896484375],"last":[275.0596008300781,224.38999938964844,10.331787109375,8.639999389648438],"length":33,"rects":[[393.6100158691406,209.52001953125,77.74996948242188,8.399993896484375],[47.76000213623047,224.38999938964844,237.63138580322266,8.639999389648438]],"start":328,"text":"1/0消耗型不需要\n长的时间片，而处理器消耗型的进程则希望越长越好"}],"type":5,"uuid":"edbaa27387c7dabbd0e183d06e7482d7"}],"page":55,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"4.3.3时间片","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":65,"linecolor":"ff59c6ff","page":55,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"4.3.4调度策略的活动","type":8}],"page":53,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"4.3策略","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":66,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":67,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-17 18:02:57","docid":0,"fillcolor":"fffeeb73","id":449,"originaltext":"Linux调度器是以模块方式提供的，这样做的目的是允许不同类型的进程可以有针对性地选择调度算法。","page":56,"textblocks":[{"first":[67.19999694824219,485.0399475097656,4.8480987548828125,8.160003662109375],"last":[91.08000183105469,500.3899841308594,9,8.399993896484375],"length":49,"rects":[[67.19999694824219,485.0399475097656,403.4412078857422,8.160003662109375],[46.08000183105469,500.3899841308594,54,8.399993896484375]],"start":962,"text":"Linux调度器是以模块方式提供的，这样做的目的是允许不同类型的进程可以有针对性地选\n择调度算法。"}],"type":5,"uuid":"4598fd06adf0dfa1557a4ae846d09b36"},{"date":"2023-07-17 18:02:38","docid":0,"fillcolor":"fffeeb73","id":448,"originaltext":"这种模块化结构被称为调度器类(schedulerclasses), 它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。每个调度器都有一个优先级","page":56,"textblocks":[{"first":[67.44000244140625,515.0399780273438,10.182899475097656,8.15997314453125],"last":[336.0254821777344,530.159912109375,10.355194091796875,8.4000244140625],"length":80,"rects":[[67.44000244140625,515.0399780273438,402.9701843261719,8.15997314453125],[46.08000183105469,530.159912109375,300.30067443847656,8.4000244140625]],"start":1012,"text":"这种模块化结构被称为调度器类(schedulerclasses), 它允许多种不同的可动态添加的调度\n算法并存，调度属于自己范畴的进程。每个调度器都有一个优先级"}],"type":5,"uuid":"33aeaf30813a306b93788a4069aceba4"}],"page":56,"rect":[-2.640000104904175,2.15997314453125,-1.6400001049041748,3.15997314453125],"title":"4.4.1调度器类","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":68,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-17 18:20:55","docid":0,"fillcolor":"fffeeb73","id":451,"originaltext":"现代进程调度器有两个通用的概念：进程优先级和时间片。","page":57,"textblocks":[{"first":[73.17339324951172,108.0000228881836,10.186698913574219,8.400001525878906],"last":[329.77001953125,108.0000228881836,2.160003662109375,8.400001525878906],"length":26,"rects":[[73.17339324951172,108.0000228881836,258.75662994384766,8.400001525878906]],"start":69,"text":"现代进程调度器有两个通用的概念：进程优先级和时间片。"}],"type":5,"uuid":"521052b1f9b6952c070b4c73d5b5c16e"}],"page":57,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"4.4.2  Unix系统中的进程调度","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":69,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-17 18:28:57","docid":0,"fillcolor":"fffeeb73","id":452,"originaltext":"CFS的做法是允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程","page":58,"textblocks":[{"first":[150.47999572753906,434.8699951171875,5.7599945068359375,8.6400146484375],"last":[138.44967651367188,450.0000305175781,9.863296508789062,8.399993896484375],"length":44,"rects":[[150.47999572753906,434.8699951171875,323.2897186279297,8.6400146484375],[49.68000030517578,450.0000305175781,98.63297271728516,8.399993896484375]],"start":927,"text":"CFS的做法是允许每个进程运行一段时间、循环轮转、选择运行最少的进\n程作为下一个运行进程"}],"type":5,"uuid":"4f0c5fdfc18fd2c994aeeeaebc46c23d"},{"date":"2023-07-17 18:04:42","docid":0,"fillcolor":"fffeeb73","id":450,"originaltext":"CFS为此引入每个进程获得的时间片底线，这个底线称为最小粒度。默认情况下这个值是lms。如此一来，即便是可运行进程数量趋于无穷，每个最少也能获得lms的运行时间，确保切换消耗被限制在一定范围内。","page":59,"textblocks":[{"first":[283.1999816894531,86.8800277709961,5.760009765625,8.400001525878906],"last":[383.362060546875,116.8800277709961,9.99200439453125,8.400001525878906],"length":99,"rects":[[283.1999816894531,86.8800277709961,188.41119384765625,8.400001525878906],[49.45000076293945,102.0000228881836,423.5911979675293,8.400001525878906],[49.68000030517578,116.8800277709961,343.67406463623047,8.400001525878906]],"start":71,"text":"CFS为此引入每个进程获得的时间片底线，\n这个底线称为最小粒度。默认情况下这个值是lms。如此一来，即便是可运行进程数量趋于无\n穷，每个最少也能获得lms的运行时间，确保切换消耗被限制在一定范围内。"}],"type":5,"uuid":"8a4306c2217e11757f0ee756182da95b"}],"page":58,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"4.4.3公平调度","type":8}],"page":56,"rect":[-2.640000104904175,2.15997314453125,-1.6400001049041748,3.15997314453125],"title":"4.4  Linux调度算法","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":70,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":71,"linecolor":"ff59c6ff","page":59,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"4.5.1时间记账","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":72,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-18 16:25:19","docid":0,"fillcolor":"fffeeb73","id":454,"originaltext":"CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小vruntime值的进程","page":61,"textblocks":[{"first":[78.72000122070312,548.8799438476562,5.680000305175781,8.4000244140625],"last":[450.3600158691406,548.8799438476562,10.44000244140625,8.4000244140625],"length":41,"rects":[[78.72000122070312,548.8799438476562,382.08001708984375,8.4000244140625]],"start":1091,"text":"CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小vruntime值的进程"}],"type":5,"uuid":"405c92ccecb8c83df8499ba3db8b3c9a"}],"page":61,"rect":[0,0.239990234375,1,1.239990234375],"title":"4.5.2进程选择","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":73,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-18 16:26:16","docid":0,"fillcolor":"fffeeb73","id":455,"originaltext":"Schedule()通常都需要和一个具体的调度类相关联，也就是说，它会找到一个最高优先级的调度","page":65,"textblocks":[{"first":[407.03997802734375,179.27996826171875,4.36810302734375,8.160003662109375],"last":[409.7398681640625,194.38998413085938,10.589996337890625,8.399993896484375],"length":48,"rects":[[407.03997802734375,179.27996826171875,66.24002075195312,8.160003662109375],[49.68000030517578,194.38998413085938,370.64986419677734,8.399993896484375]],"start":253,"text":"Schedule()通常\n都需要和一个具体的调度类相关联，也就是说，它会找到一个最高优先级的调度"}],"type":5,"uuid":"654fca249f23810e69c6d76a43f27392"}],"page":65,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"4.5.3调度器入口","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":74,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-18 16:26:29","docid":0,"fillcolor":"fffeeb73","id":457,"originaltext":"休眠（被阻塞）的进程处于一个特殊的不可执行状态","page":66,"textblocks":[{"first":[66.4800033569336,164.39999389648438,10.062004089355469,8.399993896484375],"last":[287.8439636230469,164.39999389648438,10.06201171875,8.399993896484375],"length":23,"rects":[[66.4800033569336,164.39999389648438,231.42597198486328,8.399993896484375]],"start":208,"text":"休眠（被阻塞）的进程处于一个特殊的不可执行状态"}],"type":5,"uuid":"acea28da3a377f7329891ae53889b58b"},{"date":"2023-07-18 16:29:30","docid":0,"fillcolor":"fffeeb73","id":459,"markups":[{"date":"2023-07-18 16:29:07","docid":0,"fillcolor":"fffeeb73","id":458,"originaltext":"休眠通过等待队列进行处理。等待队列是由等待某些事件发生的进程组成的简单链表","page":66,"textblocks":[{"first":[66.96000671386719,377.75,10.307701110839844,8.399993896484375],"last":[438.0372619628906,377.75,10.307708740234375,8.399993896484375],"length":37,"rects":[[66.96000671386719,377.75,381.3849639892578,8.399993896484375]],"start":784,"text":"休眠通过等待队列进行处理。等待队列是由等待某些事件发生的进程组成的简单链表"}],"type":5,"uuid":"223bdea792e973726612e2e4aa239301"}],"originaltext":"1. 等待队列","page":66,"textblocks":[{"first":[67.66000366210938,363.1199951171875,4.5084381103515625,7.920013427734375],"last":[106.43998718261719,363.1199951171875,9.479995727539062,7.920013427734375],"length":7,"rects":[[67.66000366210938,363.1199951171875,48.259979248046875,7.920013427734375]],"start":776,"text":"1. 等待队列"}],"type":5,"uuid":"50a353ea06914d3e3243be655e5216fe"},{"date":"2023-07-18 16:29:39","docid":0,"fillcolor":"fffeeb73","id":460,"markups":[{"date":"2023-07-18 16:29:40","docid":0,"fillcolor":"fffeeb73","id":461,"originaltext":"唤醒操作通过函数wake_up{)进行","page":68,"textblocks":[{"first":[71.04000091552734,400.7999572753906,10.650001525878906,8.160003662109375],"last":[216.14410400390625,400.7999572753906,10.7041015625,8.160003662109375],"length":19,"rects":[[71.04000091552734,400.7999572753906,155.8082046508789,8.160003662109375]],"start":432,"text":"唤醒操作通过函数wake_up{)进行"}],"type":5,"uuid":"9113fe9ff1bd5930c2aacf85b899933f"}],"originaltext":"2. 唤醒","page":68,"textblocks":[{"first":[70.73999786376953,386.62994384765625,5,7.20001220703125],"last":[90.83999633789062,386.62994384765625,9.479995727539062,7.20001220703125],"length":5,"rects":[[70.73999786376953,386.62994384765625,29.579994201660156,7.20001220703125]],"start":426,"text":"2. 唤醒"}],"type":5,"uuid":"02da2fdae1c523089c6092f0e57c8d4d"}],"page":66,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"4.5.4睡眠和唤醒","type":8}],"page":59,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"4.5  Linux调度的实现","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":75,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-18 18:25:12","docid":0,"fillcolor":"fffeeb73","group":[{"date":"2023-07-18 18:25:12","docid":0,"fillcolor":"fffeeb73","id":464,"originaltext":"","page":69,"textblocks":[{"first":[78.72000122070312,75.3600082397461,9.469100952148438,8.400001525878906],"last":[173.4110107421875,75.3600082397461,9.469100952148438,8.400001525878906],"length":11,"rects":[[78.72000122070312,75.3600082397461,104.16011047363281,8.400001525878906]],"start":7,"text":"程映射切换到新进程中。"}],"type":5,"uuid":"432c5692cfd1b1ed658b594300fc4cac"}],"id":463,"originaltext":"调用声明在<asm/mmu_ context.h>中的switch_mm(), 该函数负责把虚拟内存从上一个进\n程映射切换到新进程中。","page":68,"textblocks":[{"first":[81.08009338378906,613.2000122070312,9.560096740722656,7.91998291015625],"last":[463.3119812011719,613.2000122070312,10.447998046875,7.91998291015625],"length":55,"rects":[[81.08009338378906,613.2000122070312,392.6798858642578,7.91998291015625]],"start":924,"text":"调用声明在<asm/mmu_ context.h>中的switch_mm(), 该函数负责把虚拟内存从上一个进"}],"type":5,"uuid":"de4a6ec3b3c99939cfab7ba0562ccfd8"},{"date":"2023-07-18 18:25:35","docid":0,"fillcolor":"fffeeb73","id":465,"originaltext":"调用声明在<asm/system.h>中的switch_to(),该函数负责从上一个进程的处理器状态切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结构相关的状态信息，都必须以每个进程为对象进行管理和保存。","page":69,"textblocks":[{"first":[82.12000274658203,90.72001647949219,9.400001525878906,7.9199981689453125],"last":[344.1705627441406,120.4699935913086,9.831512451171875,8.400001525878906],"length":121,"rects":[[82.12000274658203,90.72001647949219,392.84139251708984,7.9199981689453125],[78.96000671386719,104.86998748779297,397.44102478027344,9.120002746582031],[78.72000122070312,120.4699935913086,275.2820739746094,8.400001525878906]],"start":20,"text":"调用声明在<asm/system.h>中的switch_to(),该函数负责从上一个进程的处理器状态切换\n到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结\n构相关的状态信息，都必须以每个进程为对象进行管理和保存。"}],"type":5,"uuid":"2c21e8d1c0ca1673f05b1efbf8b90b4a"},{"date":"2022-03-03 18:29:36","docid":0,"id":76,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-18 18:26:55","docid":0,"fillcolor":"fffeeb73","id":466,"originaltext":"简而言之，用户抢占在以下情况时产生：·从系统调返回用户空间时。·从中断处理程序返回用户空间时。","page":70,"textblocks":[{"first":[72.4800033569336,201.5899658203125,9.773399353027344,8.399993896484375],"last":[213.3149871826172,231.5899658203125,9.404998779296875,8.399993896484375],"length":49,"rects":[[72.4800033569336,201.5899658203125,175.9212875366211,8.399993896484375],[72.4800033569336,216.469970703125,120.00041961669922,8.399993896484375],[72.23999786376953,231.5899658203125,150.47998809814453,8.399993896484375]],"start":314,"text":"简而言之，用户抢占在以下情况时产生：\n·从系统调返回用户空间时。\n·从中断处理程序返回用户空间时。"}],"type":5,"uuid":"31585d4512128246cfa413c8ba524424"}],"page":70,"rect":[-2.640000104904175,2.15997314453125,-1.6400001049041748,3.15997314453125],"title":"4.6.1用户抢占","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":77,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-18 18:34:10","docid":0,"fillcolor":"fffeeb73","id":468,"originaltext":"那么，什么时候重新调度才是安全的呢？只要没有持有锁，内核就可以进行抢占","page":70,"textblocks":[{"first":[72,368.3999938964844,10.061996459960938,8.399993896484375],"last":[414.10809326171875,368.3999938964844,10.06201171875,8.399993896484375],"length":35,"rects":[[72,368.3999938964844,352.17010498046875,8.399993896484375]],"start":595,"text":"那么，什么时候重新调度才是安全的呢？只要没有持有锁，内核就可以进行抢占"}],"type":5,"uuid":"30f5b186d201a7d704f38c44a5876c28"},{"date":"2023-07-18 18:34:40","docid":0,"fillcolor":"fffeeb73","id":469,"originaltext":"·中断处理程序正在执行，且返回内核空间之前。","page":70,"textblocks":[{"first":[72.23999786376953,608.6299438476562,9.599998474121094,8.4000244140625],"last":[273.8400573730469,608.6299438476562,9.600006103515625,8.4000244140625],"length":22,"rects":[[72.23999786376953,608.6299438476562,211.20006561279297,8.4000244140625]],"start":1255,"text":"·中断处理程序正在执行，且返回内核空间之前。"}],"type":5,"uuid":"766c65b92aff8711b75bc3ff673c690a"},{"date":"2023-07-18 18:34:45","docid":0,"fillcolor":"fffeeb73","id":471,"originaltext":"·内核代码再一次具有可抢占性的时候。","page":71,"textblocks":[{"first":[71.04000091552734,69.82998657226562,9.480003356933594,8.160003662109375],"last":[232.19993591308594,69.82998657226562,9.479995727539062,8.160003662109375],"length":18,"rects":[[71.04000091552734,69.82998657226562,170.63993072509766,8.160003662109375]],"start":7,"text":"·内核代码再一次具有可抢占性的时候。"}],"type":5,"uuid":"4c05106b653212e882c0c696bad7f9be"},{"date":"2023-07-18 18:34:46","docid":0,"fillcolor":"fffeeb73","id":472,"originaltext":"·如果内核中的任务显式地调用schedule()。","page":71,"textblocks":[{"first":[71.04000091552734,84.96000671386719,9.685798645019531,7.9199981689453125],"last":[254.17001342773438,84.96000671386719,2.399993896484375,7.9199981689453125],"length":25,"rects":[[71.04000091552734,84.96000671386719,185.5300064086914,7.9199981689453125]],"start":26,"text":"·如果内核中的任务显式地调用schedule()。"}],"type":5,"uuid":"49b4e3806abbcddd7f8b79cd7da96f02"},{"date":"2023-07-18 18:34:48","docid":0,"fillcolor":"fffeeb73","id":473,"originaltext":"·如果内核中的任务阻塞（这同样也会导致调用schedule())。","page":71,"textblocks":[{"first":[71.04000091552734,99.82998657226562,9.81719970703125,8.160003662109375],"last":[329.52001953125,99.82998657226562,2.6400146484375,8.160003662109375],"length":33,"rects":[[71.04000091552734,99.82998657226562,261.12003326416016,8.160003662109375]],"start":52,"text":"·如果内核中的任务阻塞（这同样也会导致调用schedule())。"}],"type":5,"uuid":"e99b0137f2bff3298f522ad68fdece0c"}],"page":70,"rect":[-2.640000104904175,2.15997314453125,-1.6400001049041748,3.15997314453125],"title":"4.6.2内核抢占","type":8}],"page":68,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"4.6抢占和上下文切换","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":78,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-18 18:38:23","docid":0,"fillcolor":"fffeeb73","id":476,"originaltext":"这两种实时算法实现的都是静态优先级。内核不为实时进程计算动态优先级。这能保证给定优先级别的实时进程总能抢占优先级比它低的进程。","page":71,"textblocks":[{"first":[71.04000091552734,387.3500061035156,10.068000793457031,8.399993896484375],"last":[265.25384521484375,402.4800109863281,9.78790283203125,8.160003662109375],"length":64,"rects":[[71.04000091552734,387.3500061035156,402.7197952270508,8.399993896484375],[49.92000198364258,402.4800109863281,225.12174606323242,8.160003662109375]],"start":815,"text":"这两种实时算法实现的都是静态优先级。内核不为实时进程计算动态优先级。这能保证给定\n优先级别的实时进程总能抢占优先级比它低的进程。"}],"type":5,"uuid":"3572ba7536545abb738869714d85f891"},{"date":"2023-07-18 18:40:12","docid":0,"fillcolor":"fffeeb73","id":477,"originaltext":"SCHED_FIFO实现了一种简单的、先入先出的调度算法：它不使用时间片。处千可运行状态的SCHED_FIFO级的进程会比任何SCHED_NORMAL级的进程都先得到调度。一旦一个SCHED_FIFO级进程处千可执行状态，就会一直执行，直到它自己受阻塞或显式地释放处理器为止","page":71,"textblocks":[{"first":[71.04000091552734,207.1199951171875,5.9521026611328125,8.160003662109375],"last":[60.042903900146484,252.239990234375,10.12289810180664,8.160003662109375],"length":140,"rects":[[71.04000091552734,207.1199951171875,402.47977447509766,8.160003662109375],[49.69000244140625,222.239990234375,423.5901184082031,8.160003662109375],[49.92000198364258,237.36001586914062,423.36066818237305,8.160003662109375],[49.92000198364258,252.239990234375,20.245800018310547,8.160003662109375]],"start":264,"text":"SCHED_FIFO实现了一种简单的、先入先出的调度算法：它不使用时间片。处千可运行\n状态的SCHED_FIFO级的进程会比任何SCHED_NORMAL级的进程都先得到调度。一旦一个\nSCHED_FIFO级进程处千可执行状态，就会一直执行，直到它自己受阻塞或显式地释放处理器\n为止"}],"type":5,"uuid":"639cd06cfdc7e5a92f85e0a89f65b74a"},{"date":"2023-07-18 18:40:20","docid":0,"fillcolor":"fffeeb73","id":478,"originaltext":"只有更高优先级的SCHED_FIFO或者SCHED_RR任务才能抢占SCHED_FIFO任务。如果有两个或者更多的同优先级的SCHED_FIFO级进程，它们会轮流执行，但是依然只有在它们愿意让出处理器时才会退出。","page":71,"textblocks":[{"first":[252.37794494628906,252.239990234375,10.122909545898438,8.160003662109375],"last":[336.3399658203125,282.239990234375,10.23748779296875,8.160003662109375],"length":108,"rects":[[252.37794494628906,252.239990234375,221.86216735839844,8.160003662109375],[49.92000198364258,267.3500061035156,423.6000175476074,7.920013427734375],[49.69000244140625,282.239990234375,296.887451171875,8.160003662109375]],"start":422,"text":"只有更高优先级的SCHED_FIFO或者SCHED_RR\n任务才能抢占SCHED_FIFO任务。如果有两个或者更多的同优先级的SCHED_FIFO级进程，它\n们会轮流执行，但是依然只有在它们愿意让出处理器时才会退出。"}],"type":5,"uuid":"9ca04877472468a7d466f49ee4409422"},{"date":"2023-07-18 18:41:32","docid":0,"fillcolor":"fffeeb73","id":479,"originaltext":"SCHED_RR与SCHED_FIFO大体相同，只是SCHED_RR级的进程在耗尽事先分配给它的时间后就不能再继续执行了。也就是说，SCHED_RR是带有时间片的SCHED_FIFO-这是一种实时轮流调度算法","page":71,"textblocks":[{"first":[71.5199966430664,312.239990234375,6.420097351074219,8.160003662109375],"last":[130.38558959960938,342.2400207519531,10.058197021484375,8.399993896484375],"length":106,"rects":[[71.5199966430664,312.239990234375,402.00118255615234,8.160003662109375],[49.92000198364258,327.3600158691406,423.8500175476074,8.160003662109375],[49.92000198364258,342.2400207519531,90.52378463745117,8.399993896484375]],"start":584,"text":"SCHED_RR与SCHED_FIFO大体相同，只是SCHED_RR级的进程在耗尽事先分配给它的\n时间后就不能再继续执行了。也就是说，SCHED_RR是带有时间片的SCHED_FIFO-这是一\n种实时轮流调度算法"}],"type":5,"uuid":"d9ad4dce41a6b17bbc654e13c14e2a4f"}],"page":71,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"4.7实时调度策略","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":79,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":80,"linecolor":"ff59c6ff","markups":[{"date":"2023-07-21 14:20:38","docid":0,"id":480,"imgfile":"4d4e4ad42b8d56d3cc6b1479ba07c814.png","linecolor":"ffa0ec6f","linewidth":2,"page":72,"rect":[35.61812815739775,126.64223344852532,476.39246410519485,316.6055836213133],"type":2,"uuid":"3561471a9038724a809896d737e3e5b5"}],"page":72,"rect":[-1.9199999570846558,1.67999267578125,-0.9199999570846558,2.67999267578125],"title":"4.8.1与调度策略和优先级相关的系统调用","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":81,"linecolor":"ff59c6ff","page":72,"rect":[-1.9199999570846558,1.67999267578125,-0.9199999570846558,2.67999267578125],"title":"4.8.2与处理器绑定有关的系统调用","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":82,"linecolor":"ff59c6ff","page":73,"rect":[-3.8399999141693115,3.3599853515625,-2.8399999141693115,4.3599853515625],"title":"4.8.3放弃处理器时间","type":8}],"page":71,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"4.8与调度相关的系统调用","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":83,"linecolor":"ff59c6ff","page":73,"rect":[-3.8399999141693115,3.3599853515625,-2.8399999141693115,4.3599853515625],"title":"4.9小结","type":8}],"page":52,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"第4章  进程调度","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":84,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":85,"linecolor":"ff59c6ff","page":74,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"5.1与内核通信","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":86,"linecolor":"ff59c6ff","page":74,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"5.2  API、POSIX和C库","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":87,"linecolor":"ff59c6ff","page":75,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"5.3系统调用","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":88,"linecolor":"ff59c6ff","page":76,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"5.3.1系统调用号","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":89,"linecolor":"ff59c6ff","page":76,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"5.3.2系统调用的性能","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":90,"linecolor":"ff59c6ff","page":77,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"5.4系统调用处理程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":91,"linecolor":"ff59c6ff","page":77,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"5.4.1指定恰当的系统调用","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":92,"linecolor":"ff59c6ff","page":77,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"5.4.2参数传递","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":93,"linecolor":"ff59c6ff","page":78,"rect":[0,0.239990234375,1,1.239990234375],"title":"5.5系统调用的实现","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":94,"linecolor":"ff59c6ff","page":78,"rect":[0,0.239990234375,1,1.239990234375],"title":"5.5.1实现系统调用","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":95,"linecolor":"ff59c6ff","page":79,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"5.5.2参数验证","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":96,"linecolor":"ff59c6ff","page":81,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"5.6系统调用上下文","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":97,"linecolor":"ff59c6ff","page":82,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"5.6.1绑定一个系统调用的最后步骤","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":98,"linecolor":"ff59c6ff","page":84,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"5.6.2从用户空间访问系统调用","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":99,"linecolor":"ff59c6ff","page":85,"rect":[0,0.239990234375,1,1.239990234375],"title":"5.6.3为什么不通过系统调用的方式实现","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":100,"linecolor":"ff59c6ff","page":85,"rect":[0,0.239990234375,1,1.239990234375],"title":"5.7小结","type":8}],"page":74,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"第5章  系统调用","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":101,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":102,"linecolor":"ff59c6ff","page":86,"rect":[-3.359999895095825,2.8800048828125,-2.359999895095825,3.8800048828125],"title":"6.1链表","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":103,"linecolor":"ff59c6ff","page":86,"rect":[-3.359999895095825,2.8800048828125,-2.359999895095825,3.8800048828125],"title":"6.1.1单向链表和双向链表","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":104,"linecolor":"ff59c6ff","page":87,"rect":[-5.039989948272705,4.55999755859375,-4.039989948272705,5.55999755859375],"title":"6.1.2环形链表","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":105,"linecolor":"ff59c6ff","page":88,"rect":[-3.359999895095825,2.8800048828125,-2.359999895095825,3.8800048828125],"title":"6.1.3沿链表移动","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":106,"linecolor":"ff59c6ff","page":88,"rect":[-3.359999895095825,2.8800048828125,-2.359999895095825,3.8800048828125],"title":"6.1.4  Linux内核中的实现","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":107,"linecolor":"ff59c6ff","page":90,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"6.1.5操作链表","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":108,"linecolor":"ff59c6ff","page":92,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"6.1.6遍历链表","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":109,"linecolor":"ff59c6ff","page":95,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"6.2队列","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":110,"linecolor":"ff59c6ff","page":96,"rect":[0,0.239990234375,1,1.239990234375],"title":"6.2.1  kfifo","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":111,"linecolor":"ff59c6ff","page":96,"rect":[0,0.239990234375,1,1.239990234375],"title":"6.2.2创建队列","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":112,"linecolor":"ff59c6ff","page":96,"rect":[0,0.239990234375,1,1.239990234375],"title":"6.2.3推入队列数据","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":113,"linecolor":"ff59c6ff","page":97,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"6.2.4摘取队列数据","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":114,"linecolor":"ff59c6ff","page":97,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"6.2.5获取队列长度","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":115,"linecolor":"ff59c6ff","page":97,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"6.2.6重置和撤销队列","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":116,"linecolor":"ff59c6ff","page":98,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"6.2.7队列使用举例","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":117,"linecolor":"ff59c6ff","page":98,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"6.3映射","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":118,"linecolor":"ff59c6ff","page":99,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"6.3.1初始化一个idr","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":119,"linecolor":"ff59c6ff","page":99,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"6.3.2分配一个新的UID","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":120,"linecolor":"ff59c6ff","page":100,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"6.3.3查找UID","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":121,"linecolor":"ff59c6ff","page":101,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"6.3.4删除UID","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":122,"linecolor":"ff59c6ff","page":101,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"6.3.5撤销idr","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":123,"linecolor":"ff59c6ff","page":101,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"6.4二叉树","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":124,"linecolor":"ff59c6ff","page":101,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"6.4.1二叉搜索树","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":125,"linecolor":"ff59c6ff","page":102,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"6.4.2自平衡二叉搜索树","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":126,"linecolor":"ff59c6ff","page":104,"rect":[0,0.239990234375,1,1.239990234375],"title":"6.5数据结构以及选择","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":127,"linecolor":"ff59c6ff","page":105,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"6.6算法复杂度","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":128,"linecolor":"ff59c6ff","page":105,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"6.6.1算法","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":129,"linecolor":"ff59c6ff","page":105,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"6.6.2大O符号","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":130,"linecolor":"ff59c6ff","page":106,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"6.6.3大θ符号","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":131,"linecolor":"ff59c6ff","page":106,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"6.6.4时间复杂度","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":132,"linecolor":"ff59c6ff","page":107,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"6.7小结","type":8}],"page":86,"rect":[-3.359999895095825,2.8800048828125,-2.359999895095825,3.8800048828125],"title":"第6章  内核数据结构","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":133,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":134,"linecolor":"ff59c6ff","page":108,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"7.1中断","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":135,"linecolor":"ff59c6ff","page":109,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"7.2中断处理程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":136,"linecolor":"ff59c6ff","page":110,"rect":[0,0.239990234375,1,1.239990234375],"title":"7.3上半部与下半部的对比","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":137,"linecolor":"ff59c6ff","page":110,"rect":[0,0.239990234375,1,1.239990234375],"title":"7.4注册中断处理程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":138,"linecolor":"ff59c6ff","page":111,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"7.4.1中断处理程序标志","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":139,"linecolor":"ff59c6ff","page":112,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"7.4.2一个中断例子","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":140,"linecolor":"ff59c6ff","page":112,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"7.4.3释放中断处理程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":141,"linecolor":"ff59c6ff","page":113,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"7.5编写中断处理程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":142,"linecolor":"ff59c6ff","page":114,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"7.5.1共享的中断处理程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":143,"linecolor":"ff59c6ff","page":114,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"7.5.2中断处理程序实例","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":144,"linecolor":"ff59c6ff","page":116,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"7.6中断上下文","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":145,"linecolor":"ff59c6ff","page":117,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"7.7中断处理机制的实现","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":146,"linecolor":"ff59c6ff","page":119,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"7.8/proc/interrupts","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":147,"linecolor":"ff59c6ff","page":120,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"7.9中断控制","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":148,"linecolor":"ff59c6ff","page":120,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"7.9.1禁止和激活中断","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":149,"linecolor":"ff59c6ff","page":122,"rect":[0,0.239990234375,1,1.239990234375],"title":"7.9.2禁止指定中断线","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":150,"linecolor":"ff59c6ff","page":122,"rect":[0,0.239990234375,1,1.239990234375],"title":"7.9.3中断系统的状态","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":151,"linecolor":"ff59c6ff","page":123,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"7.10小结","type":8}],"page":108,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"第7章  中断和中断处理","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":152,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":153,"linecolor":"ff59c6ff","page":124,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"8.1下半部","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":154,"linecolor":"ff59c6ff","page":125,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"8.1.1为什么要用下半部","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":155,"linecolor":"ff59c6ff","page":125,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"8.1.2下半部的环境","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":156,"linecolor":"ff59c6ff","page":127,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"8.2软中断","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":157,"linecolor":"ff59c6ff","page":128,"rect":[0,0.239990234375,1,1.239990234375],"title":"8.2.1软中断的实现","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":158,"linecolor":"ff59c6ff","page":130,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"8.2.2使用软中断","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":159,"linecolor":"ff59c6ff","page":131,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"8.3  tasklet","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":160,"linecolor":"ff59c6ff","page":131,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"8.3.1  tasklet的实现","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":161,"linecolor":"ff59c6ff","page":133,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"8.3.2使用 tasklet","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":162,"linecolor":"ff59c6ff","page":136,"rect":[-3.359999895095825,2.8800048828125,-2.359999895095825,3.8800048828125],"title":"8.3.3老的BH机制","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":163,"linecolor":"ff59c6ff","page":137,"rect":[-5.039989948272705,4.55999755859375,-4.039989948272705,5.55999755859375],"title":"8.4工作队列","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":164,"linecolor":"ff59c6ff","page":138,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"8.4.1工作队列的实现","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":165,"linecolor":"ff59c6ff","page":141,"rect":[0,0.239990234375,1,1.239990234375],"title":"8.4.2使用工作队列","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":166,"linecolor":"ff59c6ff","page":143,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"8.4.3老的任务队列机制","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":167,"linecolor":"ff59c6ff","page":144,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"8.5下半部机制的选择","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":168,"linecolor":"ff59c6ff","page":145,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"8.6在下半部之间加锁","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":169,"linecolor":"ff59c6ff","page":145,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"8.7禁止下半部","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":170,"linecolor":"ff59c6ff","page":146,"rect":[-1.9199999570846558,1.67999267578125,-0.9199999570846558,2.67999267578125],"title":"8.8小结","type":8}],"page":124,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"第8章  下半部和推后执行的工作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":171,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":172,"linecolor":"ff59c6ff","page":148,"rect":[0,0.239990234375,1,1.239990234375],"title":"9.1临界区和竞争条件","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":173,"linecolor":"ff59c6ff","page":149,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"9.1.1为什么我们需要保护","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":174,"linecolor":"ff59c6ff","page":150,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"9.1.2单个变量","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":175,"linecolor":"ff59c6ff","page":151,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"9.2加锁","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":176,"linecolor":"ff59c6ff","page":152,"rect":[0,0.239990234375,1,1.239990234375],"title":"9.2.1造成并发执行的原因","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":177,"linecolor":"ff59c6ff","page":153,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"9.2.2了解要保护些什么","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":178,"linecolor":"ff59c6ff","page":154,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"9.3死锁","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":179,"linecolor":"ff59c6ff","page":155,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"9.4争用和扩展性","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":180,"linecolor":"ff59c6ff","page":157,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"9.5小结","type":8}],"page":148,"rect":[0,0.239990234375,1,1.239990234375],"title":"第9章  内核同步介绍","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":181,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":182,"linecolor":"ff59c6ff","page":158,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"10.1原子操作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":183,"linecolor":"ff59c6ff","page":159,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"10.1.1原子整数操作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":184,"linecolor":"ff59c6ff","page":161,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"10.1.2  64位原子操作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":185,"linecolor":"ff59c6ff","page":162,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"10.1.3原子位操作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":186,"linecolor":"ff59c6ff","page":164,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"10.2自旋锁","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":187,"linecolor":"ff59c6ff","page":165,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"10.2.1自旋锁方法","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":188,"linecolor":"ff59c6ff","page":166,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"10.2.2其他针对自旋锁的操作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":189,"linecolor":"ff59c6ff","page":167,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"10.2.3自旋锁和下半部","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":190,"linecolor":"ff59c6ff","page":167,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"10.3读一写自旋锁","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":191,"linecolor":"ff59c6ff","page":169,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"10.4信号量","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":192,"linecolor":"ff59c6ff","page":170,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"10.4.1计数信号量和二值信号量","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":193,"linecolor":"ff59c6ff","page":171,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"10.4.2创建和初始化信号量","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":194,"linecolor":"ff59c6ff","page":171,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"10.4.3使用信号量","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":195,"linecolor":"ff59c6ff","page":172,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"10.5读一写信号量","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":196,"linecolor":"ff59c6ff","page":173,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"10.6互斥体","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":197,"linecolor":"ff59c6ff","page":175,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"10.6.1信号量和互斥体","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":198,"linecolor":"ff59c6ff","page":175,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"10.6.2自旋锁和互斥体","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":199,"linecolor":"ff59c6ff","page":175,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"10.7完成变量","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":200,"linecolor":"ff59c6ff","page":176,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"10.8  BLK：大内核锁","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":201,"linecolor":"ff59c6ff","page":177,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"10.9顺序锁","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":202,"linecolor":"ff59c6ff","page":178,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"10.10禁止抢占","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":203,"linecolor":"ff59c6ff","page":179,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"10.11顺序和屏障","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":204,"linecolor":"ff59c6ff","page":182,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"10.12小结","type":8}],"page":158,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"第10章  内核同步方法","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":205,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":206,"linecolor":"ff59c6ff","page":183,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"11.1内核中的时间概念","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":207,"linecolor":"ff59c6ff","page":184,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"11.2节拍率：HZ","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":208,"linecolor":"ff59c6ff","page":185,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"11.2.1理想的HZ值","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":209,"linecolor":"ff59c6ff","page":186,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"11.2.2高HZ的优势","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":210,"linecolor":"ff59c6ff","page":186,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"11.2.3高HZ的劣势","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":211,"linecolor":"ff59c6ff","page":187,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"11.3  jiffies","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":212,"linecolor":"ff59c6ff","page":188,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"11.3.1 jiffies的内部表示","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":213,"linecolor":"ff59c6ff","page":189,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"11.3.2 jiffies的回绕","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":214,"linecolor":"ff59c6ff","page":190,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"11.3.3用户空间和HZ","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":215,"linecolor":"ff59c6ff","page":191,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"11.4硬时钟和定时器","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":216,"linecolor":"ff59c6ff","page":191,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"11.4.1实时时钟","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":217,"linecolor":"ff59c6ff","page":191,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"11.4.2系统定时器","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":218,"linecolor":"ff59c6ff","page":191,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"11.5时钟中断处理程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":219,"linecolor":"ff59c6ff","page":193,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"11.6实际时间","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":220,"linecolor":"ff59c6ff","page":195,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"11.7定时器","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":221,"linecolor":"ff59c6ff","page":195,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"11.7.1使用定时器","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":222,"linecolor":"ff59c6ff","page":197,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"11.7.2定时器竞争条件","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":223,"linecolor":"ff59c6ff","page":197,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"11.7.3实现定时器","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":224,"linecolor":"ff59c6ff","page":198,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"11.8延迟执行","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":225,"linecolor":"ff59c6ff","page":198,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"11.8.1忙等待","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":226,"linecolor":"ff59c6ff","page":199,"rect":[-3.8399999141693115,3.3599853515625,-2.8399999141693115,4.3599853515625],"title":"11.8.2短延迟","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":227,"linecolor":"ff59c6ff","page":200,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"11.8.3  schedule timeoutO","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":228,"linecolor":"ff59c6ff","page":202,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"11.9小结","type":8}],"page":183,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"第11章  定时器和时间管理","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":229,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":230,"linecolor":"ff59c6ff","page":203,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"12.1页","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":231,"linecolor":"ff59c6ff","page":204,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"12.2区","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":232,"linecolor":"ff59c6ff","page":206,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"12.3获得页","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":233,"linecolor":"ff59c6ff","page":207,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"12.3.1获得填充为0的页","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":234,"linecolor":"ff59c6ff","page":208,"rect":[-2.640000104904175,2.15997314453125,-1.6400001049041748,3.15997314453125],"title":"12.3.2释放页","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":235,"linecolor":"ff59c6ff","page":208,"rect":[-2.640000104904175,2.15997314453125,-1.6400001049041748,3.15997314453125],"title":"12.4  kmallocO","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":236,"linecolor":"ff59c6ff","page":209,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"12.4.1  gfp_mask标志","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":237,"linecolor":"ff59c6ff","page":212,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"12.4.2  kfreeO","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":238,"linecolor":"ff59c6ff","page":213,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"12.5  vmallocO","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":239,"linecolor":"ff59c6ff","page":214,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"12.6  slab层","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":240,"linecolor":"ff59c6ff","page":215,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"12.6.1  slab层的设计","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":241,"linecolor":"ff59c6ff","page":217,"rect":[-3.8399999141693115,3.3599853515625,-2.8399999141693115,4.3599853515625],"title":"12.6.2  slab分配器的接口","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":242,"linecolor":"ff59c6ff","page":220,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"12.7在栈上的静态分配","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":243,"linecolor":"ff59c6ff","page":220,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"12.7.1单页内核栈","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":244,"linecolor":"ff59c6ff","page":220,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"12.7.2在栈上光明正大地工作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":245,"linecolor":"ff59c6ff","page":221,"rect":[0,0.239990234375,1,1.239990234375],"title":"12.8高端内存的映射","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":246,"linecolor":"ff59c6ff","page":221,"rect":[0,0.239990234375,1,1.239990234375],"title":"12.8.1永久映射","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":247,"linecolor":"ff59c6ff","page":221,"rect":[0,0.239990234375,1,1.239990234375],"title":"12.8.2临时映射","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":248,"linecolor":"ff59c6ff","page":222,"rect":[0,0.239990234375,1,1.239990234375],"title":"12.9每个CPU的分配","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":249,"linecolor":"ff59c6ff","page":223,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"12.10新的每个CPU接口","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":250,"linecolor":"ff59c6ff","page":223,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"12.10.1编译时的每个CPU数据","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":251,"linecolor":"ff59c6ff","page":224,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"12.10.2运行时的每个CPU数据","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":252,"linecolor":"ff59c6ff","page":225,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"12.11使用每个CPU数据的原因","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":253,"linecolor":"ff59c6ff","page":226,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"12.12分配函数的选择","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":254,"linecolor":"ff59c6ff","page":226,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"12.13小结","type":8}],"page":203,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"第12章  内存管理","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":255,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":256,"linecolor":"ff59c6ff","page":227,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"13.1通用文件系统接口","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":257,"linecolor":"ff59c6ff","page":228,"rect":[0,0.239990234375,1,1.239990234375],"title":"13.2文件系统抽象层","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":258,"linecolor":"ff59c6ff","page":229,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"13.3  Unix文件系统","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":259,"linecolor":"ff59c6ff","page":230,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"13.4  VFS对象及其数据结构","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":260,"linecolor":"ff59c6ff","page":231,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"13.5超级块对象","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":261,"linecolor":"ff59c6ff","page":232,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"13.6超级块操作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":262,"linecolor":"ff59c6ff","page":234,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"13.7索引节点对象","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":263,"linecolor":"ff59c6ff","page":236,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"13.8索引节点操作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":264,"linecolor":"ff59c6ff","page":239,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"13.9目录项对象","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":265,"linecolor":"ff59c6ff","page":239,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"13.9.1目录项状态","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":266,"linecolor":"ff59c6ff","page":240,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"13.9.2目录项缓存","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":267,"linecolor":"ff59c6ff","page":241,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"13.10目录项操作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":268,"linecolor":"ff59c6ff","page":242,"rect":[0,0.239990234375,1,1.239990234375],"title":"13.11文件对象","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":269,"linecolor":"ff59c6ff","page":243,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"13.12文件操作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":270,"linecolor":"ff59c6ff","page":247,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"13.13和文件系统相关的数据结构","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":271,"linecolor":"ff59c6ff","page":249,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"13.14和进程相关的数据结构","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":272,"linecolor":"ff59c6ff","page":250,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"13.15小结","type":8}],"page":227,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"第13章  虚拟文件系统","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":273,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":274,"linecolor":"ff59c6ff","page":251,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"14.1剖析一个块设备","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":275,"linecolor":"ff59c6ff","page":252,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"14.2缓冲区和缓冲区头","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":276,"linecolor":"ff59c6ff","page":254,"rect":[0,0.239990234375,1,1.239990234375],"title":"14.3  bio结构体","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":277,"linecolor":"ff59c6ff","page":255,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"14.3.1  I/O向量","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":278,"linecolor":"ff59c6ff","page":256,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"14.3.2新老方法对比","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":279,"linecolor":"ff59c6ff","page":257,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"14.4请求队列","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":280,"linecolor":"ff59c6ff","page":257,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"14.5  I/O调度程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":281,"linecolor":"ff59c6ff","page":258,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"14.5.1  I/O调度程序的工作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":282,"linecolor":"ff59c6ff","page":258,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"14.5.2  Linus电梯","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":283,"linecolor":"ff59c6ff","page":259,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"14.5.3最终期限I/O调度程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":284,"linecolor":"ff59c6ff","page":261,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"14.5.4预测I/O调度程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":285,"linecolor":"ff59c6ff","page":261,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"14.5.5完全公正的排队I/O调度程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":286,"linecolor":"ff59c6ff","page":262,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"14.5.6空操作的I/O调度程序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":287,"linecolor":"ff59c6ff","page":262,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"14.5.7  I/O调度程序的选择","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":288,"linecolor":"ff59c6ff","page":263,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"14.6小结","type":8}],"page":251,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"第14章  块I/O层","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":289,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":290,"linecolor":"ff59c6ff","page":264,"rect":[0,0.239990234375,1,1.239990234375],"title":"15.1地址空间","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":291,"linecolor":"ff59c6ff","page":265,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"15.2内存描述符","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":292,"linecolor":"ff59c6ff","page":266,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"15.2.1分配内存描述符","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":293,"linecolor":"ff59c6ff","page":267,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"15.2.2撤销内存描述符","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":294,"linecolor":"ff59c6ff","page":267,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"15.2.3  mm_struct与内核线程","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":295,"linecolor":"ff59c6ff","page":268,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"15.3虚拟内存区域","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":296,"linecolor":"ff59c6ff","page":268,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"15.3.1  VMA标志","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":297,"linecolor":"ff59c6ff","page":270,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"15.3.2  VMA操作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":298,"linecolor":"ff59c6ff","page":271,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"15.3.3内存区域的树型结构和内存区域的链表结构","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":299,"linecolor":"ff59c6ff","page":271,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"15.3.4实际使用中的内存区域","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":300,"linecolor":"ff59c6ff","page":272,"rect":[0,0.239990234375,1,1.239990234375],"title":"15.4操作内存区域","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":301,"linecolor":"ff59c6ff","page":273,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"15.4.1  find_vmaO","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":302,"linecolor":"ff59c6ff","page":274,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"15.4.2  find_vma_prevO","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":303,"linecolor":"ff59c6ff","page":274,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"15.4.3  find_vma_intersectionO","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":304,"linecolor":"ff59c6ff","page":275,"rect":[0,0.239990234375,1,1.239990234375],"title":"15.5  mmapO和do_mmapO：创建地址区间","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":305,"linecolor":"ff59c6ff","page":276,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"15.6  mummapO和do_mummapO：删除地址区间","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":306,"linecolor":"ff59c6ff","page":277,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"15.7页表","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":307,"linecolor":"ff59c6ff","page":278,"rect":[0,0.239990234375,1,1.239990234375],"title":"15.8小结","type":8}],"page":264,"rect":[0,0.239990234375,1,1.239990234375],"title":"第15章  进程地址空间","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":308,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":309,"linecolor":"ff59c6ff","page":279,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"16.1缓存手段","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":310,"linecolor":"ff59c6ff","page":279,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"16.1.1写缓存","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":311,"linecolor":"ff59c6ff","page":280,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"16.1.2缓存回收","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":312,"linecolor":"ff59c6ff","page":281,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"16.2  Linux页高速缓存","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":313,"linecolor":"ff59c6ff","page":281,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"16.2.1  address_space对象","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":314,"linecolor":"ff59c6ff","page":283,"rect":[0,0.239990234375,1,1.239990234375],"title":"16.2.2  address_space操作","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":315,"linecolor":"ff59c6ff","page":284,"rect":[0,0.239990234375,1,1.239990234375],"title":"16.2.3基树","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":316,"linecolor":"ff59c6ff","page":285,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"16.2.4以前的页散列表","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":317,"linecolor":"ff59c6ff","page":285,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"16.3缓冲区高速缓存","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":318,"linecolor":"ff59c6ff","page":285,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"16.4  fiusher线程","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":319,"linecolor":"ff59c6ff","page":287,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"16.4.1膝上型计算机模式","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":320,"linecolor":"ff59c6ff","page":287,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"16.4.2历史上的bdflush、kupdated和pdflush","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":321,"linecolor":"ff59c6ff","page":288,"rect":[0,0.239990234375,1,1.239990234375],"title":"16.4.3避免拥塞的方法：使用多线程","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":322,"linecolor":"ff59c6ff","page":288,"rect":[0,0.239990234375,1,1.239990234375],"title":"16.5小结","type":8}],"page":279,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"第16章  页高速缓存和页回写","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":323,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":324,"linecolor":"ff59c6ff","page":290,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"17.1设备类型","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":325,"linecolor":"ff59c6ff","page":291,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"17.2模块","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":326,"linecolor":"ff59c6ff","page":291,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"17.2.1  Hello，World","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":327,"linecolor":"ff59c6ff","page":292,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"17.2.2构建模块","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":328,"linecolor":"ff59c6ff","page":294,"rect":[0,0.239990234375,1,1.239990234375],"title":"17.2.3安装模块","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":329,"linecolor":"ff59c6ff","page":294,"rect":[0,0.239990234375,1,1.239990234375],"title":"17.2.4产生模块依赖性","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":330,"linecolor":"ff59c6ff","page":295,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"17.2.5载入模块","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":331,"linecolor":"ff59c6ff","page":296,"rect":[0,0.239990234375,1,1.239990234375],"title":"17.2.6管理配置选项","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":332,"linecolor":"ff59c6ff","page":297,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"17.2.7模块参数","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":333,"linecolor":"ff59c6ff","page":299,"rect":[0,0.239990234375,1,1.239990234375],"title":"17.2.8导出符号表","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":334,"linecolor":"ff59c6ff","page":300,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"17.3设备模型","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":335,"linecolor":"ff59c6ff","page":300,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"17.3.1  kobject","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":336,"linecolor":"ff59c6ff","page":301,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"17.3.2  ktype","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":337,"linecolor":"ff59c6ff","page":302,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"17.3.3  kset","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":338,"linecolor":"ff59c6ff","page":302,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"17.3.4  kobject、ktype和kset的相互关系","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":339,"linecolor":"ff59c6ff","page":303,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"17.3.5管理和操作kobject","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":340,"linecolor":"ff59c6ff","page":304,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"17.3.6引用计数","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":341,"linecolor":"ff59c6ff","page":305,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"17.4  sysfs","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":342,"linecolor":"ff59c6ff","page":307,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"17.4.1  sysfs中添加和删除kobject","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":343,"linecolor":"ff59c6ff","page":308,"rect":[-0.7200009822845459,0.719970703125,0.2799990177154541,1.719970703125],"title":"17.4.2向sysfs中添加文件","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":344,"linecolor":"ff59c6ff","page":310,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"17.4.3内核事件层","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":345,"linecolor":"ff59c6ff","page":311,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"17.5小结","type":8}],"page":290,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"第17章  设备与模块","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":346,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":347,"linecolor":"ff59c6ff","page":312,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"18.1准备开始","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":348,"linecolor":"ff59c6ff","page":313,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"18.2内核中的bug","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":349,"linecolor":"ff59c6ff","page":313,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"18.3通过打印来调试","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":350,"linecolor":"ff59c6ff","page":313,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"18.3.1健壮性","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":351,"linecolor":"ff59c6ff","page":314,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"18.3.2日志等级","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":352,"linecolor":"ff59c6ff","page":315,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"18.3.3记录缓冲区","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":353,"linecolor":"ff59c6ff","page":315,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"18.3.4  syslogd和klogd","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":354,"linecolor":"ff59c6ff","page":315,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"18.3.5从printfO到printkO的转换","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":355,"linecolor":"ff59c6ff","page":315,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"18.4  oops","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":356,"linecolor":"ff59c6ff","page":317,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"18.4.1  ksymoops","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":357,"linecolor":"ff59c6ff","page":317,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"18.4.2  kallsyms","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":358,"linecolor":"ff59c6ff","page":318,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"18.5内核调试配置选项","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":359,"linecolor":"ff59c6ff","page":318,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"18.6引发bug并打印信息","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":360,"linecolor":"ff59c6ff","page":319,"rect":[0,0.239990234375,1,1.239990234375],"title":"18.7神奇的系统请求键","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":361,"linecolor":"ff59c6ff","page":320,"rect":[0,0.239990234375,1,1.239990234375],"title":"18.8内核调试器的传奇","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":362,"linecolor":"ff59c6ff","page":320,"rect":[0,0.239990234375,1,1.239990234375],"title":"18.8.1  gdb","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":363,"linecolor":"ff59c6ff","page":321,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"18.8.2  kgdb","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":364,"linecolor":"ff59c6ff","page":321,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"18.9探测系统","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":365,"linecolor":"ff59c6ff","page":321,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"18.9.1用UID作为选择条件","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":366,"linecolor":"ff59c6ff","page":322,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"18.9.2使用条件变量","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":367,"linecolor":"ff59c6ff","page":322,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"18.9.3使用统计量","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":368,"linecolor":"ff59c6ff","page":322,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"18.9.4重复频率限制","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":369,"linecolor":"ff59c6ff","page":323,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"18.10用二分查找法找出引发罪恶的变更","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":370,"linecolor":"ff59c6ff","page":324,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"18.11使用Git进行二分搜索","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":371,"linecolor":"ff59c6ff","page":325,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"18.12当所有的努力都失败时：社区","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":372,"linecolor":"ff59c6ff","page":325,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"18.13小结","type":8}],"page":312,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"第18章  调试","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":373,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":374,"linecolor":"ff59c6ff","page":326,"rect":[0,0.239990234375,1,1.239990234375],"title":"19.1可移植操作系统","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":375,"linecolor":"ff59c6ff","page":327,"rect":[-3.119999885559082,2.8800048828125,-2.119999885559082,3.8800048828125],"title":"19.2  Linux移植史","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":376,"linecolor":"ff59c6ff","page":328,"rect":[-1.2000000476837158,1.20001220703125,-0.20000004768371582,2.20001220703125],"title":"19.3字长和数据类型","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":377,"linecolor":"ff59c6ff","page":330,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"19.3.1不透明类型","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":378,"linecolor":"ff59c6ff","page":331,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"19.3.2指定数据类型","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":379,"linecolor":"ff59c6ff","page":331,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"19.3.3长度明确的类型","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":380,"linecolor":"ff59c6ff","page":332,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"19.3.4  char型的符号问题","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":381,"linecolor":"ff59c6ff","page":332,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"19.4数据对齐","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":382,"linecolor":"ff59c6ff","page":333,"rect":[0,0.239990234375,1,1.239990234375],"title":"19.4.1避免对齐引发的问题","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":383,"linecolor":"ff59c6ff","page":333,"rect":[0,0.239990234375,1,1.239990234375],"title":"19.4.2非标准类型的对齐","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":384,"linecolor":"ff59c6ff","page":333,"rect":[0,0.239990234375,1,1.239990234375],"title":"19.4.3结构体填补","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":385,"linecolor":"ff59c6ff","page":335,"rect":[-2.3999900817871094,2.4000244140625,-1.3999900817871094,3.4000244140625],"title":"19.5字节顺序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":386,"linecolor":"ff59c6ff","page":336,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"19.6时间","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":387,"linecolor":"ff59c6ff","page":337,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"19.7页长度","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":388,"linecolor":"ff59c6ff","page":337,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"19.8处理器排序","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":389,"linecolor":"ff59c6ff","page":338,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"19.9  SMP、内核抢占、高端内存","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":390,"linecolor":"ff59c6ff","page":338,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"19.10小结","type":8}],"page":326,"rect":[0,0.239990234375,1,1.239990234375],"title":"第19章  可移植性","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":391,"linecolor":"ff59c6ff","markups":[{"date":"2022-03-03 18:29:36","docid":0,"id":392,"linecolor":"ff59c6ff","page":339,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"20.1社区","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":393,"linecolor":"ff59c6ff","page":339,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"20.2  Linux编码风格","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":394,"linecolor":"ff59c6ff","page":340,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"20.2.1缩进","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":395,"linecolor":"ff59c6ff","page":340,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"20.2.2  switch语句","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":396,"linecolor":"ff59c6ff","page":341,"rect":[0,0.239990234375,1,1.239990234375],"title":"20.2.3空格","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":397,"linecolor":"ff59c6ff","page":342,"rect":[-1.9199999570846558,1.67999267578125,-0.9199999570846558,2.67999267578125],"title":"20.2.4花括号","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":398,"linecolor":"ff59c6ff","page":343,"rect":[-3.8399999141693115,3.3599853515625,-2.8399999141693115,4.3599853515625],"title":"20.2.5每行代码的长度","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":399,"linecolor":"ff59c6ff","page":343,"rect":[-3.8399999141693115,3.3599853515625,-2.8399999141693115,4.3599853515625],"title":"20.2.6命名规范","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":400,"linecolor":"ff59c6ff","page":343,"rect":[-3.8399999141693115,3.3599853515625,-2.8399999141693115,4.3599853515625],"title":"20.2.7函数","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":401,"linecolor":"ff59c6ff","page":343,"rect":[-3.8399999141693115,3.3599853515625,-2.8399999141693115,4.3599853515625],"title":"20.2.8注释","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":402,"linecolor":"ff59c6ff","page":344,"rect":[-1.9199999570846558,1.67999267578125,-0.9199999570846558,2.67999267578125],"title":"20.2.9  typedef","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":403,"linecolor":"ff59c6ff","page":345,"rect":[-3.8399999141693115,3.3599853515625,-2.8399999141693115,4.3599853515625],"title":"20.2.10多用现成的东西","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":404,"linecolor":"ff59c6ff","page":345,"rect":[-3.8399999141693115,3.3599853515625,-2.8399999141693115,4.3599853515625],"title":"20.2.11在源码中减少使用ifdef","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":405,"linecolor":"ff59c6ff","page":345,"rect":[-3.8399999141693115,3.3599853515625,-2.8399999141693115,4.3599853515625],"title":"20.2.12结构初始化","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":406,"linecolor":"ff59c6ff","page":346,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"20.2.13代码的事后修正","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":407,"linecolor":"ff59c6ff","page":346,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"20.3管理系统","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":408,"linecolor":"ff59c6ff","page":346,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"20.4提交错误报告","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":409,"linecolor":"ff59c6ff","page":347,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"20.5补丁","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":410,"linecolor":"ff59c6ff","page":347,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"20.5.1创建补丁","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":411,"linecolor":"ff59c6ff","page":348,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"20.5.2用Git创建补丁","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":412,"linecolor":"ff59c6ff","page":348,"rect":[-1.9199999570846558,1.91998291015625,-0.9199999570846558,2.91998291015625],"title":"20.5.3提交补丁","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":413,"linecolor":"ff59c6ff","page":349,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"20.6小结","type":8}],"page":339,"rect":[-1.2000000476837158,1.44000244140625,-0.20000004768371582,2.44000244140625],"title":"第20章  补丁、开发和社区","type":8},{"date":"2022-03-03 18:29:36","docid":0,"id":414,"linecolor":"ff59c6ff","page":350,"rect":[-0.479995995759964,0.96002197265625,0.520004004240036,1.96002197265625],"title":"参考资料","type":8}],"maxid":480,"notelinks":[],"scalingratio":50,"title":"LINUX内核设计与实现  原书第3版_12786079","unimportant":[]}